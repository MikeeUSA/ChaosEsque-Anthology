float autocvar_g_vehicles_crash_dmg;
float autocvar_g_vehicles_crush_dmg;
float autocvar_g_vehicles_crush_force;
float autocvar_g_vehicles_delayspawn;
float autocvar_g_vehicles_delayspawn_jitter;
float autocvar_g_vehicles_usetoenter;
float autocvar_g_vehicles_hooktoenter;

float autocvar_g_vehicles_allowdriveby;
float autocvar_g_vehicles_allowdriveby_drvr;
float autocvar_g_vehicles_allowdriveby_pssngr;
float autocvar_g_vehicles_allowdriveby_pssngr_hudnorm;
float autocvar_g_vehicles_allowdriveby_drvr_hudnorm;

var float autocvar_g_vehicles_idletime;
//var float autocvar_g_vehicles_shotgun_damagerate = 0.4;
//var float autocvar_g_vehicles_shotgunautomat_damagerate = 0.4;
//var float autocvar_g_vehicles_pumpshotgun_damagerate = 0.4;
//var float autocvar_g_vehicles_mg_damagerate = 0.5;
//var float autocvar_g_vehicles_hmg_damagerate = 0.75;
//var float autocvar_g_vehicles_g98_damagerate = 0.75;
//var float autocvar_g_vehicles_revolver_damagerate = 0.5;
//var float autocvar_g_vehicles_pistol_damagerate = 0.5;
//var float autocvar_g_vehicles_bigpistol_damagerate = 0.5;
//var float autocvar_g_vehicles_warhammerspiked_damagerate = 0.10;
//var float autocvar_g_vehicles_torch_damagerate = 0.10;
//var float autocvar_g_vehicles_caltrop_damagerate = 0.10;
//var float autocvar_g_vehicles_crossbowdtwr_damagerate = 0.10;
//var float autocvar_g_vehicles_electro_damagerate = 0.30;
//var float autocvar_g_vehicles_hlac_damagerate = 0.30;
//var float autocvar_g_vehicles_laser_damagerate = 0.30;
//var float autocvar_g_vehicles_crylink_damagerate = 0.30;
//var float autocvar_g_vehicles_tuba_damagerate = 0.10;
//var float autocvar_g_vehicles_lightninggun_damagerate = 0.25;

//var float autocvar_g_vehicles_nex_damagerate = 0.5;
//var float autocvar_g_vehicles_uzi_damagerate = 0.5;
//var float autocvar_g_vehicles_m1921_damagerate = 0.5;
//var float autocvar_g_vehicles_pdw_damagerate = 0.5;
//var float autocvar_g_vehicles_rifle_damagerate = 0.75;
//var float autocvar_g_vehicles_minstanex_damagerate = 0.001;
//var float autocvar_g_vehicles_tag_damagerate = 2;
//var float autocvar_g_vehicles_rocketlauncher_damagerate = 2;

//var float autocvar_g_vehicles_raptorcannon_damagerate =  0.30;
//var float autocvar_g_vehicles_racercannon_damagerate =  0.30;
//var float autocvar_g_vehicles_bumbcannon_damagerate =  0.30;
//var float autocvar_g_vehicles_sportstercannon_damagerate =  0.5;

float autocvar_g_vehicles;

void vehicles_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force);
void vehicles_return();
void vehicles_enter();
void vehicles_touch();
void vehicles_reset_colors();
void vehicles_clearrturn();
void vehicles_setreturn();


/** AuxiliaryXhair*
    Send additional points of interest to be drawn, to vehicle owner
**/
float MAX_AXH = 4;
.entity AuxiliaryXhair[MAX_AXH];

float SendAuxiliaryXhair(entity to, float sf)
{

	WriteByte(MSG_ENTITY, ENT_CLIENT_AUXILIARYXHAIR);

	WriteByte(MSG_ENTITY, self.cnt);

	WriteCoord(MSG_ENTITY, self.origin_x);
	WriteCoord(MSG_ENTITY, self.origin_y);
	WriteCoord(MSG_ENTITY, self.origin_z);

    WriteByte(MSG_ENTITY, rint(self.colormod_x * 255));
    WriteByte(MSG_ENTITY, rint(self.colormod_y * 255));
    WriteByte(MSG_ENTITY, rint(self.colormod_z * 255));

    return TRUE;
}

void UpdateAuxiliaryXhair(entity own, vector loc, vector clr, float axh_id)
{
    if (clienttype(own) != CLIENTTYPE_REAL)
        return;

    entity axh;

    axh_id = bound(0, axh_id, MAX_AXH);
    axh = own.(AuxiliaryXhair[axh_id]);

    if(axh == world || wasfreed(axh))  // MADNESS? THIS IS QQQQCCCCCCCCC (wasfreed, why do you exsist?)
    {
        axh                     = spawn();
        axh.cnt                 = axh_id;
        axh.drawonlytoclient    = own;
        axh.owner               = own;
        Net_LinkEntity(axh, FALSE, 0, SendAuxiliaryXhair);
    }

    setorigin(axh, loc);
    axh.colormod            = clr;
    axh.SendFlags           = 0x01;
    own.(AuxiliaryXhair[axh_id]) = axh;
}

/*
// SVC_TEMPENTITY based, horrible with even 50 ping. hm.
// WriteByte(MSG_ONE, SVC_TEMPENTITY) uses reliable messagess, never use for thinsg that need continous updates.
void SendAuxiliaryXhair2(entity own, vector loc, vector clr, float axh_id)
{
	msgexntity = own;

	WriteByte(MSG_ONE, SVC_TEMPENTITY);
	WriteByte(MSG_ONE, TE_CSQC_AUXILIARYXHAIR);

	WriteByte(MSG_ONE, axh_id);

	WriteCoord(MSG_ONE, loc_x);
	WriteCoord(MSG_ONE, loc_y);
	WriteCoord(MSG_ONE, loc_z);

    WriteByte(MSG_ONE, rint(clr_x * 255));
    WriteByte(MSG_ONE, rint(clr_y * 255));
    WriteByte(MSG_ONE, rint(clr_z * 255));

}
*/
// End AuxiliaryXhair

/**
    Notifies the client that he enterd a vehicle, and sends
    realavent data.

    only sends vehicle_id atm (wich is a HUD_* constant, ex. HUD_SPIDERBOT)
**/
void CSQCVehicleSetup(entity own, float vehicle_id)
{
    if (clienttype(own) != CLIENTTYPE_REAL)
        return;
	
	msg_entity = own;

	WriteByte(MSG_ONE, SVC_TEMPENTITY);
	WriteByte(MSG_ONE, TE_CSQC_VEHICLESETUP);
	if(vehicle_id != 0)
	    WriteByte(MSG_ONE, vehicle_id);        
	else
        WriteByte(MSG_ONE, 1 + own.vehicle.vehicle_weapon2mode + HUD_VEHICLE_LAST);
}

/** vehicles_locktarget

    Generic target locking.

    Figure out if what target is "locked" (if any), for missile tracking as such.

    after calling, "if(self.lock_target != world && self.lock_strength == 1)" mean
    you have a locked in target.

    Exspects a crosshair_trace() or equivalent to be
    dont before calling.

**/
.entity lock_target;
.float  lock_strength;
.float  lock_time;
.float  lock_soundtime;
float	DAMAGE_TARGETDRONE = 10;

vector targetdrone_getnewspot()
{

	vector spot;
	float i;
	for(i = 0; i < 100; ++i)
	{
		spot = self.origin + randomvec() * 1024;
		tracebox(spot, self.mins, self.maxs, spot, MOVE_NORMAL, self);
		if(trace_fraction == 1.0 && trace_startsolid == 0 && trace_allsolid == 0)
			return spot;
	}
	return self.origin;
}

#if 0
void targetdrone_think();
void targetdrone_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force);
void targetdrone_renwe()
{
	self.think = targetdrone_think;
	self.nextthink = time + 0.1;
	setorigin(self, targetdrone_getnewspot());
	self.health = 200;
	self.takedamage = DAMAGE_TARGETDRONE;
	self.event_damage = targetdrone_damage;
	self.solid = SOLID_BBOX;
	setmodel(self, "models/runematch/rune.mdl");
	self.effects = EF_LOWPRECISION;
	self.scale = 10;
	self.movetype = MOVETYPE_BOUNCEMISSILE;
	setsize(self, '-100 -100 -100', '100 100 100');

}
void targetdrone_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
	self.health -= damage;
	if(self.health <= 0)
	{
		pointparticles(particleeffectnum("explosion_medium"), self.origin, '0 0 0', 1);

		if(!self.cnt)
			remove(self);
		else
		{
			self.think = targetdrone_renwe;
			self.nextthink = time + 1 + random() * 2;
			self.solid = SOLID_NOT;
			setmodel(self, "");
		}
	}
}
entity targetdrone_getfear()
{
	entity fear;
	float i;

	for(i = 64; i <= 1024; i += 64)
	{
		fear = findradius(self.origin, i);
		while(fear)
		{
			if(fear.bot_dodge)
				return fear;

			fear = fear.chain;
		}
	}

	return world;
}
void targetdrone_think()
{
	self.nextthink = time + 0.1;

	if(self.wp00)
	if(self.wp00.deadflag != DEAD_NO)
		self.wp00 = targetdrone_getfear();

	if(!self.wp00)
		self.wp00 = targetdrone_getfear();

	vector newdir;

	if(self.wp00)
		newdir = steerlib_push(self.wp00.origin) + randomvec() * 0.75;
	else
		newdir = randomvec() * 0.75;

	newdir = newdir * 0.5 + normalize(self.velocity) * 0.5;

	if(self.wp00)
		self.velocity = normalize(newdir) * (500 + (1024 / min(vlen(self.wp00.origin - self.origin), 1024)) * 700);
	else
		self.velocity = normalize(newdir) * 750;

	tracebox(self.origin, self.mins, self.maxs, self.origin + self.velocity * 2, MOVE_NORMAL, self);
	if(trace_fraction != 1.0)
		self.velocity = self.velocity * -1;

	//normalize((normalize(self.velocity) * 0.5 + newdir * 0.5)) * 750;
}

void targetdrone_spawn(vector _where, float _autorenew)
{
	entity drone = spawn();
	setorigin(drone, _where);
	drone.think = targetdrone_renwe;
	drone.nextthink = time + 0.1;
	drone.cnt = _autorenew;
}
#endif

void vehicles_locktarget(float incr, float decr, float _lock_time)
{
    if(self.lock_target && self.lock_target.deadflag != DEAD_NO)
    {
        self.lock_target    = world;
        self.lock_strength  = 0;
        self.lock_time      = 0;
    }

    if(self.lock_time > time)
    {
        if(self.lock_target)
        if(self.lock_soundtime < time)
        {
            self.lock_soundtime = time + 0.5;
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self.owner, "vehicles/locked.wav");
	    }
        }

        return;
    }

    if(trace_ent != world)
    {
        if(teamplay && trace_ent.team == self.team)
            trace_ent = world;

        if(trace_ent.deadflag != DEAD_NO)
            trace_ent = world;

        if not (trace_ent.vehicle_flags & VHF_ISVEHICLE ||
				trace_ent.turrcaps_flags & TFL_TURRCAPS_ISTURRET ||
				trace_ent.takedamage == DAMAGE_TARGETDRONE)
            trace_ent = world;
    }

    if(self.lock_target == world && trace_ent != world)
        self.lock_target = trace_ent;

    if(self.lock_target && trace_ent == self.lock_target)
    {
        if(self.lock_strength != 1 && self.lock_strength + incr >= 1)
        {
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self.owner, "vehicles/lock.wav");
	    }
            self.lock_soundtime = time + 0.8;
        }
        else if (self.lock_strength != 1 && self.lock_soundtime < time)
        {
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self.owner, "vehicles/locking.wav");
	    }
            self.lock_soundtime = time + 0.3;
        }

    }

    // Have a locking target
    // Trace hit current target
    if(trace_ent == self.lock_target && trace_ent != world)
    {
        self.lock_strength = min(self.lock_strength + incr, 1);
        if(self.lock_strength == 1)
            self.lock_time = time + _lock_time;
    }
    else
    {
        if(trace_ent)
            self.lock_strength = max(self.lock_strength - decr * 2, 0);
        else
            self.lock_strength = max(self.lock_strength - decr, 0);

        if(self.lock_strength == 0)
            self.lock_target = world;
    }
}

void vehicles_locktarget_for_handweapon(float incr, float decr, float _lock_time)
{
    //Similar to vehicles_locktarget, but for handheld weapons 
    if(self.lock_target && self.lock_target.deadflag != DEAD_NO)
    {
        self.lock_target    = world;
        self.lock_strength  = 0;
        self.lock_time      = 0;
    }

    if(self.lock_time > time)
    {
        if(self.lock_target)
        if(self.lock_soundtime < time)
        {
            self.lock_soundtime = time + 0.5;
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self, "vehicles/locked.wav");
	    }
        }

        return;
    }

    if(trace_ent != world)
    {
        if(teamplay && trace_ent.team == self.team)
            trace_ent = world;

        if(trace_ent.deadflag != DEAD_NO)
            trace_ent = world;

        if not (trace_ent.vehicle_flags & VHF_ISVEHICLE ||
				trace_ent.turrcaps_flags & TFL_TURRCAPS_ISTURRET ||
				trace_ent.takedamage == DAMAGE_TARGETDRONE)
            trace_ent = world;
    }

    if(self.lock_target == world && trace_ent != world)
        self.lock_target = trace_ent;

    if(self.lock_target && trace_ent == self.lock_target)
    {
        if(self.lock_strength != 1 && self.lock_strength + incr >= 1)
        {
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self, "vehicles/lock.wav");
	    }
            self.lock_soundtime = time + 0.8;
        }
        else if (self.lock_strength != 1 && self.lock_soundtime < time)
        {
	    if ((clienttype(self.owner) != CLIENTTYPE_NOTACLIENT)) {
            	play2(self, "vehicles/locking.wav");
	    }
            self.lock_soundtime = time + 0.3;
        }

    }

    // Have a locking target
    // Trace hit current target
    if(trace_ent == self.lock_target && trace_ent != world)
    {
        self.lock_strength = min(self.lock_strength + incr, 1);
        if(self.lock_strength == 1)
            self.lock_time = time + _lock_time;
    }
    else
    {
        if(trace_ent)
            self.lock_strength = max(self.lock_strength - decr * 2, 0);
        else
            self.lock_strength = max(self.lock_strength - decr, 0);

        if(self.lock_strength == 0)
            self.lock_target = world;
    }
}

#define VEHICLE_UPDATE_PLAYER(ply,fld,vhname) \
ply.vehicle_##fld = (self.vehicle_##fld / autocvar_g_vehicle_##vhname##_##fld) * 100

#define vehicles_sweap_collision(orig,vel,dt,acm,mult) \
traceline(orig, orig + vel * dt, MOVE_NORMAL, self); \
if(trace_fraction != 1) \
    acm += normalize(self.origin - trace_endpos) * (vlen(vel) * mult)

// Hover movement support
float  force_fromtag_power;
float  force_fromtag_normpower;
vector force_fromtag_origin;
vector vehicles_force_fromtag_hover(string tag_name, float spring_length, float max_power)
{
    force_fromtag_origin = gettaginfo(self, gettagindex(self, tag_name));
    v_forward  = normalize(v_forward) * -1;
    traceline(force_fromtag_origin, force_fromtag_origin - (v_forward  * spring_length), MOVE_NORMAL, self);

    force_fromtag_power = (1 - trace_fraction) * max_power;
    force_fromtag_normpower = force_fromtag_power / max_power;

    //te_lightning1(world, force_fromtag_origin, force_fromtag_origin + v_forward  * spring_length);

    return v_forward  * force_fromtag_power;
}

// Experimental hovermode wich uses attraction/repulstion from surface insted of gravity/repulsion
// Can possibly be use to move abt any surface (inclusing walls/celings)
vector vehicles_force_fromtag_maglev(string tag_name, float spring_length, float max_power)
{

    force_fromtag_origin = gettaginfo(self, gettagindex(self, tag_name));
    v_forward  = normalize(v_forward) * -1;
    traceline(force_fromtag_origin, force_fromtag_origin - (v_forward  * spring_length), MOVE_NORMAL, self);

    // TODO - this may NOT be compatible with wall/celing movement, unhardcode 0.25 (engine count multiplier)
    if(trace_fraction == 1.0)
    {
        force_fromtag_normpower = -0.25;
        return '0 0 -200';
    }

    force_fromtag_power = ((1 - trace_fraction) - trace_fraction) * max_power;
    force_fromtag_normpower = force_fromtag_power / max_power;

    return v_forward  * force_fromtag_power;
}

// Generic vehile projectile system
void vehicles_projectile_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
    // Ignore damage from oterh projectiles from my owner (dont mess up volly's)
    if(inflictor.owner == self.owner)
        return;

    self.health -= damage;
    self.velocity += force;
    if(self.health < 1)
    {
        self.takedamage = DAMAGE_NO;
        self.event_damage = func_null;
        self.think = self.use;
        self.nextthink = time;
    }
}

void vehicles_projectile_explode()
{
    if(self.owner && other != world)
    {
        if(other == self.owner.vehicle)
            return;

        if(other == self.owner.vehicle.tur_head)
            return;
    }

	PROJECTILE_TOUCH;

	self.event_damage = func_null;
    RadiusDamage (self, self.realowner, self.shot_dmg, 0, self.shot_radius, self, self.shot_force, self.totalfrags, other);
    if (self.totalfrags == DEATH_SBROCKET
    || self.totalfrags == DEATH_WAKIROCKET)
    {
    	OilFire_explosion_spawnoilburnermaybe(self);
    } else if (self.totalfrags == DEATH_RAPTOR_CANNON
    || self.totalfrags == DEATH_BUMB_GUN
    || self.totalfrags == DEATH_WAKIGUN)
    {
    	Chemical_flash_maybe(self);
    } 

    remove (self);
}

entity vehicles_projectile(string _mzlfx, string _mzlsound,
                           vector _org, vector _vel,
                           float _dmg, float _radi, float _force,  float _size,
                           float _deahtype, float _projtype, float _health,
                           float _cull, float _clianim, entity _owner)
{
    entity proj;

    proj = spawn();

    PROJECTILE_MAKETRIGGER(proj);
    setorigin(proj, _org);

    proj.shot_dmg         = _dmg;
    proj.shot_radius      = _radi;
    proj.shot_force       = _force;
    proj.totalfrags       = _deahtype;
    proj.solid            = SOLID_BBOX;
    proj.movetype         = MOVETYPE_FLYMISSILE;
    proj.flags            = FL_PROJECTILE;
    proj.bot_dodge        = TRUE;
    proj.bot_dodgerating  = _dmg;
    proj.velocity         = _vel;
    proj.touch            = vehicles_projectile_explode;
    proj.use              = vehicles_projectile_explode;
    proj.owner            = self;
    proj.realowner        = _owner;
    proj.think            = SUB_Remove;
    proj.nextthink        = time + 30;

    if(_health)
    {
        proj.takedamage       = DAMAGE_AIM;
        proj.event_damage     = vehicles_projectile_damage;
        proj.health           = _health;
    }
    else
        proj.flags           = FL_PROJECTILE | FL_NOTARGET;

    if(_mzlsound)
        sound (self, CH_WEAPON_A, _mzlsound, VOL_BASE, ATTN_NORM);

    if(_mzlfx)
        pointparticles(particleeffectnum(_mzlfx), proj.origin, proj.velocity, 1);


    setsize (proj, '-1 -1 -1' * _size, '1 1 1' * _size);

    CSQCProjectile(proj, _clianim, _projtype, _cull);

    return proj;
}
// End generic vehile projectile system

/** vehicles_spawn
    Exetuted for all vehicles on (re)spawn.
    Sets defaults for newly spawned units.
**/
void vehicles_spawn()
{
    dprint("Spawning vehicle: ", self.netname, "\n");

    // De-own & reset
    self.vehicle_hudmodel.viewmodelforclient = self;

    self.vehicle_lastowner  = world; //Chaos-Esque Mod Change
    self.owner              = world;
    self.touch              = vehicles_touch;
    self.event_damage       = vehicles_damage;
    self.iscreature         = TRUE;
    self.teleportable       = FALSE; // no teleporting for vehicles, too buggy
    self.damagedbycontents	= TRUE;
    self.movetype           = MOVETYPE_WALK;
    self.solid              = SOLID_SLIDEBOX;
    self.takedamage         = DAMAGE_AIM;
	self.deadflag           = DEAD_NO;
    self.bot_attack         = TRUE;
    self.flags              = FL_NOTARGET;
    self.avelocity          = '0 0 0';
    self.velocity           = '0 0 0';

    // Reset locking
    self.lock_strength      = 0;
    self.lock_target        = world;
    self.misc_bulletcounter = 0;

    // Return to spawn
    self.angles             = self.pos2;
    setorigin(self, self.pos1 + '0 0 0');
    // Show it
    pointparticles(particleeffectnum("teleport"), self.origin + '0 0 64', '0 0 0', 1);
    
    if(self.vehicle_controller)
        self.team = self.vehicle_controller.team;
       
    vehicles_reset_colors();
    
    //Chaos-Esque Mod Change
    if (self.vehicle_autocolor > 1) {
    	self.colormap = self.vehicle_autocolor;
	//Colormap = 1024 + pants + shirt * 16
    }
    //Chaos-Esque Mod Change
    self.vehicle_spawn(VHSF_NORMAL);
}

// Better way of determening whats crushable needed! (fl_crushable?)
float vehicles_crushable(entity e)
{
    if(e.classname == "player")
        return TRUE;
	
    if(e.flags & FL_MONSTER)
        return TRUE;

    return FALSE;
}

float vehicles_lightvehicle(entity e)
{
     if (
	(e.netname == "Challenger")
	|| (e.netname == "CruizerLimo")
	|| (e.netname == "Cruizer")
	|| (e.netname == "FastCar")
	|| (e.netname == "SpeedCar")
	|| (e.netname == "PickupTruck")
	|| (e.netname == "SmallTruck")
	|| (e.netname == "Yugo")
	|| (e.netname == "Wakizashi")
	|| (e.netname == "Sedan")
	|| (e.netname == "Sportster")
	|| (e.netname == "Sparrow")
	|| (e.netname == "R22Heli")
	|| (e.netname == "H125Heli")
	|| (e.netname == "Submersible")
	|| (e.netname == "SpeedBoat")
	|| (e.netname == "AeroCommander")
	|| (e.netname == "Nieuport")
	|| (e.netname == "Farman")
	|| (e.netname == "Fokker")
	|| (e.netname == "Sopwith")
	|| (e.netname == "Eindecker")
	|| (e.netname == "eWheel Turret")
    ){
        return TRUE;
    }

    return FALSE;
}

float vehicles_mediumvehicle(entity e)
{
     if (
	(e.netname == "Raptor")
	|| (e.netname == "Bumblebee")
	|| (e.netname == "Shundi")
	|| (e.netname == "Shenzong")
	|| (e.netname == "BlackHawk")
	|| (e.netname == "MechMAX")
	|| (e.netname == "LightAPC")
	|| (e.netname == "Walker Turret")
    ){
        return TRUE;
    }

    return FALSE;
}

float vehicles_heavyvehicle(entity e)
{
     if (
	(e.netname == "T27")
	|| (e.netname == "TankIV")
	|| (e.netname == "TankA7V")
	|| (e.netname == "Bulldozer")
	|| (e.netname == "Spiderbot")
	|| (e.netname == "LL48")
	|| (e.netname == "LL40")
	|| (e.netname == "LL37")
	|| (e.netname == "LL24")
	|| (e.netname == "LL20")
    ){
        return TRUE;
    }

    return FALSE;
}

void vehilces_impact(float _minspeed, float _speedfac, float _maxpain)
{
    if (trace_dphitq3surfaceflags & Q3SURFACEFLAG_NOIMPACT)
        return;

    if(self.play_time < time)
    {
        float wc = vlen(self.velocity - self.oldvelocity);
        //dprint("oldvel: ", vtos(self.oldvelocity), "\n");
        //dprint("vel: ", vtos(self.velocity), "\n");
        if(_minspeed < wc)
        {
            float take = min(_speedfac * wc, _maxpain);
            Damage (self, world, world, take, DEATH_FALL, self.origin, '0 0 0');
            self.play_time = time + 0.25;

            //dprint("wc: ", ftos(wc), "\n");
            //dprint("take: ", ftos(take), "\n");
        }
    }
}

float vehicles_evalenter(entity enterer)
{
    if((autocvar_g_vehicles_usetoenter == 1) || (autocvar_g_vehicles_hooktoenter == 1)) {
    	if((autocvar_g_vehicles_usetoenter == 1) && (enterer.BUTTON_USE)) {
		return 1;
	} else if((autocvar_g_vehicles_hooktoenter == 1) && (enterer.BUTTON_HOOK)) {
		////Hook button is usually "E" (for "enter!")////
		return 1;
	} else {
		return 0;
	}
    } else if ((autocvar_g_vehicles_usetoenter != 1) && (autocvar_g_vehicles_hooktoenter != 1)) {
    	return 1;
    } else {
    	return 0;
    }
}

.void() vehicle_impact;
void vehicles_touch()
{
    // Vehicle currently in use or rolling
    if((self.owner || (vlen(self.velocity) > autocvar_g_vehicles_maxenterspeed)) && !(self.movetype == MOVETYPE_NONE))
    {
        if(other != world)
        if(vehicles_crushable(other))
        {
            if(vlen(self.velocity) != 0)
                Damage(other, self, self.owner, autocvar_g_vehicles_crush_dmg * (self.mass*(vlen((self.velocity-other.velocity)))*0.0000012), DEATH_VHCRUSH, '0 0 0', normalize(other.origin - self.origin) * autocvar_g_vehicles_crush_force);

		//Force equals Mass times Acceleration
		//Normalized to the dmg value for the racer in the old code
		//(Which did a fixed autocvar_g_vehicles_crush_dmg nomatter what)
		//
		//Note ((X/Z)*(Y/Z)) = (X*Y)/Z^2; Z in this case being 900 (both the mass and speed of the racer to normalize). Thus
		//(self.mass/900)*(vlen(self.velocity)/900)
		//To
		//((self.mass*(vlen(self.velocity)))/810000))
		//And why divide when you can multiply
		//1/810000 = 0.00000123456790123457
		//And why be accurate when you can be inaccurate
		//0.0000012
		//And self.velocity-other.velocity so the other's speed in relation to us is taken into account
            return; // Dont do selfdamage when hitting "soft targets".
        } else if ((vehicles_lightvehicle(other))
	|| (vehicles_mediumvehicle(other))) {
		//This is for when hitting other light vehicles (cars, planes)
		if(vlen(self.velocity) != 0) {
			float dmgalgo;
			float dmgself;
			float dmgother;
		
			float totalmass;
			totalmass = self.mass+other.mass;
			dmgalgo = autocvar_g_vehicles_crash_dmg * (self.mass*(vlen((self.velocity-other.velocity)))*0.0000012);
		
			dmgother = (self.mass/totalmass) * dmgalgo;
			dmgself = (other.mass/totalmass) * dmgalgo;
		
			Damage(other, self, self.owner, dmgother, DEATH_VHCRUSH, '0 0 0', normalize(other.origin - self.origin) * autocvar_g_vehicles_crush_force);
		
			Damage(self, self, self.owner, dmgself, DEATH_VHCRUSH, '0 0 0', normalize(other.origin - self.origin) * autocvar_g_vehicles_crush_force);		
		}
	} else if (vehicles_heavyvehicle(other)) {
		//Heavy vehicles use a different touch() routine,
		//when we hit them with a light or med vehicle,
		//we only hurt ourselves
		if(vlen(self.velocity) != 0) {
			float dmgalgo;
			float dmgself;
			dmgalgo = autocvar_g_vehicles_crash_dmg * (self.mass*(vlen((self.velocity-other.velocity)))*0.0000012);
		
			dmgself = (other.mass/(self.mass+other.mass)) * dmgalgo;
		
			Damage(self, self, self.owner, dmgself, DEATH_VHCRUSH, '0 0 0', normalize(other.origin - self.origin) * autocvar_g_vehicles_crush_force);		
		}
	}

        if(self.play_time < time)
        if(self.vehicle_impact)
            self.vehicle_impact();

        return;
    }

    if(other.classname != "player")
        return;

    if(other.deadflag != DEAD_NO)
        return;
	
    if(other.frozen)
        return;

    if(other.vehicle != world)
        return;

    if (vehicles_evalenter(other)) {
    	vehicles_enter();
    } else {
    	return;
    }
}
var float autocvar_g_vehicles_allow_bots = 0;
void vehicles_enter()
{
   // Remove this when bots know how to use vehicles
   
    if (clienttype(other) == CLIENTTYPE_BOT)    
        if (autocvar_g_vehicles_allow_bots)
            dprint("Bot enters vehicle\n"); // This is where we need to disconnect (some, all?) normal bot AI and hand over to vehicle's _aiframe()
        else
            return;

    if(other.health <= g_bloodloss)
    	return; //Crashes due to nullfunc in player prethink otherwise
	
    if(self.phase > time)
        return;

    if(teamplay)
    if(self.team)
    if(self.team != other.team)
        return;

    RemoveGrapplingHook(other);

    //self.vehicle_ammo1   = 0;
    //self.vehicle_ammo2   = 0;
    //self.vehicle_reload1 = 0;
    //self.vehicle_reload2 = 0;
    //self.vehicle_energy  = 0;
    
    self.vehicle_allowdriveby = 0;

    self.owner          = other;
    self.switchweapon   = other.switchweapon;

    // .viewmodelforclient works better.
    //self.vehicle_hudmodel.drawonlytoclient = self.owner;

    self.vehicle_hudmodel.viewmodelforclient = self.owner;

    self.event_damage         = vehicles_damage;
    self.nextthink            = 0;
    self.owner.angles         = self.angles;
    self.owner.takedamage     = DAMAGE_NO;
    self.owner.solid          = SOLID_NOT;
    self.owner.movetype       = MOVETYPE_NOCLIP;
    self.owner.alpha          = -1;
    self.owner.vehicle        = self;
    self.owner.event_damage   = func_null;
    self.owner.view_ofs       = '0 0 0';
    
    //Chaos-Esque Mod Change
    //1024 means gray, it's the default value
    if ((self.colormap == 1024 && self.vehicle_autocolor == 1) 
    	|| (self.vehicle_autocolor == -1 && (self.vehicle_lastowner != self.owner))
    	|| self.vehicle_autocolor == -3
	|| self.vehicle_autocolor == -4)
	{
    	//If we have autocolor set to -1 we set the color whenever anyone enters to their color
	//If -1 is set and the player leaves but then re-enters the vehic we won't change color
	//From whatever it was allready set to (so they can paint it and keep that color-scheme
	//-4 works the same as -1 but will reset color regardless
    	self.colormap             = self.owner.colormap;
	
    	if(self.tur_head)
        	self.tur_head.colormap    = self.owner.colormap;
    }
    // //print(etos(self.vehicle_lastowner)," vehicle_lastowner and owner ",  etos(self.owner), "\n");
    //Chaos-Esque Mod Change

    self.owner.hud            = self.hud;
    self.owner.PlayerPhysplug = self.PlayerPhysplug;

    self.owner.vehicle_ammo1    = self.vehicle_ammo1;
    self.owner.vehicle_ammo2    = self.vehicle_ammo2;
    self.owner.vehicle_reload1  = self.vehicle_reload1;
    self.owner.vehicle_reload2  = self.vehicle_reload2;
    self.owner.vehicle_ammo1_max    = self.vehicle_ammo1_max;
    self.owner.vehicle_ammo2_max    = self.vehicle_ammo2_max;
    self.owner.vehicle_ammo1_current    = self.vehicle_ammo1_current;
    self.owner.vehicle_ammo2_current    = self.vehicle_ammo2_current;
    
    // Cant do this, hides attached objects too.
    //self.exteriormodeltoclient = self.owner;
    //self.tur_head.exteriormodeltoclient = self.owner;

    other.flags &~= FL_ONGROUND;
    self.flags  &~= FL_ONGROUND;

    self.team                 = self.owner.team;
    self.flags               -= FL_NOTARGET;
    
    if (clienttype(other) == CLIENTTYPE_REAL)
    {
        msg_entity = other;
        WriteByte (MSG_ONE, SVC_SETVIEWPORT);
        WriteEntity(MSG_ONE, self.vehicle_viewport);
                
        WriteByte (MSG_ONE, SVC_SETVIEWANGLES);
        if(self.tur_head)
        {
            WriteAngle(MSG_ONE, self.tur_head.angles_x + self.angles_x); // tilt
            WriteAngle(MSG_ONE, self.tur_head.angles_y + self.angles_y); // yaw
            WriteAngle(MSG_ONE, 0);                                      // roll
        }
        else
        {
            WriteAngle(MSG_ONE,  self.angles_x * -1); // tilt
            WriteAngle(MSG_ONE,  self.angles_y);      // yaw
            WriteAngle(MSG_ONE,  0);                  // roll
        }
    }

    vehicles_clearrturn();

    CSQCVehicleSetup(self.owner, self.hud);
    
    vh_player = other;
    vh_vehicle = self;
    MUTATOR_CALLHOOK(VehicleEnter);
    other = vh_player;
    self = vh_vehicle;

    self.vehicle_enter();
    antilag_clear(other);
}

/** vehicles_findgoodexit
    Locates a valid location for the player to exit the vehicle.
    Will first try prefer_spot, then up 100 random spots arround the vehicle
    wich are in direct line of sight and empty enougth to hold a players bbox
**/
vector vehicles_findgoodexit(vector prefer_spot, float mvtype)
{
    //vector exitspot;
    float mysize;

    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, prefer_spot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
        return prefer_spot;

    mysize = 1.5 * vlen(self.maxs - self.mins);
    float i;
    vector v, v2;
    v2 = 0.5 * (self.absmin + self.absmax);
    for(i = 0; i < 100; ++i)
    {
        v = randomvec();
        v_z = 0;
        v = v2 + normalize(v) * mysize;
        tracebox(v2, PL_MIN, PL_MAX, v, mvtype, self.owner);
        if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
            return v;
    }

    /*
    exitspot = (self.origin + '0 0 48') + v_forward * mysize;
    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, exitspot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
        return exitspot;

    exitspot = (self.origin + '0 0 48') - v_forward * mysize;
    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, exitspot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
        return exitspot;

    exitspot = (self.origin + '0 0 48') + v_right * mysize;
    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, exitspot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
        return exitspot;

    exitspot = (self.origin + '0 0 48') - v_right * mysize;
    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, exitspot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
        return exitspot;
    */

    return self.origin;
}

vector vehicles_findgoodexit2(vector prefer_spot, vector other_spot, float othermulti, float mvtype)
{
    //vector exitspot;
    float mysize;
    float i;
    vector v;

    tracebox(self.origin + '0 0 32', PL_MIN, PL_MAX, prefer_spot, MOVE_NORMAL, self.owner);
    if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
    {
    	//print("pspot\n");
        return prefer_spot;
    }

    for(i = 0; i < 100; ++i)
    {
    	
    	v = randomvec() * othermulti;
	v_z = 0;
	//print(vtos(other_spot + v),"\n");
    	tracebox(other_spot + '0 0 32', PL_MIN, PL_MAX, (other_spot + v), MOVE_NORMAL, self.owner);
    	if(trace_fraction == 1.0 && !trace_startsolid && !trace_allsolid)
	{
		//print("pspot2\n");
        	return (other_spot + v);
	}
    }

	//print("dintfin\n");
    return self.origin;
}

/** vehicles_exit
    Standarrd vehicle release fucntion.
    custom code goes in self.vehicle_exit
**/
float vehicles_exit_running;
void vehicles_exit(float eject)
{
    entity _vehicle;
    entity _player;
    entity _oldself = self;
    
    if(vehicles_exit_running)
    {
        dprint("^1vehicles_exit allready running! this is not good..\n");
        return;
    }
    
    vehicles_exit_running = TRUE;
    if(self.flags & FL_CLIENT)
    {
        _vehicle = self.vehicle;
            
        if (_vehicle.vehicle_flags & VHF_PLAYERSLOT)
        {
            _vehicle.vehicle_exit(eject);
            self = _oldself;
            vehicles_exit_running = FALSE;
            return;            
        }
    }
    else
        _vehicle = self;
    
    _player = _vehicle.owner;
    
    self = _vehicle;

    if (_player)
    {
        if (clienttype(_player) == CLIENTTYPE_REAL)
        {
            msg_entity = _player;
            WriteByte (MSG_ONE, SVC_SETVIEWPORT);
            WriteEntity( MSG_ONE, _player);

            WriteByte (MSG_ONE, SVC_SETVIEWANGLES);
            WriteAngle(MSG_ONE, 0);
            WriteAngle(MSG_ONE, _vehicle.angles_y);
            WriteAngle(MSG_ONE, 0);
        }
        
        setsize(_player, PL_MIN,PL_MAX);

	_player.vehicle_playerisgunner = 0;
	_player.vehicle_playergunnervehicle  = world;
	_player.vehicle_changeseat	= func_null;
        _player.takedamage     = DAMAGE_AIM;
        _player.solid          = SOLID_SLIDEBOX;
        _player.movetype       = MOVETYPE_WALK;
        _player.effects        &~= EF_NODRAW;
        _player.alpha          = 1;
        _player.PlayerPhysplug = func_null;
        _player.vehicle        = world;
        _player.view_ofs       = PL_VIEW_OFS;
        _player.event_damage   = PlayerDamage;
        _player.hud            = HUD_NORMAL;
        _player.switchweapon   = _vehicle.switchweapon;
	_player.vehicle_ammo1_max    = 0;
	_player.vehicle_ammo2_max    = 0;
	_player.vehicle_ammo1_current    = 0;
	_player.vehicle_ammo2_current    = 0;
	_player.vehicle_allowdriveby = 0;

        CSQCVehicleSetup(_player, HUD_NORMAL);
    }
    _vehicle.flags |= FL_NOTARGET;
    
    if(_vehicle.deadflag == DEAD_NO)
        _vehicle.avelocity          = '0 0 0';
    
    _vehicle.tur_head.nodrawtoclient             = world;
    
    if(!teamplay)
        _vehicle.team = 0;
    else

    vh_player = _player;
    vh_vehicle = _vehicle;
    MUTATOR_CALLHOOK(VehicleExit);
    _player = vh_player;
    _vehicle = vh_vehicle;

    _vehicle.team = _vehicle.tur_head.team;
        
    sound (_vehicle, CH_TRIGGER_SINGLE, "misc/null.wav", 1, ATTN_NORM);
    _vehicle.vehicle_hudmodel.viewmodelforclient = _vehicle;	
    _vehicle.phase = time + 1;
    
    _vehicle.vehicle_exit(eject);
    
    vehicles_setreturn();
    
    //Chaos-Esque Mod Edits
    if (self.vehicle_autocolor == -2 || self.vehicle_autocolor == -3) {
    	//If this is set to -2 or -3 we reset the colors on vehic exit.
	//-3 sets on vehic entrance aswell
	//-1 only sets on vehic enterance
    	vehicles_reset_colors();
    }
    _vehicle.vehicle_lastowner = _player;
    //Chaos-Esque Mod Edits
    
    _vehicle.owner = world;
    self = _oldself;
    
    vehicles_exit_running = FALSE;
}

////This is for replenishing the ammo stocks of a vehicle from the player's ammo
//Player to take ammo from, Vehicle to give ammo to,
//Ammo Type, Float to add ammo to, How much ammo to take,
//How much to divide ammo by (conversion factor)
////Example: give 3 nails, divide by 3, give vehicle 1 extra ammo
void vehicles_replenishAmmo(entity player, entity vehic, .float ammo_type, .float vh_ammocurrent, .float vh_ammomax, float ammo_use, float ammo_convert)
{
	float ammo_converted;
	if(player.ammo_type >= ammo_use) {
		ammo_converted = (ammo_use/ammo_convert);
		if (vehic.vh_ammocurrent <= (vehic.vh_ammomax - ammo_converted)) {
			player.ammo_type -= ammo_use;
			vehic.vh_ammocurrent += ammo_converted;
		} else if(vehic.pushltime < time) {
			// Don't flood the connection with the messages
			sprint(player,"Ammo reserve maximal\n");
			vehic.pushltime = time + 0.25;
		}
	} else {
		if(vehic.pushltime < time)  // Don't flood the connection with the messages
		{
			sprint(player,"Not enough ammo to replenish reserve\n");
			vehic.pushltime = time + 0.25;
		}
	}
}

void vehicles_regen(float timer, .float regen_field, float field_max, float rpause, float regen, float delta_time, float _healthscale, .float vh_ammomax, .float vh_ammocurrent)
{
    if(self.vh_ammocurrent > 0 || self.vh_ammomax == 0)
    if(self.regen_field < field_max)
    if(timer + rpause < time)
    {
   	if((self.vh_ammomax != 0) && (self.vh_ammocurrent <= 0))
	{
		//print("Not enough ammo to reload", ftos(self.vh_ammocurrent), "/", ftos(self.vh_ammomax), "\n");
		//Do nothing
	} else {
    
       		if(_healthscale)
        	    regen = regen * (self.vehicle_health / self.tur_health);
            
        	self.regen_field = min(self.regen_field + regen * delta_time, field_max);

        	if(self.owner)
        	    self.owner.regen_field = (self.regen_field / field_max) * 100;
	    
		if (self.vh_ammomax)
			self.vh_ammocurrent = self.vh_ammocurrent - (regen * delta_time);
		
		//print("Ammo Max: ", ftos(self.vh_ammomax), "\n");
		//print("Ammo Current: ", ftos(self.vh_ammocurrent), "\n");
	}
    }
}

void shieldhit_think()
{
    self.alpha -= 0.1;
    if (self.alpha <= 0)
    {
        //setmodel(self, "");
        self.alpha = -1;
        self.effects |= EF_NODRAW;
    }
    else
    {
        self.nextthink = time + 0.1;
    }
}

void vehicles_painframe()
{
    if(self.owner.vehicle_health <= 50)
    if(self.pain_frame < time)
    {
        float _ftmp;
        _ftmp = self.owner.vehicle_health / 50;
        self.pain_frame = time + 0.1 + (random() * 0.5 * _ftmp);
        pointparticles(particleeffectnum("smoke_small"), (self.origin + (randomvec() * 80)), '0 0 0', 1);

        if(self.vehicle_flags & VHF_DMGSHAKE)
            self.velocity += randomvec() * 30;

        if(self.vehicle_flags & VHF_DMGROLL)
            if(self.vehicle_flags & VHF_DMGHEADROLL)
                self.tur_head.angles += randomvec();
            else
                self.angles += randomvec();

    }
}

float vehicles_evaldamage(float damage, float deathtype)
{
    if(DEATH_ISWEAPON(deathtype, WEP_NEX))
        damage *= autocvar_g_vehicles_nex_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_UZI))
        damage *= autocvar_g_vehicles_uzi_damagerate;
    
    if(DEATH_ISWEAPON(deathtype, WEP_CARBINE))
        damage *= autocvar_g_vehicles_carbine_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SHOTGUN))
        damage *= autocvar_g_vehicles_shotgun_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SHOTGUNAUTOMAT))
        damage *= autocvar_g_vehicles_shotgunautomat_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_PUMPSHOTGUN))
        damage *= autocvar_g_vehicles_pumpshotgun_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPORTSHOTGUN))
        damage *= autocvar_g_vehicles_sportshotgun_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STREETSWEEPER))
        damage *= autocvar_g_vehicles_streetsweeper_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WINCHESTER1897))
        damage *= autocvar_g_vehicles_winchester1897_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M1897TRENCHGUN))
        damage *= autocvar_g_vehicles_m1897trenchgun_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_ITHACASTAKEOUT))
        damage *= autocvar_g_vehicles_ithacastakeout_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SPAS12))
        damage *= autocvar_g_vehicles_spas12_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MG))
        damage *= autocvar_g_vehicles_mg_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_HMG))
        damage *= autocvar_g_vehicles_hmg_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_LEWISMG))
        damage *= autocvar_g_vehicles_lewismg_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_HELLRIEGELSMG))
        damage *= autocvar_g_vehicles_hellriegelsmg_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MG0815))
        damage *= autocvar_g_vehicles_mg0815_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_PISTOL))
        damage *= autocvar_g_vehicles_pistol_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_BIGPISTOL))
        damage *= autocvar_g_vehicles_bigpistol_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_LONGPISTOL))
        damage *= autocvar_g_vehicles_longpistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LARGEPISTOL))
        damage *= autocvar_g_vehicles_largepistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTPISTOL))
        damage *= autocvar_g_vehicles_lightpistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FIVESEVENPISTOL))
        damage *= autocvar_g_vehicles_fivesevenpistol_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_MAUSERPISTOL))
        damage *= autocvar_g_vehicles_mauserpistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M9PISTOL))
        damage *= autocvar_g_vehicles_m9pistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M93RPISTOL))
        damage *= autocvar_g_vehicles_m93rpistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_BROWNINGHP))
        damage *= autocvar_g_vehicles_browninghp_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTAUTO))
        damage *= autocvar_g_vehicles_lightauto_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_MACHINEPISTOL))
        damage *= autocvar_g_vehicles_machinepistol_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_CZSKORPION))
        damage *= autocvar_g_vehicles_czskorpion_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SVSKORPION))
        damage *= autocvar_g_vehicles_svskorpion_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MICROUZI))
        damage *= autocvar_g_vehicles_microuzi_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_TEC9))
        damage *= autocvar_g_vehicles_tec9_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_POUNDERSMG))
        damage *= autocvar_g_vehicles_poundersmg_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MINIUZI))
        damage *= autocvar_g_vehicles_miniuzi_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_AK47))
        damage *= autocvar_g_vehicles_ak47_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_RPD))
        damage *= autocvar_g_vehicles_rpd_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_PKM))
        damage *= autocvar_g_vehicles_pkm_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M249PARA))
        damage *= autocvar_g_vehicles_m249para_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SVD))
        damage *= autocvar_g_vehicles_svd_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_BAR1918))
        damage *= autocvar_g_vehicles_bar1918_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CHAUCHAT))
        damage *= autocvar_g_vehicles_chauchat_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SHOSHO))
        damage *= autocvar_g_vehicles_shosho_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_AMR18))
        damage *= autocvar_g_vehicles_amr18_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SKS45))
        damage *= autocvar_g_vehicles_sks45_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M82RIFLE))
        damage *= autocvar_g_vehicles_m82rifle_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_AKS74U))
        damage *= autocvar_g_vehicles_aks74u_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M16MINI))
        damage *= autocvar_g_vehicles_m16mini_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPECTRE))
        damage *= autocvar_g_vehicles_spectre_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M16VN))
        damage *= autocvar_g_vehicles_m16vn_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_M16A2))
        damage *= autocvar_g_vehicles_m16a2_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FNSCAR))
        damage *= autocvar_g_vehicles_fnscar_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_G36C))
        damage *= autocvar_g_vehicles_g36c_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_L85A2))
        damage *= autocvar_g_vehicles_l85a2_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STYERAUG))
        damage *= autocvar_g_vehicles_styeraug_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_STYERTMP))
        damage *= autocvar_g_vehicles_styertmp_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_P90))
        damage *= autocvar_g_vehicles_p90_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_FAMAS))
        damage *= autocvar_g_vehicles_famas_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_TT33PISTOL))
        damage *= autocvar_g_vehicles_tt33pistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_REVOLVER))
        damage *= autocvar_g_vehicles_revolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FLINTLOCKPISTOL))
        damage *= autocvar_g_vehicles_flintlockpistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MUSKET))
        damage *= autocvar_g_vehicles_musket_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_TANEGASHIMA))
        damage *= autocvar_g_vehicles_tanegashima_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_NAVY1851REVOLVER))
        damage *= autocvar_g_vehicles_navy1851revolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_R1856REVOLVER))
        damage *= autocvar_g_vehicles_r1856revolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_COLT44REVOLVER))
        damage *= autocvar_g_vehicles_colt44revolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SCHOFIELDREVOLVER))
        damage *= autocvar_g_vehicles_schofieldrevolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MAGNUM))
        damage *= autocvar_g_vehicles_magnum_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_NAGANT1895))
        damage *= autocvar_g_vehicles_nagant1895_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WEBLEY))
        damage *= autocvar_g_vehicles_webley_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WEBLEYLONG))
        damage *= autocvar_g_vehicles_webleylong_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FFMAGNUM))
        damage *= autocvar_g_vehicles_ffmagnum_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_PEPPERBOXREVOLVER))
        damage *= autocvar_g_vehicles_pepperboxrevolver_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LONGBOW))
        damage *= autocvar_g_vehicles_longbow_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_YUMIBOW))
        damage *= autocvar_g_vehicles_yumibow_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTCROSSBOW))
        damage *= autocvar_g_vehicles_lightcrossbow_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_COMPOSITEBOW))
        damage *= autocvar_g_vehicles_compositebow_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CRUDEBOW))
        damage *= autocvar_g_vehicles_crudebow_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M1921))
        damage *= autocvar_g_vehicles_m1921_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M1928))
        damage *= autocvar_g_vehicles_m1928_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M1929))
        damage *= autocvar_g_vehicles_m1929_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_PDW))
        damage *= autocvar_g_vehicles_pdw_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CROSSBOWDTWR))
        damage *= autocvar_g_vehicles_crossbowdtwr_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WARHAMMERSPIKED))
        damage *= autocvar_g_vehicles_warhammerspiked_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CLAWHAMMER))
        damage *= autocvar_g_vehicles_clawhammer_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MORGENSTERN))
        damage *= autocvar_g_vehicles_morgenstern_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SHOOTINGSTAR))
        damage *= autocvar_g_vehicles_shootingstar_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SPIKEDFLAIL))
        damage *= autocvar_g_vehicles_spikedflail_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_MILFLAIL))
        damage *= autocvar_g_vehicles_milflail_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SHININGSTAR))
        damage *= autocvar_g_vehicles_shiningstar_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WARMALLET))
        damage *= autocvar_g_vehicles_warmallet_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPIKEDCLUB))
        damage *= autocvar_g_vehicles_spikedclub_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPIKEDCUDGEL))
        damage *= autocvar_g_vehicles_spikedcudgel_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_GREYIRONMALLET))
        damage *= autocvar_g_vehicles_greyironmallet_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_TETSUBO))
        damage *= autocvar_g_vehicles_tetsubo_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_BRONZECUDGEL))
        damage *= autocvar_g_vehicles_bronzecudgel_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FLANGEDMACE))
        damage *= autocvar_g_vehicles_flangedmace_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CUDGEL))
        damage *= autocvar_g_vehicles_cudgel_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_BAT))
        damage *= autocvar_g_vehicles_bat_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPIKEDMACE))
        damage *= autocvar_g_vehicles_spikedmace_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SAI))
        damage *= autocvar_g_vehicles_sai_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_QUARTERSTAFF))
        damage *= autocvar_g_vehicles_quarterstaff_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_INFANTRYSTAFF))
        damage *= autocvar_g_vehicles_infantrystaff_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_KIDUCHI))
        damage *= autocvar_g_vehicles_kiduchi_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STAFFFLAME))
        damage *= autocvar_g_vehicles_staffflame_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STAFFMAGI))
        damage *= autocvar_g_vehicles_staffmagi_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_ELVENSTAFF))
        damage *= autocvar_g_vehicles_elvenstaff_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_ELVENGLAIVE))
        damage *= autocvar_g_vehicles_elvenglaive_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_CROWBAR))
        damage *= autocvar_g_vehicles_crowbar_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_IRONCROW))
        damage *= autocvar_g_vehicles_ironcrow_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SHACKLES))
        damage *= autocvar_g_vehicles_shackles_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_HANDCUFFS))
        damage *= autocvar_g_vehicles_handcuffs_damagerate;
	
    //if(DEATH_ISWEAPON(deathtype, WEP_MULTITOOL)) //This was commented out for a reason
    //    damage *= autocvar_g_vehicles_multitool_damagerate; //Has to do with building things IIRC (the multitool dmg is for building etc).. maybe because the multitool is a tool and you can go right up and meticulously pull apart a device

    if(DEATH_ISWEAPON(deathtype, WEP_SHORTSWORD))
        damage *= autocvar_g_vehicles_shortsword_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_LONGSWORD))
        damage *= autocvar_g_vehicles_longsword_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_ARMINGSWORD))
        damage *= autocvar_g_vehicles_armingsword_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_CRUSADERSWORD))
        damage *= autocvar_g_vehicles_crusadersword_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_FIGHTERSWORD))
        damage *= autocvar_g_vehicles_fightersword_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SCIMITAR))
        damage *= autocvar_g_vehicles_scimitar_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FALCHION))
        damage *= autocvar_g_vehicles_falchion_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_DADAO))
        damage *= autocvar_g_vehicles_dadao_damagerate;
    if(DEATH_ISWEAPON(deathtype, WEP_PUDAO))
        damage *= autocvar_g_vehicles_dadao_damagerate; //uses same as dadao
	
    if(DEATH_ISWEAPON(deathtype, WEP_BASTARDSWORD))
        damage *= autocvar_g_vehicles_bastardsword_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CLAYMORE))
        damage *= autocvar_g_vehicles_bastardsword_damagerate; //same as above
	
    if(DEATH_ISWEAPON(deathtype, WEP_FLAMBERGE))
        damage *= autocvar_g_vehicles_flamberge_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_DEFENDERSWORD))
        damage *= autocvar_g_vehicles_defendersword_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_IRONKNIFE))
        damage *= autocvar_g_vehicles_ironknife_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_BOWIEKNIFE))
        damage *= autocvar_g_vehicles_bowieknife_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_ELVENSABRE))
        damage *= autocvar_g_vehicles_elvensabre_damagerate;
		
    if(DEATH_ISWEAPON(deathtype, WEP_KATANA))
        damage *= autocvar_g_vehicles_katana_damagerate;
    if(DEATH_ISWEAPON(deathtype, WEP_SHIRASAYA))
        damage *= autocvar_g_vehicles_katana_damagerate; //Uses same as katana
    if(DEATH_ISWEAPON(deathtype, WEP_ZATOICHI))
        damage *= autocvar_g_vehicles_katana_damagerate; //Uses same as katana
	
    if(DEATH_ISWEAPON(deathtype, WEP_ODACHI))
        damage *= autocvar_g_vehicles_odachi_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_NAGAMAKI))
        damage *= autocvar_g_vehicles_nagamaki_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_RAPIER))
        damage *= autocvar_g_vehicles_rapier_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_DAGGER))
        damage *= autocvar_g_vehicles_dagger_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_ARKANSASTOOTHPICK))
        damage *= autocvar_g_vehicles_arkansastoothpick_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_KNIFE))
        damage *= autocvar_g_vehicles_knife_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTSABRE))
        damage *= autocvar_g_vehicles_lightsabre_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTSABREII))
        damage *= autocvar_g_vehicles_lightsabreii_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTSABREIV))
        damage *= autocvar_g_vehicles_lightsabreiv_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTSABREXI))
        damage *= autocvar_g_vehicles_lightsabrexi_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SPEAR))
        damage *= autocvar_g_vehicles_spear_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_YARI))
        damage *= autocvar_g_vehicles_yari_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_POLEAXE))
        damage *= autocvar_g_vehicles_poleaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_BARDICHE))
        damage *= autocvar_g_vehicles_bardiche_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_INFANTRYAXE))
        damage *= autocvar_g_vehicles_infantryaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_ELVENAXE))
        damage *= autocvar_g_vehicles_elvenaxe_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_ELVENHAMMER))
        damage *= autocvar_g_vehicles_elvenhammer_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_KRIEGSHAMMER))
        damage *= autocvar_g_vehicles_kriegshammer_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_BROADAXE))
        damage *= autocvar_g_vehicles_broadaxe_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_WARAXE))
        damage *= autocvar_g_vehicles_waraxe_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SKIRMISHERSAXE))
        damage *= autocvar_g_vehicles_skirmishersaxe_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_BATTLEAXE))
        damage *= autocvar_g_vehicles_battleaxe_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_TEMPLARAXE))
        damage *= autocvar_g_vehicles_templaraxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_DOUBLEBITAXE))
        damage *= autocvar_g_vehicles_doublebitaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_WOODAXE))
        damage *= autocvar_g_vehicles_woodaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_PICKAXE))
        damage *= autocvar_g_vehicles_pickaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_AXE))
        damage *= autocvar_g_vehicles_axe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_BEARDEDAXE))
        damage *= autocvar_g_vehicles_beardedaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CHAINSAW))
        damage *= autocvar_g_vehicles_chainsaw_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_POWERSAW))
        damage *= autocvar_g_vehicles_powersaw_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STONEAXE))
        damage *= autocvar_g_vehicles_stoneaxe_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_TORCH))
        damage *= autocvar_g_vehicles_torch_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CALTROP))
        damage *= autocvar_g_vehicles_caltrop_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_ELECTRO))
        damage *= autocvar_g_vehicles_electro_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_HLAC))
        damage *= autocvar_g_vehicles_hlac_damagerate;
	
    if(deathtype == DEATH_TURRET_AUTOSHLAC)
        damage *= autocvar_g_vehicles_hlac_damagerate;
	
    if(deathtype == DEATH_HURTLASER)
        damage *= autocvar_g_vehicles_hurtlaser_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_LASER))
        damage *= autocvar_g_vehicles_laser_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_CRYLINK))
        damage *= autocvar_g_vehicles_crylink_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_STARBLAST))
        damage *= autocvar_g_vehicles_starblast_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_STARLASE))
        damage *= autocvar_g_vehicles_starlase_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SUNBURST))
        damage *= autocvar_g_vehicles_sunburst_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_SUNBOLT))
        damage *= autocvar_g_vehicles_sunbolt_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CRYPISTOL))
        damage *= autocvar_g_vehicles_crypistol_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_CRYLANCER))
        damage *= autocvar_g_vehicles_crylancer_damagerate;

    //Note: Sunbeam weapon actually uses a hurtlaser, but here for completion
    if(DEATH_ISWEAPON(deathtype, WEP_SUNBEAM))
        damage *= autocvar_g_vehicles_sunbeam_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LIGHTNINGGUN))
        damage *= autocvar_g_vehicles_lightninggun_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_FLAMETHROWER))
        damage *= autocvar_g_vehicles_flamethrower_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_G98))
        damage *= autocvar_g_vehicles_g98_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MOSIN))
        damage *= autocvar_g_vehicles_mosin_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_T17MMRIFLE))
        damage *= autocvar_g_vehicles_t17mmrifle_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_HENRY1860RIFLE))
        damage *= autocvar_g_vehicles_henry1860rifle_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_WINCHESTER1873RIFLE))
        damage *= autocvar_g_vehicles_winchester1873rifle_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_HENRY1860MARESLEG))
        damage *= autocvar_g_vehicles_henry1860maresleg_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_COLTLIGHTNING))
        damage *= autocvar_g_vehicles_coltlightning_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SHARPSRIFLE))
        damage *= autocvar_g_vehicles_sharpsrifle_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_EIGHTGAUGESHOTGUN))
        damage *= autocvar_g_vehicles_eightgaugeshotgun_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_TENGAUGEDOUBLE))
        damage *= autocvar_g_vehicles_tengaugedouble_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_TENGAUGESAWEDOFF))
        damage *= autocvar_g_vehicles_tengaugesawedoff_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_EIGHTGAUGESAWEDOFF))
        damage *= autocvar_g_vehicles_eightgaugesawedoff_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_TARGETPISTOL))
        damage *= autocvar_g_vehicles_targetpistol_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_M1903))
        damage *= autocvar_g_vehicles_m1903_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_LRR))
        damage *= autocvar_g_vehicles_lrr_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_TUBA))
        damage *= autocvar_g_vehicles_tuba_damagerate;
	
    if((deathtype == DEATH_SPORTSTERGUN
	|| (deathtype == (DEATH_SPORTSTERGUN + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_SPORTSTERGUN + HITTYPE_CORESHOT))
	|| (deathtype ==  DEATH_SPORTSTERGUNHV)
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_CORESHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_CORESHOT + HITTYPE_HEADSHOT))
	|| (deathtype ==  DEATH_SPORTSTERGUNLT)
	|| (deathtype == (DEATH_SPORTSTERGUNLT + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNLT + HITTYPE_CORESHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNLT + HITTYPE_CORESHOT + HITTYPE_HEADSHOT))
	))
        damage *= autocvar_g_vehicles_sportstercannon_damagerate;
	
    if(deathtype == DEATH_RAPTOR_CANNON)
        damage *= autocvar_g_vehicles_raptorcannon_damagerate;
	
    if(deathtype == DEATH_BUMB_GUN)
        damage *= autocvar_g_vehicles_bumbcannon_damagerate;
	
    if(deathtype == DEATH_WAKIGUN)
        damage *= autocvar_g_vehicles_racercannon_damagerate;

	
    if(DEATH_ISWEAPON(deathtype, WEP_ROCKET_LAUNCHER))
        damage *= autocvar_g_vehicles_rocketlauncher_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_RIFLE))
        damage *= autocvar_g_vehicles_rifle_damagerate;
        
    if(DEATH_ISWEAPON(deathtype, WEP_MINSTANEX))
        damage *= autocvar_g_vehicles_minstanex_damagerate;

    if(DEATH_ISWEAPON(deathtype, WEP_SEEKER))
        damage *= autocvar_g_vehicles_tag_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_RPG7_LAUNCHER))
        damage *= autocvar_g_vehicles_rpg7launcher_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_RA4_LAUNCHER))
        damage *= autocvar_g_vehicles_ra4launcher_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_DEVASTATOR))
        damage *= autocvar_g_vehicles_devastator_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_HAGAR))
        damage *= autocvar_g_vehicles_hagar_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_HAGAR2))
        damage *= autocvar_g_vehicles_hagar2_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_GRENADE_LAUNCHER))
        damage *= autocvar_g_vehicles_grenadelauncher_damagerate;
	
    if(DEATH_ISWEAPON(deathtype, WEP_MORTAR))
        damage *= autocvar_g_vehicles_mortar_damagerate;

    return damage;
}

void vehicles_removebombs(entity e) 
{
	if(e.bomb1) remove_safely(e.bomb1);
	if(e.bomb2) remove_safely(e.bomb2);
	if(e.bomb3) remove_safely(e.bomb3);
	if(e.bomb4) remove_safely(e.bomb4);
	if(e.bomb5) remove_safely(e.bomb5);
	if(e.bomb6) remove_safely(e.bomb6);
	if(e.bomb7) remove_safely(e.bomb7);
	if(e.bomb8) remove_safely(e.bomb8);
	if(e.bomb9) remove_safely(e.bomb9);
	if(e.bomb10) remove_safely(e.bomb10);
	if(e.bomb11) remove_safely(e.bomb11);
	if(e.bomb12) remove_safely(e.bomb12);
	if(e.bomb13) remove_safely(e.bomb13);
	if(e.bomb14) remove_safely(e.bomb14);
	if(e.bomb15) remove_safely(e.bomb15);
	if(e.bomb16) remove_safely(e.bomb16);
	if(e.bomb17) remove_safely(e.bomb17);
	if(e.bomb18) remove_safely(e.bomb18);
}

void vehicles_removeguns(entity e) 
{
	if(e.gun1) remove_safely(e.gun1);
	if(e.gun2) remove_safely(e.gun2);
	if(e.gun3) remove_safely(e.gun3);
	if(e.gun4) remove_safely(e.gun4);
	if(e.gun5) remove_safely(e.gun5);
	if(e.gun6) remove_safely(e.gun6);
	if(e.gun7) remove_safely(e.gun7);
	if(e.gun8) remove_safely(e.gun8);
	if(e.gun9) remove_safely(e.gun9);
	if(e.gun10) remove_safely(e.gun10);
	if(e.gun11) remove_safely(e.gun11);
	if(e.gun12) remove_safely(e.gun12);
	if(e.gun13) remove_safely(e.gun13);
	if(e.gun14) remove_safely(e.gun14);
	if(e.gun0) remove_safely(e.gun0);  //--Used for pilot secondary on some multi-player tanks
	if(e.gun00) remove_safely(e.gun00);  //--Used for pilot primary on some multi-player tanks
	if(e.gun000) remove_safely(e.gun000);  //--Used for pilot primary on some multi-player tanks
}

void vehicles_removerotors(entity e) 
{
	//front/back
	if(e.rotorboxft) remove_safely(e.rotorboxft);
	if(e.rotorboxmf) remove_safely(e.rotorboxmf);
	if(e.rotorboxmb) remove_safely(e.rotorboxmb);
	if(e.rotorboxbk) remove_safely(e.rotorboxbk);
	
	//side to side
	if(e.rotorboxftr) remove_safely(e.rotorboxftr);
	if(e.rotorboxmfr) remove_safely(e.rotorboxmfr);
	if(e.rotorboxmbr) remove_safely(e.rotorboxmbr);
	if(e.rotorboxbkr) remove_safely(e.rotorboxbkr);
	
	//diagnol 1
	if(e.rotorboxftd1) remove_safely(e.rotorboxftd1);
	if(e.rotorboxmfd1) remove_safely(e.rotorboxmfd1);
	if(e.rotorboxmbd1) remove_safely(e.rotorboxmbd1);
	if(e.rotorboxbkd1) remove_safely(e.rotorboxbkd1);
	
	//diagnol 2
	if(e.rotorboxftd2) remove_safely(e.rotorboxftd2);
	if(e.rotorboxmfd2) remove_safely(e.rotorboxmfd2);
	if(e.rotorboxmbd2) remove_safely(e.rotorboxmbd2);
	if(e.rotorboxbkd2) remove_safely(e.rotorboxbkd2);
	
	//tail rotor
	if(e.rotorboxft_t) remove_safely(e.rotorboxft_t);
	if(e.rotorboxmf_t) remove_safely(e.rotorboxmf_t);
	if(e.rotorboxmid_t) remove_safely(e.rotorboxmid_t);
	if(e.rotorboxmb_t) remove_safely(e.rotorboxmb_t);
	if(e.rotorboxbk_t) remove_safely(e.rotorboxbk_t);
}

void vehicles_remove()
{
    vehicles_clearrturn();

    setmodel(self, "null");
    if(self.hitboxft) remove_safely(self.hitboxft);
    if(self.hitboxbk) remove_safely(self.hitboxbk);
    if(self.hitboxft) remove_safely(self.hitboxmb);
    if(self.hitboxbk) remove_safely(self.hitboxmf);
    if(self.gun1.gun1) remove_safely(self.gun1.gun1); //Gau19 gun usually
    if(self.gun1.gun2) remove_safely(self.gun1.gun2); //Jic
    if(self.gun2.gun1) remove_safely(self.gun2.gun1); //Rotary cannon usually
    if(self.gun2.gun2) remove_safely(self.gun2.gun2); //Jic
    if(self.gun0.gun1) remove_safely(self.gun0.gun1); //Jic --Used for pilot secondary on some multi-player tanks
    if(self.gun0.gun2) remove_safely(self.gun0.gun2); //Jic
    if(self.gun00.gun1) remove_safely(self.gun00.gun1); //Jic --Used for pilot primary on some multi-player tanks
    if(self.gun00.gun2) remove_safely(self.gun00.gun2); //Jic
    if(self.gun000.gun1) remove_safely(self.gun000.gun1); //Jic --Used for pilot primary on some multi-player tanks
    if(self.gun000.gun2) remove_safely(self.gun000.gun2); //Jic
    if(self.bomb1.gun1) remove_safely(self.bomb1.gun1);
    if(self.bomb1.gun2) remove_safely(self.bomb1.gun2); //Spinners usually
    if(self.bomb2.gun1) remove_safely(self.bomb2.gun1);
    if(self.bomb2.gun2) remove_safely(self.bomb2.gun2); //Spinners usually
    if(self.bomb3.gun1) remove_safely(self.bomb3.gun1);
    if(self.bomb3.gun2) remove_safely(self.bomb3.gun2);
    if(self.bomb4.gun1) remove_safely(self.bomb4.gun1); //Last used of these in code so far
    if(self.bomb4.gun2) remove_safely(self.bomb4.gun2);
    if(self.bomb5.gun1) remove_safely(self.bomb5.gun1);
    if(self.bomb5.gun2) remove_safely(self.bomb5.gun2);
    if(self.bomb6.gun1) remove_safely(self.bomb6.gun1);
    if(self.bomb6.gun2) remove_safely(self.bomb6.gun2);
    if(self.bomb7.gun1) remove_safely(self.bomb7.gun1);
    if(self.bomb7.gun2) remove_safely(self.bomb7.gun2);
    if(self.bomb8.gun1) remove_safely(self.bomb8.gun1);
    if(self.bomb8.gun2) remove_safely(self.bomb8.gun2);
    if(self.bomb9.gun1) remove_safely(self.bomb9.gun1);
    if(self.bomb9.gun2) remove_safely(self.bomb9.gun2);
    vehicles_removeguns(self);
    vehicles_removebombs(self);
    vehicles_removerotors(self);
    if (self.tur_head) {
	setmodel(self.tur_head, "null");
	remove_safely(self.tur_head);
    }
    remove_safely(self);
}

float vehicles_evaltankdamage(float damage, float deathtype)
{
    //These are applied on top of the reguar resists
    //print("TankDamage In: ", ftos(damage),"\n");
    if(deathtype == DEATH_SPORTSTERGUNHV
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_CORESHOT))
	|| (deathtype == (DEATH_SPORTSTERGUNHV + HITTYPE_CORESHOT + HITTYPE_HEADSHOT))
	|| deathtype == DEATH_SBMINIGUN
	)
    {
	//Do Nothing
    } else if(deathtype == DEATH_SPORTSTERGUN
	|| (deathtype == (DEATH_SPORTSTERGUN + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_SPORTSTERGUN + HITTYPE_CORESHOT))
	|| (deathtype == (DEATH_SPORTSTERGUN + HITTYPE_CORESHOT + HITTYPE_HEADSHOT))
	
	|| deathtype == DEATH_TURRET_WALKER_GUN
	|| (deathtype == (DEATH_TURRET_WALKER_GUN + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_TURRET_WALKER_GUN + HITTYPE_CORESHOT))
	
	|| deathtype == DEATH_TURRET_MACHINEGUN
	|| (deathtype == (DEATH_TURRET_MACHINEGUN + HITTYPE_HEADSHOT))
	|| (deathtype == (DEATH_TURRET_MACHINEGUN + HITTYPE_CORESHOT))	
	)
    {
    	damage = damage * 0.4; //Multiply damage by fraction to lower it
    } else {
    	//Otherwise we apply resistances and run it through the resist subroutine.
	//A resist of 1 is a total resist. And 0.9 allows only 0.1 of the damage through.
    	local entity targ;
	targ = spawn();
	targ.resist_acid = 0.1;   //Slime //Corrosive
	
	if (random() > 0.5)
		targ.resist_bullet = 0.9;
	else
		targ.resist_bullet = 1; //Sometimes totally ignore
	
	targ.resist_crush = 0.9;  //Vehicle crush
	
	if (random() > 0.65) {
		targ.resist_blunt = 0.95;  //Warhammer, beatdown, melee
		targ.resist_edged = 0.95;  //Axe, Sword, Claw
		targ.resist_electricity = 0.95; //Lightning gun, Tesla arc, 
		targ.resist_energy = 0.95; //Nex, Electro, Crylink, Wakigun, Bumbgun, Wakigun, "laser" gun, hlac
	} else {
		targ.resist_blunt = 1;  //Warhammer, beatdown, melee
		targ.resist_edged = 1;  //Axe, Sword, Claw
		targ.resist_electricity = 1; //Lightning gun, Tesla arc, 
		targ.resist_energy = 1; //Nex, Electro, Crylink, Wakigun, Bumbgun, Wakigun, "laser" gun, hlac
	}
	
	//No Special Resists to explosions.
	//targ.resist_explode = 0;//Rockets etc
	//targ.resist_nuke = 0;  //Nuclear explosion

	targ.resist_fall = 0.95;   //Shooting star, fall etc
	targ.resist_fire = 0.1;   //Fire, Lava //Eventually could melt
	targ.resist_laser = 0.95;  //Laser
	targ.resist_pierce = 1; //Crossbow, Bite
	targ.resist_sound = 1; //Tuba
	targ.resist_ice = 1; //Freeze damage resistance
	targ.resist_rotor = 1;
    	damage = DamageResistance(targ, damage, deathtype);
	remove(targ);
    }
    //print("TankDamage out  ", ftos(damage),"\n");
    return damage;
}

void vehicles_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
    self.dmg_time = time;
    
    damage = vehicles_evaldamage(damage, deathtype);
    
    if(self.vehicle_tankresists == 1) {
    	damage = vehicles_evaltankdamage(damage, deathtype);
    }
    
    self.enemy = attacker;
    
    if((self.vehicle_flags & VHF_HASSHIELD) && (self.vehicle_shield > 0))
    {
        if (wasfreed(self.vehicle_shieldent) || self.vehicle_shieldent == world)
        {
            self.vehicle_shieldent = spawn();
            self.vehicle_shieldent.effects = EF_LOWPRECISION;

            setmodel(self.vehicle_shieldent, "models/vhshield.md3");
            setattachment(self.vehicle_shieldent, self, "");
            setorigin(self.vehicle_shieldent, real_origin(self) - self.origin);
            self.vehicle_shieldent.scale       = 256 / vlen(self.maxs - self.mins);
            self.vehicle_shieldent.think       = shieldhit_think;
        }

        self.vehicle_shieldent.colormod    = '1 1 1';
        self.vehicle_shieldent.alpha       = 0.45;
        self.vehicle_shieldent.angles      = vectoangles(normalize(hitloc - (self.origin + self.vehicle_shieldent.origin))) - self.angles;
        self.vehicle_shieldent.nextthink   = time;
        self.vehicle_shieldent.effects &~= EF_NODRAW;

        self.vehicle_shield -= damage;

        if(self.vehicle_shield < 0)
        {
            self.vehicle_health            -= fabs(self.vehicle_shield);
            self.vehicle_shieldent.colormod = '2 0 0';
            self.vehicle_shield             = 0;
            self.vehicle_shieldent.alpha    = 0.75;

        	if(sound_allowed(MSG_BROADCAST, attacker))
                spamsound (self, CH_PAIN, "onslaught/ons_hit2.wav", VOL_BASE, ATTN_NORM);   // FIXME: PLACEHOLDER
        }
        else
        	if(sound_allowed(MSG_BROADCAST, attacker))
                spamsound (self, CH_PAIN, "onslaught/electricity_explode.wav", VOL_BASE, ATTN_NORM);  // FIXME: PLACEHOLDER

    }
    else
    {
        self.vehicle_health -= damage;

        if(sound_allowed(MSG_BROADCAST, attacker))
            spamsound (self, CH_PAIN, "onslaught/ons_hit2.wav", VOL_BASE, ATTN_NORM);  // FIXME: PLACEHOLDER
    }
    
	if(self.damageforcescale < 1 && self.damageforcescale > 0)
		self.velocity += force * self.damageforcescale;
	else
		self.velocity += force;

    if(self.vehicle_health <= 0)
    {
        if(self.owner)
            if(self.vehicle_flags & VHF_DEATHEJECT)
                vehicles_exit(VHEF_EJECT);
            else
                vehicles_exit(VHEF_RELESE);


        antilag_clear(self);

        self.vehicle_die();
	
	
	
	if (self.vehicle_pilotplaceholder) {
		if (self.vehicle_pilotplaceholder != world) {
			local entity myvpplhldr;
			myvpplhldr = self.vehicle_pilotplaceholder;
			if (myvpplhldr.isvehiclepilotplaceholder) {
				//print("Placehold remove at vehic destruction\n");
				self.vehicle_pilotplaceholder = world;
				remove(myvpplhldr);
			}
		}
	}
	
	
	if not (self.vehicle_norespawn)
        	vehicles_setreturn();
	else
		vehicles_remove();
    }
}

void vehicles_clearrturn()
{
    entity ret;
    // Remove "return helper", if any.
    ret = findchain(classname, "vehicle_return");
    while(ret)
    {
        if(ret.wp00 == self)
        {
            ret.classname   = "";
            ret.think       = SUB_Remove;
            ret.nextthink   = time + 0.1;

            if(ret.waypointsprite_attached)
                WaypointSprite_Kill(ret.waypointsprite_attached);

            return;
        }
        ret = ret.chain;
    }
}

void vehicles_return()
{
    pointparticles(particleeffectnum("teleport"), self.wp00.origin + '0 0 64', '0 0 0', 1);

    self.wp00.think     = vehicles_spawn;
    self.wp00.nextthink = time;

    if(self.waypointsprite_attached)
        WaypointSprite_Kill(self.waypointsprite_attached);

    remove(self);
}

void vehicles_showwp_goaway()
{
    if(self.waypointsprite_attached)
        WaypointSprite_Kill(self.waypointsprite_attached);

    remove(self);

}

void vehicles_showwp()
{
    entity oldself = world;
    vector rgb;

    if(self.cnt)
    {
        self.think      = vehicles_return;
        self.nextthink  = self.cnt;
    }
    else
    {
        self.think      = vehicles_return;
        self.nextthink  = time +1;

        oldself = self;
        self = spawn();
        setmodel(self, "null");
        self.team = oldself.wp00.team;
        self.wp00 = oldself.wp00;
        setorigin(self, oldself.wp00.pos1);

        self.nextthink = time + 5;
        self.think = vehicles_showwp_goaway;
    }

    if(teamplay && self.team)
	    rgb = TeamColor(self.team);
    else
	    rgb = '1 1 1';
    WaypointSprite_Spawn("vehicle", 0, 0, self, '0 0 64', world, 0, self, waypointsprite_attached, TRUE, RADARICON_POWERUP, rgb);
    if(self.waypointsprite_attached)
    {
        WaypointSprite_UpdateRule(self.waypointsprite_attached, self.wp00.team, SPRITERULE_DEFAULT);
        if(oldself == world)
            WaypointSprite_UpdateBuildFinished(self.waypointsprite_attached, self.nextthink);
        WaypointSprite_Ping(self.waypointsprite_attached);
    }

    if(oldself != world)
        self = oldself;
}

void vehicles_setreturn()
{
    entity ret;

    vehicles_clearrturn();

    ret = spawn();
    ret.classname   = "vehicle_return";
    ret.wp00       = self;
    ret.team        = self.team;
    ret.think       = vehicles_showwp;

    if(self.deadflag != DEAD_NO)
    {
        ret.cnt         = time + self.vehicle_respawntime;
        ret.nextthink   = min(time + self.vehicle_respawntime, time + self.vehicle_respawntime - 5);
    }
    else
    {
        ret.nextthink   = min(time + self.vehicle_respawntime + autocvar_g_vehicles_idletime, time + self.vehicle_respawntime + autocvar_g_vehicles_idletime - 1); //Chaos-Esque Mod Edits: Added idletime
    }

    setmodel(ret, "null");
    setorigin(ret, self.pos1 + '0 0 96');

}

void vehicles_reset_colors()
{
    entity e;
    float _effects = 0, _colormap;
    vector _glowmod, _colormod;

    if(autocvar_g_nodepthtestplayers)
        _effects |= EF_NODEPTHTEST;

    if(autocvar_g_fullbrightplayers)
        _effects |= EF_FULLBRIGHT;

    if(self.team)
        _colormap = 1024 + (self.team - 1) * 17;
    else
        _colormap = 1024;

    _glowmod  = '0 0 0';
    _colormod = '0 0 0';

    // Find all ents attacked to main model and setup effects, colormod etc.
    e = findchainentity(tag_entity, self);
    while(e)
    {
        if(e != self.vehicle_shieldent)
        {
            e.effects   = _effects; //  | EF_LOWPRECISION;
            e.colormod  = _colormod;
            e.colormap  = _colormap;
            e.alpha     = 1;
        }
        e = e.chain;
    }

    self.vehicle_hudmodel.effects  = self.effects  = _effects; // | EF_LOWPRECISION;
    self.vehicle_hudmodel.colormod = self.colormod = _colormod;
    self.vehicle_hudmodel.colormap = self.colormap = _colormap;
    self.vehicle_viewport.effects = (EF_ADDITIVE | EF_DOUBLESIDED | EF_FULLBRIGHT | EF_NODEPTHTEST | EF_NOGUNBOB | EF_NOSHADOW | EF_LOWPRECISION | EF_SELECTABLE | EF_TELEPORT_BIT);

    self.alpha     = 1;
    self.avelocity = '0 0 0';
    self.velocity  = '0 0 0';
    self.effects   = _effects;
}

void vehicle_use()
{
    dprint("vehicle ",self.netname, " used by ", activator.classname, "\n");

    self.tur_head.team = activator.team;

    if(self.tur_head.team == 0)
        self.active = ACTIVE_NOT;
    else
        self.active = ACTIVE_ACTIVE;
    
    if(self.active == ACTIVE_ACTIVE && self.deadflag == DEAD_NO)
    {
        dprint("^3Eat shit yall!\n");
        vehicles_setreturn();
        vehicles_reset_colors();
    }
    else if(self.active == ACTIVE_NOT && self.deadflag != DEAD_NO)
    {
        
    }
}

float vehicle_addplayerslot(    entity _owner, 
                                entity _slot, 
                                float _hud, 
                                string _hud_model,
                                float() _framefunc, 
                                void(float) _exitfunc)
{
    if not (_owner.vehicle_flags & VHF_MULTISLOT)
        _owner.vehicle_flags |= VHF_MULTISLOT;

    _slot.PlayerPhysplug = _framefunc;
    _slot.vehicle_exit = _exitfunc;
    _slot.hud = _hud;
    _slot.vehicle_flags = VHF_PLAYERSLOT;
    _slot.vehicle_viewport = spawn();
    _slot.vehicle_hudmodel = spawn();
    _slot.vehicle_hudmodel.viewmodelforclient = _slot;
    _slot.vehicle_viewport.effects = (EF_ADDITIVE | EF_DOUBLESIDED | EF_FULLBRIGHT | EF_NODEPTHTEST | EF_NOGUNBOB | EF_NOSHADOW | EF_LOWPRECISION | EF_SELECTABLE | EF_TELEPORT_BIT);
    
    setmodel(_slot.vehicle_hudmodel, _hud_model);
    setmodel(_slot.vehicle_viewport, "null");
    
    setattachment(_slot.vehicle_hudmodel, _slot, "");
    setattachment(_slot.vehicle_viewport, _slot.vehicle_hudmodel, "");
    
    return TRUE;
}

float vehicle_initialize(string  net_name,
                         string  bodymodel,
                         string  topmodel,
                         string  hudmodel,
                         string  toptag,
                         string  hudtag,
                         string  viewtag,
                         float   vhud,
                         vector  min_s,
                         vector  max_s,
                         float   nodrop,
                         void(float _spawnflag)  spawnproc,
                         float   _respawntime,
                         float() physproc,
                         void()  enterproc,
                         void(float extflag) exitfunc,
                         void() dieproc,
                         void() thinkproc,
                         float  use_csqc,
                         float _max_health,
                         float _max_shield,
			 float _vehicle_autocolor,
			 float _max_ammo1,
			 float _max_ammo2) //Chaos-Esque Mod Change
{
	if(!autocvar_g_vehicles)
		return FALSE;
		
	if (autocvar_g_delete_vehicles >= 2) {
		if (time < game_starttime + autocvar_g_delete_vehicles_time)
		{
			return FALSE;
		}
	}
	
    if(self.targetname)
    {
        self.vehicle_controller = find(world, target, self.targetname);
        if(!self.vehicle_controller)
        {
            bprint("^1WARNING: ^7Vehicle with invalid .targetname\n");
        }
        else
        {
            self.team = self.vehicle_controller.team;        
            self.use = vehicle_use;
            
            if(teamplay)
            {
                if(self.vehicle_controller.team == 0)
                    self.active = ACTIVE_NOT;
                else
                    self.active = ACTIVE_ACTIVE;                
            }
        }
    }
    
    precache_sound("onslaught/ons_hit2.wav");
    precache_sound("onslaught/electricity_explode.wav");


    addstat(STAT_HUD, AS_INT,  hud);
	addstat(STAT_VEHICLESTAT_HEALTH,  AS_INT, vehicle_health);
	addstat(STAT_VEHICLESTAT_SHIELD,  AS_INT, vehicle_shield);
	addstat(STAT_VEHICLESTAT_ENERGY,  AS_INT, vehicle_energy);

	addstat(STAT_VEHICLESTAT_AMMO1,   AS_INT, vehicle_ammo1);
	addstat(STAT_VEHICLESTAT_RELOAD1, AS_INT, vehicle_reload1);

	addstat(STAT_VEHICLESTAT_AMMO2,   AS_INT, vehicle_ammo2);
	addstat(STAT_VEHICLESTAT_RELOAD2, AS_INT, vehicle_reload2);
	
	addstat(STAT_VEHICLESTAT_AMMO1_CURRENT,   AS_INT, vehicle_ammo1_current);
	addstat(STAT_VEHICLESTAT_AMMO1_MAX,   AS_INT, vehicle_ammo1_max);
	
	addstat(STAT_VEHICLESTAT_AMMO2_CURRENT,   AS_INT, vehicle_ammo2_current);
	addstat(STAT_VEHICLESTAT_AMMO2_MAX,   AS_INT, vehicle_ammo2_max);

    if(bodymodel == "")
        error("vehicles: missing bodymodel!");

    if(hudmodel == "")
        error("vehicles: missing hudmodel!");

    if(net_name == "")
        self.netname = self.classname;
    else
        self.netname = net_name;

    if(self.team && !teamplay)
        self.team = 0;

    self.vehicle_flags |= VHF_ISVEHICLE;

    setmodel(self, bodymodel);

    self.vehicle_zero = 0;
    self.vehicle_ammo1_max = self.vehicle_ammo1_current = _max_ammo1;
    self.vehicle_ammo2_max = self.vehicle_ammo2_current = _max_ammo2;
    self.vehicle_autocolor  = _vehicle_autocolor; //Chaos-Esque Mod Change
    self.vehicle_viewport   = spawn();
    self.vehicle_hudmodel   = spawn();
    self.tur_head           = spawn();
    self.tur_head.owner     = self;
    self.takedamage         = DAMAGE_AIM;
    self.bot_attack         = TRUE;
    self.iscreature         = TRUE;
    self.teleportable       = FALSE; // no teleporting for vehicles, too buggy
    self.damagedbycontents	= TRUE;
    self.hud                = vhud;
    self.tur_health          = _max_health;
    self.tur_head.tur_health = _max_shield;
    self.vehicle_die         = dieproc;
    self.vehicle_exit        = exitfunc;
    self.vehicle_enter       = enterproc;
    self.PlayerPhysplug      = physproc;
    self.event_damage        = func_null;
    self.touch               = vehicles_touch;
    self.think               = vehicles_spawn;
    self.nextthink           = time;
    self.vehicle_respawntime = _respawntime;
    self.vehicle_spawn       = spawnproc;
    self.effects             = EF_NODRAW;
    if(g_assault || !autocvar_g_vehicles_delayspawn)
        self.nextthink = time + 0.5;
    else
        self.nextthink = time + _respawntime + (random() * autocvar_g_vehicles_delayspawn_jitter);


    if(autocvar_g_nodepthtestplayers)
        self.effects = self.effects | EF_NODEPTHTEST;

    if(autocvar_g_fullbrightplayers)
        self.effects = self.effects | EF_FULLBRIGHT;

    setmodel(self.vehicle_hudmodel, hudmodel);
    setmodel(self.vehicle_viewport, "null");

    if(topmodel != "")
    {
        setmodel(self.tur_head, topmodel);
        setattachment(self.tur_head, self, toptag);
        setattachment(self.vehicle_hudmodel, self.tur_head, hudtag);
        setattachment(self.vehicle_viewport, self.vehicle_hudmodel, viewtag);
    }
    else
    {
        setattachment(self.tur_head, self, "");
        setattachment(self.vehicle_hudmodel, self, hudtag);
        setattachment(self.vehicle_viewport, self.vehicle_hudmodel, viewtag);
    }

    setsize(self, min_s, max_s);
    if not (nodrop)
    {
        setorigin(self, self.origin);
	if (self.vehicle_droptype == 1) {
	        tracebox(self.origin + '0 0 100', min_s, max_s, self.origin - '0 0 10000', MOVE_NORMAL, self);
	} else {
        	tracebox(self.origin + '0 0 100', min_s, max_s, self.origin - '0 0 10000', MOVE_WORLDONLY, self);
        }
	setorigin(self, trace_endpos);
    }
    
    self.pos1 = self.origin;
    self.pos2 = self.angles;
    self.tur_head.team = self.team;

    return TRUE;
}

vector vehicle_aimturret(entity _vehic, vector _target, entity _turrret, string _tagname, 
                         float _pichlimit_min, float _pichlimit_max, 
                         float _rotlimit_min, float _rotlimit_max, float _aimspeed)
{
    vector vtmp, vtag;
    float ftmp;
    vtag = gettaginfo(_turrret, gettagindex(_turrret, _tagname));
    vtmp = vectoangles(normalize(_target - vtag));
    vtmp = AnglesTransform_ToAngles(AnglesTransform_LeftDivide(AnglesTransform_FromAngles(_vehic.angles), AnglesTransform_FromAngles(vtmp))) - _turrret.angles;
    vtmp = AnglesTransform_Normalize(vtmp, TRUE);
    ftmp = _aimspeed * frametime;
    vtmp_y = bound(-ftmp, vtmp_y, ftmp);
    vtmp_x = bound(-ftmp, vtmp_x, ftmp);
    _turrret.angles_y = bound(_rotlimit_min, _turrret.angles_y + vtmp_y, _rotlimit_max);    
    _turrret.angles_x = bound(_pichlimit_min, _turrret.angles_x + vtmp_x, _pichlimit_max);
    return vtag;
}

vector vehicle_aimturret2(entity _vehic, entity _turretmount, vector _target, entity _turrret, string _tagname, 
                         float _pichlimit_min, float _pichlimit_max, 
                         float _rotlimit_min, float _rotlimit_max, float _aimspeed)
{
    vector vtmp, vtag;
    float ftmp;
    vtag = gettaginfo(_turrret, gettagindex(_turrret, _tagname));
    vtmp = vectoangles(normalize(_target - vtag));
    vtmp = AnglesTransform_ToAngles(AnglesTransform_LeftDivide(AnglesTransform_FromAngles(_vehic.angles+_turretmount.angles), AnglesTransform_FromAngles(vtmp))) - _turrret.angles;
    vtmp = AnglesTransform_Normalize(vtmp, TRUE);
    ftmp = _aimspeed * frametime;
    vtmp_y = bound(-ftmp, vtmp_y, ftmp);
    vtmp_x = bound(-ftmp, vtmp_x, ftmp);
    _turrret.angles_y = bound(_rotlimit_min, _turrret.angles_y + vtmp_y, _rotlimit_max);    
    _turrret.angles_x = bound(_pichlimit_min, _turrret.angles_x + vtmp_x, _pichlimit_max);
    return vtag;
}

void vehicles_gib_explode()
{
	sound (self, CH_SHOTS, "weapons/rocket_impact.wav", VOL_BASE, ATTN_NORM);
	pointparticles(particleeffectnum("explosion_small"), randomvec() * 80 + (self.origin + '0 0 100'), '0 0 0', 1);
	remove(self);
}

void vehicles_gib_think()
{
	self.alpha -= 0.1;
	if(self.cnt >= time)
		remove(self);
	else
		self.nextthink = time + 0.1;
}

entity vehicle_tossgib(entity _template, vector _vel, string _tag, float _burn, float _explode, float _maxtime, vector _rot)
{
	entity _gib = spawn();
	setmodel(_gib, _template.model);
	setorigin(_gib, gettaginfo(self, gettagindex(self, _tag)));
	_gib.velocity = _vel;
	_gib.movetype = MOVETYPE_TOSS;
	_gib.solid = SOLID_CORPSE;
	_gib.colormod = '-0.5 -0.5 -0.5';
	_gib.effects = EF_LOWPRECISION;	
	_gib.avelocity = _rot;
	
	if(_burn)
		_gib.effects |= EF_FLAME;
	
	if(_explode)
	{
		_gib.think = vehicles_gib_explode; 
		_gib.nextthink = time + random() * _explode;
		_gib.touch = vehicles_gib_explode;
	}
	else
	{
		_gib.cnt = time + _maxtime;
		_gib.think = vehicles_gib_think; 
		_gib.nextthink = time + _maxtime - 1;		
		_gib.alpha = 1;
	}
	return _gib;
}


.float oldhud;
float vehicles_allowdriveby(float isdriver, entity player, float changehud, float vehictype)
{
	//vehictype 1 cars, 2 boats, 3 helicopters, 4 aircraft, 5 spaceships, 6 submersibles.
	if not (autocvar_g_vehicles_allowdriveby) 
		return 0;
		
	if (vehictype && (vehictype > autocvar_g_vehicles_allowdriveby))
		return 0;
		
	//Passangers allowed to do drivebys is more likely
	if ((isdriver && autocvar_g_vehicles_allowdriveby_drvr)
	|| (!isdriver && autocvar_g_vehicles_allowdriveby_pssngr))
	{
		//Note: HUD_NORMAL is equal to 0
			if (changehud) {
				if (player.hud != HUD_NORMAL) {
				player.oldhud = player.hud;
				player.hud = HUD_NORMAL;
				}
			}
		return 1;
	}
	
	//Restore if has been disabled
	if (changehud) {
		if (player.oldhud) {
			player.hud = player.oldhud;
		}
	}
	return 0;
}


/*
vector predict_target(entity _targ, vector _from, float _shot_speed)
{
    float i;                // loop
    float _distance;        // How far to target
    float _impact_time;     // How long untill projectile impacts
    vector _predict_pos;    // Predicted enemy location
    vector _original_origin;// Where target is before predicted

     _original_origin = real_origin(_targ); // Typicaly center of target BBOX

    _predict_pos = _original_origin;
    for(i = 0; i < 4; ++i)  // Loop a few times to increase prediction accuracy (increase loop count if accuracy is to low)
    {
        _distance = vlen(_predict_pos - _from); // Get distance to previos predicted location
        _impact_time = _distance / _shot_speed; // Calculate impact time
        _predict_pos = _original_origin + _targ.velocity * _impact_time; // Calculate new predicted location
    }

    return _predict_pos;
}
*/
