#ifdef REGISTER_WEAPON
REGISTER_WEAPON(MULTITOOL, w_multitool, IT_NAILS, 1, WEP_FLAG_NORMAL | WEP_FLAG_RELOADABLE | WEP_TYPE_HITSCAN, BOT_PICKUP_RATING_HIGH, "multitool", "multitool", _("Multi-Tool"))
#else
#ifdef SVQC


#define BUILDING_ACCPTCRRDBLDSPLTR   4
	//Multiply decal attemps by this, often needed as engine seems reluctant for non world decaling

#define TREETOP_SENTRY_ZADD   232

#define TREETOP_SENTRY_RADIUS   128
	//For finding a tree

#define HSNG_BED_CAPACITY   1    
	//

#define HSNG_HOUSE_CAPACITY   2    
	//1*2

#define HSNG_JHOUSE_CAPACITY   3    
	//(1*2)+1

#define HSNG_BARRACKS_CAPACITY   12 
	//6*2

#define HSNG_APART_CAPACITY   80   
	//40*2

#define HSNG_STRNGHLD_CAPACITY   5   
	//(2*2)+1

#define HSNG_MANSE_CAPACITY   4   
	//2*2

#define OIL_TANK_CAPACITY   200000

#define OIL_TANK_SMALL_CAPACITY   1250 
	//Small oil tank, local source, 1/4 size of battery about in size, then factor in the 1:2 oil/energy ratio seen here..

#define ENERGY_TANK_CAPACITY   400000

#define ENERGY_BATTERY_CAPACITY   10000 
	//"Small" battery, local source

#define RESOURCELOCAL_RADIUS   4096 
	//How far to search (for battery)

#define RESOURCELOCAL_RADIUS2   8192 
	//How far to search (for oil tanks etc)

#define RESOURCELOCAL_RADIUSAMMODEPOT   131072 
	//How far to search (for stuff to supply ammo depots), abt 2mi

#define RESOURCELOCAL_RADIUSFORGEBLDNG   32768 
	//How far to search (for stuff to supply forges) About 0.5 mile

#define RESOURCELOCAL_RADIUSFINDFORGERCRCS   98304 
	//How far to search for a forgeresources (for building turrets etc) About 1.5 miles

#define SOLARPANEL_ENERGY   1
#define FIELD_FOOD   1

//Chemical Plants produce fuel and explosives, input is electricity and crude. Ammo depot can thus replenish
#define CHEMICAL_INPUT_E   1
#define CHEMICAL_INPUT_C   20
#define CHEMICAL_OUTPUT_A   10 
	//Fuel resource
#define CHEMICAL_OUTPUT_B   6  
	//Rocket resource

//Factorys produce munitions, input is fuel and electricity. Ammo depot can thus replenish
#define FACTORY_INPUT_E   5
#define FACTORY_INPUT_C   20 
	//Fuel resource
#define FACTORY_OUTPUT_A   10 
	//Nail resource
#define FACTORY_OUTPUT_B   4  
	//Shell resource
	
#define FORGEBLD_INPUT_A   100  
	//How many resources //medieval
#define FORGEBLD_OUTPUT_A   1   
	//Makes how much
	
#define FORGEBLD_INPUT_B   150  
	//How many resources //futuristic
#define FORGEBLD_OUTPUT_B   2  
	 //Makes how much

float numberoffurnaces; //How many global




//Constants for Block Numbers, to make it easier for ourselves to extend
#define MTB64BOUNDFIRST   700  
	//Not used in the code here yet, for clarity's sake so far, LASTBOUND is used however.

#define MTB64FIRST   704  
	//Used in cheats.qc select command 

#define MTB64_FILLED   704 
#define MTB64_FILLED_D   705 
#define MTB64_FILLED_X   706 
#define MTB64_FILLED_I   707 
#define MTB64_FILLED_CASING   708 
#define MTB64_FILLED_CORNER   709 
#define MTB64_FILLEDLAST   709 

#define MTB64_SHINGLES   710 
#define MTB64_SHINGLES_CASING   711 
#define MTB64_SHINGLES_SCASING    712 
#define MTB64_SHINGLES_PYR   713 
#define MTB64_SHINGLES_CORNER   714 
#define MTB64_SHINGLES_RCORNER   715 
#define MTB64_SHINGLES_STAIRS   716 
#define MTB64_SHINGLES_ICASING   717 
#define MTB64_SHINGLES_OS   718 
#define MTB64_SHINGLES_OS2   719 
#define MTB64_SHINGLES_SSTAIRS   720 
#define MTB64_SHINGLES_ISTAIRS   721 
#define MTB64_SHINGLESLAST   721 

#define MTB64_WOOD1   722 
#define MTB64_WOOD1_CASING   723 
#define MTB64_WOOD1_SCASING    724 
#define MTB64_WOOD1_PYR   725 
#define MTB64_WOOD1_CORNER   726 
#define MTB64_WOOD1_RCORNER   727 
#define MTB64_WOOD1_STAIRS   728 
#define MTB64_WOOD1_ICASING   729 
#define MTB64_WOOD1_OS   730 
#define MTB64_WOOD1_OS2   731 
#define MTB64_WOOD1_SSTAIRS   732 
#define MTB64_WOOD1_ISTAIRS   733 
#define MTB64_WOOD1LAST   733 

#define MTB64_WOOD2   734 
#define MTB64_WOOD2_CASING   735 
#define MTB64_WOOD2_SCASING    736 
#define MTB64_WOOD2_PYR   737 
#define MTB64_WOOD2_CORNER   738 
#define MTB64_WOOD2_RCORNER   739 
#define MTB64_WOOD2_STAIRS   740 
#define MTB64_WOOD2_ICASING   741 
#define MTB64_WOOD2_OS   742 
#define MTB64_WOOD2_OS2   743 
#define MTB64_WOOD2_SSTAIRS   744 
#define MTB64_WOOD2_ISTAIRS   745 
#define MTB64_WOOD2_STAIRSCHEAP   746 
#define MTB64_WOOD2LAST   746 

#define MTB64_CURTAIN   747 
#define MTB64_CURTAIN_CASING   748 
#define MTB64_CURTAIN_SCASING    749 
#define MTB64_CURTAIN_PYR   750 
#define MTB64_CURTAIN_CORNER   751 
#define MTB64_CURTAIN_RCORNER   752 
#define MTB64_CURTAIN_STAIRS   753 
#define MTB64_CURTAIN_ICASING   754 
#define MTB64_CURTAIN_OS   755 
#define MTB64_CURTAIN_OS2   756 
#define MTB64_CURTAIN_SSTAIRS   757 
#define MTB64_CURTAIN_ISTAIRS   758 
#define MTB64_CURTAINLAST   758 

#define MTB64_CASTLE   759 
#define MTB64_CASTLE_CASING   760 
#define MTB64_CASTLE_SCASING    761 
#define MTB64_CASTLE_PYR   762 
#define MTB64_CASTLE_CORNER   763 
#define MTB64_CASTLE_RCORNER   764 
#define MTB64_CASTLE_STAIRS   765 
#define MTB64_CASTLE_ICASING   766 
#define MTB64_CASTLE_OS   767 
#define MTB64_CASTLE_OS2   768 
#define MTB64_CASTLE_SSTAIRS   769 
#define MTB64_CASTLE_ISTAIRS   770 
#define MTB64_CASTLELAST   770 

#define MTB64_CASTLESQUARE   771 

#define MTB64_HEDGE   772 
#define MTB64_HEDGE_CASING   773 
#define MTB64_HEDGE_SCASING    774 
#define MTB64_HEDGE_PYR   775 
#define MTB64_HEDGE_CORNER   776 
#define MTB64_HEDGE_RCORNER   777 
#define MTB64_HEDGE_STAIRS   778 
#define MTB64_HEDGE_ICASING   779 
#define MTB64_HEDGE_OS   780 
#define MTB64_HEDGE_OS2   781 
#define MTB64_HEDGE_SSTAIRS   782 
#define MTB64_HEDGE_ISTAIRS   783 
#define MTB64_HEDGELAST   783 

#define MTB64_POLISH   784 
#define MTB64_POLISH_CASING   785 
#define MTB64_POLISH_SCASING    786 
#define MTB64_POLISH_PYR   787 
#define MTB64_POLISH_CORNER   788 
#define MTB64_POLISH_RCORNER   789 
#define MTB64_POLISH_STAIRS   790 
#define MTB64_POLISH_ICASING   791 
#define MTB64_POLISH_OS   792 
#define MTB64_POLISH_OS2   793 
#define MTB64_POLISH_SSTAIRS   794 
#define MTB64_POLISH_ISTAIRS   795 
#define MTB64_POLISHLAST   795 

#define MTB64_GRAYSTONE   796 
#define MTB64_GRAYSTONE_CASING   797 
#define MTB64_GRAYSTONE_SCASING    798 
#define MTB64_GRAYSTONE_PYR   799 
#define MTB64_GRAYSTONE_CORNER   800 
#define MTB64_GRAYSTONE_RCORNER   801 
#define MTB64_GRAYSTONE_STAIRS   802 
#define MTB64_GRAYSTONE_ICASING   803 
#define MTB64_GRAYSTONE_OS   804 
#define MTB64_GRAYSTONE_OS2   805 
#define MTB64_GRAYSTONE_SSTAIRS   806 
#define MTB64_GRAYSTONE_ISTAIRS   807 
#define MTB64_GRAYSTONELAST   807 

#define MTB64_SANDSTONEDARK   808 
#define MTB64_SANDSTONE   809 
#define MTB64_SANDSTONE_CASING   810 
#define MTB64_SANDSTONE_SCASING    811 
#define MTB64_SANDSTONE_PYR   812 
#define MTB64_SANDSTONE_CORNER   813 
#define MTB64_SANDSTONE_RCORNER   814 
#define MTB64_SANDSTONE_STAIRS   815 
#define MTB64_SANDSTONE_ICASING   816 
#define MTB64_SANDSTONE_OS   817 
#define MTB64_SANDSTONE_OS2   818 
#define MTB64_SANDSTONE_SSTAIRS   819 
#define MTB64_SANDSTONE_ISTAIRS   820 
#define MTB64_SANDSTONELAST   820 

#define MTB64_SHINGLES2   821 
#define MTB64_SHINGLES2_CASING   822 
#define MTB64_SHINGLES2_SCASING    823 
#define MTB64_SHINGLES2_PYR   824 
#define MTB64_SHINGLES2_CORNER   825 
#define MTB64_SHINGLES2_RCORNER   826 
#define MTB64_SHINGLES2_STAIRS   827 
#define MTB64_SHINGLES2_ICASING   828 
#define MTB64_SHINGLES2_OS   829 
#define MTB64_SHINGLES2_OS2   830 
#define MTB64_SHINGLES2_SSTAIRS   831 
#define MTB64_SHINGLES2_ISTAIRS   832 
#define MTB64_SHINGLES2LAST   832 

#define MTB64_MARBLEWHITE   833 
#define MTB64_MARBLEWHITE_CASING   834 
#define MTB64_MARBLEWHITE_SCASING    835 
#define MTB64_MARBLEWHITE_PYR   836 
#define MTB64_MARBLEWHITE_CORNER   837 
#define MTB64_MARBLEWHITE_RCORNER   838 
#define MTB64_MARBLEWHITE_STAIRS   839 
#define MTB64_MARBLEWHITE_ICASING   840 
#define MTB64_MARBLEWHITE_OS   841 
#define MTB64_MARBLEWHITE_OS2   842 
#define MTB64_MARBLEWHITE_SSTAIRS   843 
#define MTB64_MARBLEWHITE_ISTAIRS   844 
#define MTB64_MARBLEWHITE_RCORNER_SOLID   845 
#define MTB64_MARBLEWHITE_RCORNER_F   846 
#define MTB64_MARBLEWHITE_RCORNER_FT   847 
#define MTB64_MARBLEWHITE_RCORNER_FB   848 
#define MTB64_MARBLEWHITE_RCORNER_P   849 
#define MTB64_MARBLEWHITE_RECCORNER   850 
#define MTB64_MARBLEWHITE_RECCORNER_F   851 
#define MTB64_MARBLEWHITE_RECCORNER_FT   852 
#define MTB64_MARBLEWHITE_RECCORNER_FB   853 
#define MTB64_MARBLEWHITE_SCORNER_P   854 
#define MTB64_MARBLEWHITELAST   854 

#define MTB64_STAKES_WOOD1   855 
#define MTB64_BWIRE   856 
#define MTB64_WINDOW_WOODBAR   857 
#define MTB64_WINDOW_IRONBAR   858 

#define MTB64_DOOR_R_WOOD   859 
#define MTB64_DOOR_R_JWOOD   860 
#define MTB64_DOOR_R_FWOOD   861 
#define MTB64_DOOR_R_IRONBAR   862 

#define MTB64_FITTEDWINDOW_CASTLE_ALOOP   863 
#define MTB64_FITTEDWINDOW_CASTLE_SWALL   864 
#define MTB64_FITTEDWINDOW_WINDOW   865 

#define MTB64_PLATFORMWOOD_8   866 
#define MTB64_PLATFORMWOOD_24   867 

#define MTB64_FURN_CHAIR_WOOD   868 
#define MTB64_FURN_CHAIR_WOOD2   869 
#define MTB64_FURN_STOOL_WOOD   870 
#define MTB64_FURN_BENCH_WOOD   871 
#define MTB64_FURN_TABLE_WOOD   872 
#define MTB64_FURN_TABLE_WOOD2   873 
#define MTB64_FURN_TABLE_WOOD3   874 
#define MTB64_FURN_TABLE_OCT_WOOD   875 
#define MTB64_FURN_TABLE_OCT_WOOD2   876 
#define MTB64_FURN_WORKBENCH   877 
#define MTB64_FURN_BLKSMHBELLOWS   878 
#define MTB64_FURN_BLKSMHFORGE   879 
#define MTB64_FURN_BLKSMHANVIL   880 
#define MTB64_FURN_BLKSMHGRNDSTN   881 
#define MTB64_FURN_BARREL_WOOD2   882
	//Not tapped, big
#define MTB64_FURN_BARREL_WOOD   883
	//Tapped, dwarf style
#define MTB64_FURN_BED_WOOD   884 
#define MTB64_FURN_CHEST_WOOD   885 
#define MTB64_FURN_CHESTLARGE_WOOD   886 
#define MTB64_FURN_CHAIR_FANCY1   887 
#define MTB64_FURN_CHAIR_FANCY2   888 
#define MTB64_FURN_CHAIR_FANCY3   889 
#define MTB64_FURN_CHAISELOUNGE   890 
#define MTB64_FURN_EMPTYSHELF_WOOD   891 
#define MTB64_FURN_BOOKSHELF_WOOD   892 
#define MTB64_FURN_IRONMAIDEN   893 
#define MTB64_FURN_GIBBET   894 
#define MTB64_FURN_SPIKEDRACK   895 
#define MTB64_FURN_IMPALEMENTPOLE   896
#define MTB64_FURN_GREEKPILLAR   897
#define MTB64_FURN_GREEKPILLARM   898 
#define MTB64_FURN_ROMANCOLUMN   899
#define MTB64_FURN_ROMANCOLUMNM   900 
#define MTB64_FURN_IRONBRAZIER   901 

#define MTB64_CLAIMSTONE   902  
	//Should always be last

#define MTB64LAST   902 
#define MTB64BOUNDLAST   910  
	//Past this we won't treat as 64x64 block (Also note, less than 1000, 1000+ is the utilitool set)


//Constants for Utilitool Block Numbers, to make it easier for ourselves to extend
#define MTB64UBOUNDFIRST   1700  
	//Used in code
#define MTB64UFIRST   1759  
	//Used in cheats.qc select command 

#define MTB64U_CONCRETE   1759 
#define MTB64U_CONCRETE_CASING   1760 
#define MTB64U_CONCRETE_SCASING    1761 
#define MTB64U_CONCRETE_PYR   1762 
#define MTB64U_CONCRETE_CORNER   1763 
#define MTB64U_CONCRETE_RCORNER   1764 
#define MTB64U_CONCRETE_STAIRS   1765 
#define MTB64U_CONCRETE_ICASING   1766 
#define MTB64U_CONCRETE_OS   1767 
#define MTB64U_CONCRETE_OS2   1768 
#define MTB64U_CONCRETE_SSTAIRS   1769 
#define MTB64U_CONCRETE_ISTAIRS   1770 
#define MTB64U_CONCRETELAST   1770 

#define MTB64U_CONCRETESQUARE   1771 

#define MTB64U_METAL   1772 
#define MTB64U_METAL_CASING   1773 
#define MTB64U_METAL_SCASING    1774 
#define MTB64U_METAL_PYR   1775 
#define MTB64U_METAL_CORNER   1776 
#define MTB64U_METAL_RCORNER   1777 
#define MTB64U_METAL_STAIRS   1778 
#define MTB64U_METAL_ICASING   1779 
#define MTB64U_METAL_OS   1780 
#define MTB64U_METAL_OS2   1781 
#define MTB64U_METAL_SSTAIRS   1782 
#define MTB64U_METAL_ISTAIRS   1783 
#define MTB64U_METALLAST   1783 

#define MTB64U_RCONCRETE   1784 
#define MTB64U_RCONCRETE_CASING   1785 
#define MTB64U_RCONCRETE_SCASING    1786 
#define MTB64U_RCONCRETE_PYR   1787 
#define MTB64U_RCONCRETE_CORNER   1788 
#define MTB64U_RCONCRETE_RCORNER   1789 
#define MTB64U_RCONCRETE_STAIRS   1790 
#define MTB64U_RCONCRETE_ICASING   1791 
#define MTB64U_RCONCRETE_OS   1792 
#define MTB64U_RCONCRETE_OS2   1793 
#define MTB64U_RCONCRETE_SSTAIRS   1794 
#define MTB64U_RCONCRETE_ISTAIRS   1795 
#define MTB64U_RCONCRETELAST   1795 

#define MTB64U_RCONCRETESQUARE   1796 
#define MTB64U_RCONCRETESQUARE2   1797 

#define MTB64U_WINDOW_FUTURE   1798 
#define MTB64U_WINDOW_FUTURE_X   1799 

#define MTB64U_XBEAM_UP   1800 
#define MTB64U_XBEAM_OVER   1801 

#define MTB64U_FLOOR_MTRUSS   1802 
#define MTB64U_PLATFORM_8   1803 
#define MTB64U_PLATFORM_16   1804 
#define MTB64U_PLATFORM_24   1805 
#define MTB64U_PLATFORM_32   1806 

#define MTB64U_BWIRE   1807 
#define MTB64U_BWIRE_X   1808 
#define MTB64U_BWIRE_O   1809 

#define MTB64U_DOOR_R_PLAIN   1810 
#define MTB64U_DOOR_R_PLAIN2   1811 
#define MTB64U_DOOR_R_STEEL   1812 
#define MTB64U_DOOR_R_GLASS   1813 

#define MTB64U_FITTEDWINDOW_STEELSLIT   1814 
#define MTB64U_FITTEDWINDOW_STEELPLATE   1815 
#define MTB64U_FITTEDWINDOW_CWALL   1816 
#define MTB64U_FITTEDWINDOW_UWINDOW   1817 

#define MTB64U_ARCHIVEBOX   1818 

#define MTB64U_INACT_OIL   1819 
#define MTB64U_ACT_OIL   1820 
#define MTB64U_ACT_EXPL   1821 

#define MTB64U_FURN_BARRELP   1822 
#define MTB64U_FURN_BARRELM   1823 
#define MTB64U_FURN_CHAIR   1824 
#define MTB64U_FURN_CHAIR2   1825 
#define MTB64U_FURN_CHAIR3   1826 
#define MTB64U_FURN_CHAIR4   1827 
#define MTB64U_FURN_CHAIR5   1828 
#define MTB64U_FURN_SCHAIR   1829 
#define MTB64U_FURN_PLSCHAIR   1830 
#define MTB64U_FURN_OMLCHAIR   1831 
#define MTB64U_FURN_OMLCHAIR2   1832 
#define MTB64U_FURN_STOOL   1833 
#define MTB64U_FURN_CSTOOL   1834 
#define MTB64U_FURN_RETROCHAIR   1835 
#define MTB64U_FURN_SCHINTGRDESK   1836 
#define MTB64U_FURN_SCHDESKCHAIR   1837 
#define MTB64U_FURN_CRATE   1838 
#define MTB64U_FURN_DESK   1839 
#define MTB64U_FURN_MGSTDESK   1840 
#define MTB64U_FURN_MGSTDESKFLAT   1841 
#define MTB64U_FURN_MGSTDESKFULLCORNER   1842 
#define MTB64U_FURN_TABLE   1843 
#define MTB64U_FURN_TABLELOW   1844 
#define MTB64U_FURN_TABLEGLASS   1845 
#define MTB64U_FURN_TABLESQUARE   1846 
#define MTB64U_FURN_TABLECIRC   1847 
#define MTB64U_FURN_TABLELONG   1848 
#define MTB64U_FURN_RETROTABLE   1849 
#define MTB64U_FURN_FILECABINET   1850 
#define MTB64U_FURN_SHELVES   1851 
#define MTB64U_FURN_SERVER   1852 
#define MTB64U_FURN_COMCRATE   1853 
#define MTB64U_FURN_COMCRATE2   1854 
#define MTB64U_FURN_MTLCRATE   1855 
#define MTB64U_FURN_TOILET   1856 
#define MTB64U_FURN_TOILET2   1857 
#define MTB64U_FURN_TOILET3   1858 
#define MTB64U_FURN_SINK   1859 
#define MTB64U_FURN_SINK2   1860 
#define MTB64U_FURN_SINK_PED   1861 
#define MTB64U_FURN_SINK_PED2   1862 
#define MTB64U_FURN_SHOWER   1863 
#define MTB64U_FURN_STOVE3   1864 
#define MTB64U_FURN_STOVE   1865 
#define MTB64U_FURN_STOVE2   1866 
#define MTB64U_FURN_STOVE4   1867 
#define MTB64U_FURN_FRIDGE   1868 
#define MTB64U_FURN_FRIDGE2   1869 
#define MTB64U_FURN_FRIDGE4   1870 
#define MTB64U_FURN_FRIDGE3   1871 
#define MTB64U_FURN_BSCKCABINET1   1872 
#define MTB64U_FURN_BSCKCABINET2   1873 
#define MTB64U_FURN_BSCKCABINET3   1874 
#define MTB64U_FURN_BSCKCABINET4   1875 
#define MTB64U_FURN_BSCKCABINETCORNER1   1876 
#define MTB64U_FURN_BSCKCABINETCORNER2   1877 
#define MTB64U_FURN_BSCKCABINETBAR1   1878 
#define MTB64U_FURN_BSCKCABINETBARENDR   1879 
#define MTB64U_FURN_BSCKCABINETBARENDL   1880 
#define MTB64U_FURN_BSCKCABINETTOP1   1881 
#define MTB64U_FURN_BSCKCABINETTOPSHORT1   1882 
#define MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1   1883 
#define MTB64U_FURN_BSCKCABINETCORNERTOP1   1884 
#define MTB64U_FURN_BSCKCABINETCORNERTOP2   1885 
#define MTB64U_FURN_BSCKCABINETTOPDEEP1   1886 
#define MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1   1887 
#define MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1   1888 
#define MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2   1889 
#define MTB64U_FURN_FUTON   1890 
#define MTB64U_FURN_BED   1891 
#define MTB64U_FURN_BED_FOAM   1892 
#define MTB64U_FURN_MLHSKCHAIR   1893 
#define MTB64U_FURN_BARCELONACHAIR   1894 
#define MTB64U_FURN_TRIBECACHAIR   1895 
#define MTB64U_FURN_SOFA1BR   1896 
#define MTB64U_FURN_SOFA3BR   1897 
#define MTB64U_FURN_SOFA1B   1898 
#define MTB64U_FURN_SOFA3B   1899 
#define MTB64U_FURN_SOFA1LW   1900 
#define MTB64U_FURN_SOFA3LW   1901 
#define MTB64U_FURN_SOFA1LW2   1902 
#define MTB64U_FURN_SOFA3LW2   1903 
#define MTB64U_FURN_SOFA_FOAM   1904 
#define MTB64U_FURN_SOFA_TARTAN   1905 
#define MTB64U_FURN_SOFA_POOFY   1906 
#define MTB64U_FURN_SOFA_NORM   1907 
#define MTB64U_FURN_LAMP_STREET   1908 
#define MTB64U_FURN_LAMP_STREET2   1909 
#define MTB64U_FURN_LAMP_STREET3   1910 
#define MTB64U_FURN_LAMP_STREET4   1911 
#define MTB64U_FURN_LAMP_STREET5   1912 

#define MTB64U_CLAIMSTONE   1913  
	//Should always be last

#define MTB64ULAST   1913 
#define MTB64UBOUNDLAST   1920  
	//Past this we won't treat as 64x64 block (Also note, equal or more than 1000, 1000+ is the utilitool set)


.float multitool_forceangle; //Don't snap to 90 degrees, for map spawnfuncs
.float multitool_forcecolor; //Force color to colormap, used for map spawnfuncs
.float multitool_forceskin; //Force skin used for map spawnfuncs
.float multitool_forceinventory; //Force inventory transfer from spawnfunc entity, used for map spawnfuncs
.float multitool_forceinventory_weapon;
.float multitool_helpfultipnagnexttime;
.float multitool_helpfultipnagtimes;
.float multitool_helpfultipnagnexttime2;
.float multitool_helpfultipnagtimes2;
.float multitool_lit;
.float multitool_update3dscaf;
.float multitool_flipblock;
.float multitool_roofcolor;
.float multitool_marblecolor;
.float multitool_castlecolor;
.float multitool_sstonecolor;
.float multitool_woodcolor;
.float multitool_flamecolor;
.float multitool_ammocurrent;
.float multitool_ammocurrentr;
.float multitool_ammocurrentc;
.float multitool_ammomax;
.float multitool_release;
.float multitool_forcesolidtype;
.float multitool_forcenotdragable;
.float multitool_rapidscrollpressed;
.float multitool_rapidscrollnext;
.float multitool_rapidscrollnobldnext;
.float multitool_didntknowlastselection; //Didn't know last selected building
.float multitool_setting;
.float multitool_setting_saved;
.float multitool_only_lastset;
.float multitool_jammed;
.float multitool_click;
.float multitool_nextrepair;
.float multitool_zsnapmulti;
.float multitool_blocktype;
.float multitool_placetype;
.float multitool_buildingsnap;
.float multitool_wallsnap;
.float multitool_wallshift;
.float multitool_vaultwings;
.float multitool_lockz;
.float multitool_lockzsetting;
.float multitool_lockzbefore;
.float multitool_lockzbeforesetting;
.float multitool_floorlockrot;
.float multitool_floorlockrotsetting;
.float multitool_doorcenter;
.float multitool_furndrop;
.float multitool_noturretsintowers;
.float multitool_annoymsgtime1;
.float multitool_annoymsgtime2;
.float multitool_annoymsgtime3;
.float multitool_isscaffold; //We'll set this if we are a scaffold so axe and chainsaw wont treat it as a regular bldng, setting a flag for KISS rather than some complicated code
.float bldhitbx_max_health;
.float rubble_starttime;
.float rubble_takedmg;
.float rubble_is ; //Is Rubble 
.float multitool_iscontrolpoint;
.float multitool_isencasedinsolid; //Mostly for controlpoints of buildings that lockdown the area
.float multitool_isencasedinsolidnextcheck; //Next time we will check rather than just relaying the above variable
.float vehicle_droptype; //1 == normal, 0 == worldonly
.float usealtorigin; //For rubble (some bridges)
.vector altorigin;   //For rubble
.entity requiresexist;
.entity dstrybldondeath;
.entity subordinate;
.entity subordinate2; //will be used to set norespawn
.entity subordinate2a; //will be used to set norespawn
.entity subordinate3; //will be used to set norespawn
.entity subordinate3a; //will be used to set norespawn
.entity subordinate3b; //will be used to set norespawn
.entity subordinate4; //for misc stuff
.entity subordinate5; //for misc stuff
.entity subordinate6; //for misc. used mostly for storing entity that is localresource provider (energy usually), if doesn't exist or changed teams or owner would have to search
.entity subordinate7; //for misc stuff, like a lock model on the solar panels to indicate local distribution vs global
.entity subordinate8; //for misc. used mostly for storing entity that is localresource provider (oil usually), if doesn't exist or changed teams or owner would have to search
.entity subordinate9; //for misc. used mostly for storing our chemical plant local store we add to as a chem plant
.entity subordinate10; //for misc. used mostly for storing entity that is localresource provider (rockets usually), if doesn't exist or changed teams or owner would have to search
.entity multitool_doorframeent; //Door frament, so we may find info when attacking slab
.entity multitoolresetgrate; //for resetting a grate if that which it would collide with has been destroyed
.entity multitool_hitbox;
.entity multitool_dragmaster; //For things that can be dragged, so their control point follows
.float multitool_dragable;
.float doorsetsubordinate; //Door trigger should set subordinate.
			   //Note: Door should be last in chain if possible
			   //But there is code to insert it in the middle of
			   //a chain if necessary in (entity spawn_field(vector fmins, vector fmaxs))
			   //NOT needed for doors that are shot open.
.float doorreducedtriggerset;	//Touch triggered doors only trigger for players or monsters
.float doorsettriggersize;	//Set own trigger size, not absolute mins max's
.vector doortriggermins;
.vector doortriggermaxs;
// weapon frames
.float swing_prev;
.entity swing_alreadyhit;
void Foliage_Fall();
void vehicles_remove();
void ContainerAllInventoryPinata (entity container);
float multitool_isdoor(float mytype);
float multitool_isfurniture(float mytype);
float multitool_isdragable(float mytype);
float multitool_doorcentertooclose(vector mysrchorigin, float myrad);
float multitool_doorcenteredtooclose_ent(entity mysrchent, float myrad);
float multitool_controlpointencased(entity mybuilding);
float multitool_CheckIsTouchingLava(entity myhitbox, entity mymodel);
float multitool_ownedspawnpoint_tooclose_ent(entity mysrchent, float myrad, entity myplayer);

const float MULTITOOLRECRUIT_ROYALGUARD = 2;
const float MULTITOOLRECRUIT_KNIGHT = 1;
const float UTILITOOLRECRUIT_SOLIDER = 3;
const float MULTITOOLRECRUIT_FIGHTER = 4;
const float MULTITOOLRECRUIT_NINJAASSASSIN = 5;
void spawnfunc_monster_royalguard_grounded();
void spawnfunc_monster_knight();
void spawnfunc_monster_soldier();
void spawnfunc_monster_fighter();
void spawnfunc_monster_ninjaassassin();
void royalguard_precacheforothers();
void knight_precacheforothers();
void soldier_precacheforothers();
void fighter_precacheforothers();
void ninjaassassin_precacheforothers();
void monster_spwnmnstrondth(entity dthent, float dlytime, vector myoffset, float useoffsetasorigin);
void monster_readscrollondth(entity dthent, float dlytime, vector myoffset, float useoffsetasorigin, float mystvagls);
float allow_trapondth(entity dthent);
void trapspring_xyzz(float mytrap, float mystyle, float myamnt, entity myfriend, vector myorigin, entity myenemy, float mydelay);

float Item_GiveTo(entity item, entity player);

void multitool_thirdpartycallupdateammoon(entity player);
float multitool_countisfloor (float mycount); //Defined below

void multitool_spawner();

void SMI_SetOriginVsBldAngles (entity myitem, vector myoffset, entity mybuilding);


void multitool_setinventory_droptype_wpn1(entity myent)
{
	local float mygvwpn;
	mygvwpn = 0;
	
	if (autocvar_g_defaultstartsomegunsweaponset_fllw_wpn_pkups) {
		//So as not to break theme
		if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_WWIWPNS)
		{
			mygvwpn = weapon_wwireplacement();
		}
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_OLDWESTWPNS)
		{
			mygvwpn = weapon_oldwestreplacement();
		}
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_MODGUNCIVILWPNS)
		{
			mygvwpn = weapon_moderngunsreplacement();
		}
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_GUNXPLSVENRGYWPNS)
		{
			local float myrandom;
			myrandom = random();
			if (myrandom > 0.8) {
				mygvwpn = weapon_moderngunsreplacement();
			} else if (myrandom > 0.65) {
				mygvwpn = weapon_moderngunscivilianreplacement();
			} else if (myrandom > 0.55) {
				mygvwpn = weapon_explosivesreplacement();
			} else if (myrandom > 0.2) {
				mygvwpn = weapon_energyreplacement();
			} else {
				mygvwpn = weapon_moderntoolsreplacement();
			}
		}
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_SCROLLS)
		{
			mygvwpn = weapon_medievalreplacement();
		} 
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_MDVL_WPNS)
		{
			mygvwpn = weapon_medievalreplacement();
		} 
		else if (autocvar_g_replace_weapon_pickups == GREPLACEWEAPONPICKUPS_MDVL_WPNS_SCROLLS)
		{
			mygvwpn = weapon_medievalreplacement();
		} else {
			mygvwpn = weapon_medievalreplacement();
		}
	} else {
		mygvwpn = weapon_medievalreplacement();
	}
	
	if (mygvwpn) {
		//print("\n\n\n****************WEAPON GIVING BARREL******************:",ftos(mygvwpn),"\n\n\n");
		WEPSET_OR_EW(myent, mygvwpn);
		myent.multitool_forceinventory_weapon = 1;
	}
}


void multitool_setinventory_droptype_misc(entity myent, float mydroptype)
{
			local float snrandvar, mnrandvar;
			snrandvar = random();
			switch(mydroptype)
			{
				//medieval
				default:
				case 0:
					//print("\n\n***WINE***\n\n");
					//Wine
					if (snrandvar > 0.75) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_merlot_large++;
						} else {
							myent.inv_potion_merlot_medium++;
						}
					} else if (snrandvar > 0.5) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_ale_large++;
						} else {
							myent.inv_potion_ale_medium++;
						}
					} else if (snrandvar > 0.25) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_vodka_large++;
						} else {
							myent.inv_potion_vodka_medium++;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_water_large++;
						} else {
							myent.inv_potion_water_medium++;
						}
					}
					break;
				case 1:
					//print("\n\n***MEDIEVAL BARREL***\n\n");
					//medieval
					mnrandvar = random();
					if (mnrandvar > 0.9) {
						mnrandvar = floor(random()*51);
					} else if (mnrandvar > 0.75) {
						mnrandvar = floor(random()*26);
					} else if (mnrandvar > 0.6) {
						mnrandvar = floor(random()*21);
					} else if (mnrandvar > 0.5) {
						mnrandvar = floor(random()*16);
					} else {
						mnrandvar= floor(random()*10);
					}
					
					//Note: mnrandvar could turn out to be zero after floor()
					
					if (snrandvar > 0.9) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_health_large++;
						} else {
							myent.inv_potion_health_medium++;
						}
					} else if (snrandvar > 0.75) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_mana_large++;
						} else {
							myent.inv_potion_mana_medium++;
						}
					} else if (snrandvar > 0.6) {
						//wpn
						multitool_setinventory_droptype_wpn1(self);
					} else if (snrandvar > 0.3) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_copper += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_bronze += mnrandvar;
						} else {
							myent.inv_coin_iron += mnrandvar;
						}
					} else if (snrandvar > 0.1) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_bronze += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_iron += mnrandvar;
						} else {
							myent.inv_coin_tin += mnrandvar;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.9) {
							myent.inv_coin_gold += mnrandvar;
						} else if (snrandvar > 0.75) {
							myent.inv_coin_silver += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_copper += mnrandvar;
						} else {
							myent.inv_coin_bronze += mnrandvar;
						}
					}
					break;
				case 2:
					//print("\n\n***MEDIEVAL MONEY 1***\n\n");
					//medieval money 1
					mnrandvar = random();
					if (mnrandvar > 0.9) {
						mnrandvar = floor(random()*51);
					} else if (mnrandvar > 0.75) {
						mnrandvar = floor(random()*26);
					} else if (mnrandvar > 0.6) {
						mnrandvar = floor(random()*21);
					} else if (mnrandvar > 0.5) {
						mnrandvar = floor(random()*16);
					} else {
						mnrandvar= floor(random()*10);
					}
					
					//Note: mnrandvar could turn out to be zero after floor()
					
					if (snrandvar > 0.3) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_copper += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_bronze += mnrandvar;
						} else {
							myent.inv_coin_iron += mnrandvar;
						}
					} else if (snrandvar > 0.1) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_bronze += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_iron += mnrandvar;
						} else {
							myent.inv_coin_tin += mnrandvar;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.9) {
							myent.inv_coin_gold += mnrandvar;
						} else if (snrandvar > 0.75) {
							myent.inv_coin_silver += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_copper += mnrandvar;
						} else {
							myent.inv_coin_bronze += mnrandvar;
						}
					}
					break;
				case 3:
					//print("\n\n***MEDIEVAL MONEY 2***\n\n");
					//medieval money 2
					mnrandvar = random();
					if (mnrandvar > 0.9) {
						mnrandvar = floor(random()*101);
					} else if (mnrandvar > 0.75) {
						mnrandvar = floor(random()*56);
					} else if (mnrandvar > 0.6) {
						mnrandvar = floor(random()*31);
					} else if (mnrandvar > 0.5) {
						mnrandvar = floor(random()*26);
					} else {
						mnrandvar= floor(random()*10);
					}
					
					//Note: mnrandvar could turn out to be zero after floor()
					
					if (snrandvar > 0.3) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_copper += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_bronze += mnrandvar;
						} else {
							myent.inv_coin_iron += mnrandvar;
						}
					} else if (snrandvar > 0.1) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_bronze += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_iron += mnrandvar;
						} else {
							myent.inv_coin_tin += mnrandvar;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.9) {
							myent.inv_coin_gold += mnrandvar;
						} else if (snrandvar > 0.75) {
							myent.inv_coin_silver += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_copper += mnrandvar;
						} else {
							myent.inv_coin_bronze += mnrandvar;
						}
					}
					break;
				case 4:
					//print("\n\n***MEDIEVAL MONEY 3***\n\n");
					//medieval money 3
					mnrandvar = random();
					if (mnrandvar > 0.9) {
						mnrandvar = floor(random()*101);
					} else if (mnrandvar > 0.75) {
						mnrandvar = floor(random()*56);
					} else if (mnrandvar > 0.6) {
						mnrandvar = floor(random()*31);
					} else if (mnrandvar > 0.5) {
						mnrandvar = floor(random()*26);
					} else {
						mnrandvar= floor(random()*10);
					}
					
					//Note: mnrandvar could turn out to be zero after floor()
					
					if (snrandvar > 0.75) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_copper += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_bronze += mnrandvar;
						} else {
							myent.inv_coin_iron += mnrandvar;
						}
					} else if (snrandvar > 0.5) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_coin_bronze += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_iron += mnrandvar;
						} else {
							myent.inv_coin_tin += mnrandvar;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.9) {
							myent.inv_coin_gold += mnrandvar;
						} else if (snrandvar > 0.75) {
							myent.inv_coin_silver += mnrandvar;
						} else if (snrandvar > 0.5) {
							myent.inv_coin_copper += mnrandvar;
						} else {
							myent.inv_coin_bronze += mnrandvar;
						}
					}
					break;
				case 5:
					//print("\n\n***WEAPON***\n\n");
					//Weapon
					multitool_setinventory_droptype_wpn1(self);
					break;
				case 6:
					//print("\n\n***POTIONS***\n\n");
					//Potions
					snrandvar = random();
					if (snrandvar > 0.6) {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_health_large++;
						} else {
							myent.inv_potion_health_medium++;
						}
					} else {
						snrandvar = random();
						
						if (snrandvar > 0.75) {
							myent.inv_potion_mana_large++;
						} else {
							myent.inv_potion_mana_medium++;
						}
					} 
					break;
			}
}

void multitool_setinventory_droptype(entity myent, float mydroptype)
{
	local float snrandvar;
	switch(mydroptype)
	{
		//medieval
		default:
		case 0:
			//Wine
			multitool_setinventory_droptype_misc(myent, 0);
			break;
		case 1:
			//Barrel
			multitool_setinventory_droptype_misc(myent, 1);
			break;
		case 2:
			//Chest
			snrandvar = random();
			if (snrandvar > 0.95) {
				multitool_setinventory_droptype_misc(myent, 2);
				multitool_setinventory_droptype_misc(myent, 2);
			} else if (snrandvar > 0.9) {
				multitool_setinventory_droptype_misc(myent, 1);
			} else {
				//money
				multitool_setinventory_droptype_misc(myent, 2);
			}
			break;
		case 3:
			//Chest2
			snrandvar = random();
			if (snrandvar > 0.95) {
				multitool_setinventory_droptype_misc(myent, 4);
				multitool_setinventory_droptype_misc(myent, 3);
				multitool_setinventory_droptype_misc(myent, 2);
			} else if (snrandvar > 0.9) {
				multitool_setinventory_droptype_misc(myent, 2);
				multitool_setinventory_droptype_misc(myent, 3);
				multitool_setinventory_droptype_misc(myent, 3);
			} else if (snrandvar > 0.8) {
				multitool_setinventory_droptype_misc(myent, 3);
				multitool_setinventory_droptype_misc(myent, 2);
			} else if (snrandvar > 0.7) {
				multitool_setinventory_droptype_misc(myent, 3);
			} else if (snrandvar > 0.6) {
				multitool_setinventory_droptype_misc(myent, 1);
				multitool_setinventory_droptype_misc(myent, 1);
			} else if (snrandvar > 0.5) {
				multitool_setinventory_droptype_misc(myent, 5);
			} else if (snrandvar > 0.4) {
				multitool_setinventory_droptype_misc(myent, 6);
				multitool_setinventory_droptype_misc(myent, 6);
			} else {
				//money
				multitool_setinventory_droptype_misc(myent, 2);
			}
			break;
					
	}
}


void multitool_settrap_trapstyle(entity myent, float mytrapset)
{
	local float snrandvar;
	if (mytrapset < 1000) {
		myent.trapondth_trap = mytrapset;
		myent.trapondth_amnt = 1;
	} else {
		mytrapset = mytrapset - 1000;
		switch(mytrapset)
		{
			//medieval
			default:
			case 0:
				//1000 //100 arrows!
				myent.trapondth_trap = 0;
				myent.trapondth_amnt = 100;
				myent.trapondth_dirstyle = 3; //from all directions
				break;
			case 1:
				//1001 //Chests etc
				myent.trapondth_dirstyle = 0; //Defaults
				
				snrandvar = random();
				if (snrandvar > 0.90) {
					myent.trapondth_trap = 20;// flamethrower
				} else if (snrandvar > 0.75) {
					myent.trapondth_trap = 18;// big fireball
				} else {
					myent.trapondth_trap = 0;
					snrandvar = random();
					if (snrandvar > 0.90) {
						myent.trapondth_amnt = 5;
					} else if (snrandvar > 0.75) {
						myent.trapondth_amnt = 3;
					}
				}
				break;
		}
	}
}


///////////////////////////////////////////////////////
//SPAWNFUNCTIONS FOR MAPS//////////////////////////////
//BEGIN////////////////////////////////////////////////

//Here we have some functions to make it easier for
//mappers to incorporate furnishings into their maps

void spawnmultitoolbuildablefrommap(float mycount) {
	setorigin(self, self.origin);
	self.multitool_forceangle = 1;
	self.multitool_forcecolor = 1;
	if (self.skin) {
		self.multitool_forceskin = self.skin;
	} else {
		self.multitool_forceskin = 0;
	}
	self.multitool_forceinventory = 1;
	self.count = mycount;
	self.think = multitool_spawner;
	self.nextthink = time;
}



void spawnfunc_building_buildable_by_count()
{
	spawnmultitoolbuildablefrommap(self.count);
}




void spawnfunc_furniture_classic_CHAIR_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAIR_WOOD);
}


void spawnfunc_furniture_classic_CHAIR_WOOD2()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAIR_WOOD2);
}


void spawnfunc_furniture_classic_STOOL_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_STOOL_WOOD);
}


void spawnfunc_furniture_classic_BENCH_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BENCH_WOOD);
}


void spawnfunc_furniture_classic_TABLE_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_TABLE_WOOD);
}


void spawnfunc_furniture_classic_TABLE_WOOD2()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_TABLE_WOOD2);
}


void spawnfunc_furniture_classic_TABLE_WOOD3()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_TABLE_WOOD3);
}


void spawnfunc_furniture_classic_TABLE_OCT_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_TABLE_OCT_WOOD);
}


void spawnfunc_furniture_classic_TABLE_OCT_WOOD2()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_TABLE_OCT_WOOD2);
}


void spawnfunc_furniture_classic_WORKBENCH()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_WORKBENCH);
}


void spawnfunc_furniture_classic_BLKSMHBELLOWS()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BLKSMHBELLOWS);
}


void spawnfunc_furniture_classic_BLKSMHFORGE()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BLKSMHFORGE);
}


void spawnfunc_furniture_classic_BLKSMHANVIL()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BLKSMHANVIL);
}


void spawnfunc_furniture_classic_BLKSMHGRNDSTN()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BLKSMHGRNDSTN);
}


void spawnfunc_furniture_classic_BARREL_WOOD2()
{
	if (autocvar_g_balance_multitool_barrel_wood2_forcesolidslidebox) {
		self.multitool_forcesolidtype = SOLID_SLIDEBOX;
	}
	if (autocvar_g_balance_multitool_barrel_wood2_forcenotdragable) {
		self.multitool_forcenotdragable = 1;
	}
	if (autocvar_g_balance_multitool_barrel_wood2_trap) {
		if (!self.trapondth) {
		if (autocvar_g_balance_multitool_barrel_wood2_trap >= 1
		|| autocvar_g_balance_multitool_barrel_wood2_trap > random()) {
			self.trapondth = 1;
			self.trapondth_onlyonce = 1; //Trap springs once total, can be more if set to a higher number
			self.trapondth_ontake = 1; //We spring on search
			self.trapondth_ontake_amnt = -1; //Unlimited, if the onlyonce wasn't set
			self.trapondth_onput = 1; //We spring on put
			self.trapondth_onput_amnt = -1; //Unlimited, if the onlyonce wasn't set
			self.trapondth_onsearch = 1; //We spring on take
			self.trapondth_onsearch_amnt = -1; //Unlimited, if the onlyonce wasn't set
			multitool_settrap_trapstyle(self, autocvar_g_balance_multitool_barrel_wood2_trap_type);
		}
		}
	}
	if (autocvar_g_balance_multitool_barrel_wood2_explode) {
		if (!self.xplodondth) {
		if (autocvar_g_balance_multitool_barrel_wood2_explode >= 1
		|| autocvar_g_balance_multitool_barrel_wood2_explode > random()) {
			self.xplodondth = 1;
			self.xplodondth_type = autocvar_g_balance_multitool_barrel_wood2_explode_type;
			if (self.xplodondth_type == 0 || self.xplodondth_type == 4) {
				precache_sound ("ardentryst/flame_whoosh.ogg");
			}
		}
		}
	}
	if (autocvar_g_balance_multitool_barrel_wood2_skeleton) {
		if (autocvar_g_balance_multitool_barrel_wood2_skeleton_xclsv
		&& self.xplodondth) {
			//Do nothing
			//print("Do Nothing\n");
		} else if (!self.spwnmnstrondth) {
			if (autocvar_g_balance_multitool_barrel_wood2_skeleton >= 1
			|| autocvar_g_balance_multitool_barrel_wood2_skeleton > random()) {
				self.spwnmnstrondth = 1;
				self.spwnmnstrondth_monster = "skeleton";
			}
		}
	}
	if (autocvar_g_balance_multitool_barrel_wood2_isweak) {
		if (!self.isweak) {
		if (autocvar_g_balance_multitool_barrel_wood2_isweak >= 1
		|| autocvar_g_balance_multitool_barrel_wood2_isweak > random()) {
			self.isweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_barrel_wood2_isveryweak) {
		if (!self.isveryweak) {
		if (autocvar_g_balance_multitool_barrel_wood2_isveryweak >= 1
		|| autocvar_g_balance_multitool_barrel_wood2_isveryweak > random()) {
			self.isveryweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_barrel_wood2_drop) {
		if (autocvar_g_balance_multitool_barrel_wood2_drop_xclsv
		&& (self.xplodondth || self.spwnmnstrondth)) {
			//Do nothing
			//print("DO Nothing\n");
		} else if (autocvar_g_balance_multitool_barrel_wood2_drop >= 1
		|| autocvar_g_balance_multitool_barrel_wood2_drop > random()) {
			if (autocvar_g_balance_multitoolutilitool_noanimdroppeditems) {
				self.noanimdroppeditems = 1;
				self.inventory_permitems = 1;
			}
			
			multitool_setinventory_droptype(self, autocvar_g_balance_multitool_barrel_wood2_drop_type);
		}
	}
	spawnmultitoolbuildablefrommap(MTB64_FURN_BARREL_WOOD2);
}


void spawnfunc_furniture_classic_BARREL_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BARREL_WOOD);
}


void spawnfunc_furniture_classic_BED_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BED_WOOD);
}


void spawnfunc_furniture_classic_CHEST_WOOD()
{
	if (autocvar_g_balance_multitool_chest_wood_forcesolidslidebox) {
		self.multitool_forcesolidtype = SOLID_SLIDEBOX;
	}
	if (autocvar_g_balance_multitool_chest_wood_forcenotdragable) {
		self.multitool_forcenotdragable = 1;
	}
	if (autocvar_g_balance_multitool_chest_wood_trap) {
		if (!self.trapondth) {
		if (autocvar_g_balance_multitool_chest_wood_trap >= 1
		|| autocvar_g_balance_multitool_chest_wood_trap > random()) {
			self.trapondth = 1;
			self.trapondth_onlyonce = 1; //Trap springs once total, can be more if set to a higher number
			self.trapondth_ontake = 1;
			self.trapondth_ontake_amnt = -1;
			self.trapondth_onput = 1;
			self.trapondth_onput_amnt = -1;
			self.trapondth_onsearch = 1;
			self.trapondth_onsearch_amnt = -1;
			multitool_settrap_trapstyle(self, autocvar_g_balance_multitool_chest_wood_trap_type);
		}
		}
	}
	if (autocvar_g_balance_multitool_chest_wood_explode) {
		if (!self.xplodondth) {
		if (autocvar_g_balance_multitool_chest_wood_explode >= 1
		|| autocvar_g_balance_multitool_chest_wood_explode > random()) {
			self.xplodondth = 1;
			self.xplodondth_type = autocvar_g_balance_multitool_chest_wood_explode_type;
			if (self.xplodondth_type == 0 || self.xplodondth_type == 4) {
				precache_sound ("ardentryst/flame_whoosh.ogg");
			}
		}
		}
	}
	if (autocvar_g_balance_multitool_chest_wood_skeleton) {
		if (autocvar_g_balance_multitool_chest_wood_skeleton_xclsv
		&& self.xplodondth) {
			//Do nothing
			//print("Do Nothing\n");
		} else if (!self.spwnmnstrondth) {
			if (autocvar_g_balance_multitool_chest_wood_skeleton >= 1
			|| autocvar_g_balance_multitool_chest_wood_skeleton > random()) {
				self.spwnmnstrondth = 1;
				self.spwnmnstrondth_monster = "skeleton";
			}
		}
	}
	if (autocvar_g_balance_multitool_chest_wood_isweak) {
		if (!self.isweak) {
		if (autocvar_g_balance_multitool_chest_wood_isweak >= 1
		|| autocvar_g_balance_multitool_chest_wood_isweak > random()) {
			self.isweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_chest_wood_isveryweak) {
		if (!self.isveryweak) {
		if (autocvar_g_balance_multitool_chest_wood_isveryweak >= 1
		|| autocvar_g_balance_multitool_chest_wood_isveryweak > random()) {
			self.isveryweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_chest_wood_drop) {
		if (autocvar_g_balance_multitool_chest_wood_drop_xclsv
		&& (self.xplodondth || self.spwnmnstrondth)) {
			//Do nothing
			//print("DO Nothing\n");
		} else if (autocvar_g_balance_multitool_chest_wood_drop >= 1
		|| autocvar_g_balance_multitool_chest_wood_drop > random()) {
			if (autocvar_g_balance_multitoolutilitool_noanimdroppeditems) {
				self.noanimdroppeditems = 1;
				self.inventory_permitems = 1;
			}
			
			multitool_setinventory_droptype(self, autocvar_g_balance_multitool_chest_wood_drop_type);
		}
	}
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHEST_WOOD);
}


void spawnfunc_furniture_classic_CHESTLARGE_WOOD()
{
	if (autocvar_g_balance_multitool_chestlarge_wood_forcesolidslidebox) {
		self.multitool_forcesolidtype = SOLID_SLIDEBOX;
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_forcenotdragable) {
		self.multitool_forcenotdragable = 1;
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_trap) {
		if (!self.trapondth) {
		if (autocvar_g_balance_multitool_chestlarge_wood_trap >= 1
		|| autocvar_g_balance_multitool_chestlarge_wood_trap > random()) {
			self.trapondth = 1;
			self.trapondth_onlyonce = 1; //Trap springs once total, can be more if set to a higher number
			self.trapondth_ontake = 1;
			self.trapondth_ontake_amnt = -1;
			self.trapondth_onput = 1;
			self.trapondth_onput_amnt = -1;
			self.trapondth_onsearch = 1;
			self.trapondth_onsearch_amnt = -1;
			multitool_settrap_trapstyle(self, autocvar_g_balance_multitool_chestlarge_wood_trap_type);
		}
		}
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_explode) {
		if (!self.xplodondth) {
		if (autocvar_g_balance_multitool_chestlarge_wood_explode >= 1
		|| autocvar_g_balance_multitool_chestlarge_wood_explode > random()) {
			self.xplodondth = 1;
			self.xplodondth_type = autocvar_g_balance_multitool_chestlarge_wood_explode_type;
			if (self.xplodondth_type == 0 || self.xplodondth_type == 4) {
				precache_sound ("ardentryst/flame_whoosh.ogg");
			}
		}
		}
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_skeleton) {
		if (autocvar_g_balance_multitool_chestlarge_wood_skeleton_xclsv
		&& self.xplodondth) {
			//Do nothing
			//print("Do Nothing\n");
		} else if (!self.spwnmnstrondth) {
			if (autocvar_g_balance_multitool_chestlarge_wood_skeleton >= 1
			|| autocvar_g_balance_multitool_chestlarge_wood_skeleton > random()) {
				self.spwnmnstrondth = 1;
				self.spwnmnstrondth_monster = "skeleton";
			}
		}
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_isweak) {
		if (!self.isweak) {
		if (autocvar_g_balance_multitool_chestlarge_wood_isweak >= 1
		|| autocvar_g_balance_multitool_chestlarge_wood_isweak > random()) {
			self.isweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_isveryweak) {
		if (!self.isveryweak) {
		if (autocvar_g_balance_multitool_chestlarge_wood_isveryweak >= 1
		|| autocvar_g_balance_multitool_chestlarge_wood_isveryweak > random()) {
			self.isveryweak = 1;
		}
		}
	}
	if (autocvar_g_balance_multitool_chestlarge_wood_drop) {
		if (autocvar_g_balance_multitool_chestlarge_wood_drop_xclsv
		&& (self.xplodondth || self.spwnmnstrondth)) {
			//Do nothing
			//print("DO Nothing\n");
		} else if (autocvar_g_balance_multitool_chestlarge_wood_drop >= 1
		|| autocvar_g_balance_multitool_chestlarge_wood_drop > random()) {
			if (autocvar_g_balance_multitoolutilitool_noanimdroppeditems) {
				self.noanimdroppeditems = 1;
				self.inventory_permitems = 1;
			}
			
			multitool_setinventory_droptype(self, autocvar_g_balance_multitool_chestlarge_wood_drop_type);
		}
	}
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHESTLARGE_WOOD);
}


void spawnfunc_furniture_classic_CHAIR_FANCY1()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAIR_FANCY1);
}


void spawnfunc_furniture_classic_CHAIR_FANCY2()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAIR_FANCY2);
}


void spawnfunc_furniture_classic_CHAIR_FANCY3()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAIR_FANCY3);
}


void spawnfunc_furniture_classic_CHAISELOUNGE()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_CHAISELOUNGE);
}


void spawnfunc_furniture_classic_IRONMAIDEN()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_IRONMAIDEN);
}

void spawnfunc_furniture_classic_SPIKEDRACK()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_SPIKEDRACK);
}

void spawnfunc_furniture_classic_IMPALEMENTPOLE()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_IMPALEMENTPOLE);
}

void spawnfunc_furniture_classic_GIBBET()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_GIBBET);
}

void spawnfunc_furniture_classic_EMPTYSHELF_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_EMPTYSHELF_WOOD);
}


void spawnfunc_furniture_classic_BOOKSHELF_WOOD()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_BOOKSHELF_WOOD);
}


void spawnfunc_furniture_classic_GREEKPILLAR()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_GREEKPILLAR);
}


void spawnfunc_furniture_classic_GREEKPILLARM()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_GREEKPILLARM);
}


void spawnfunc_furniture_classic_ROMANCOLUMN()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_ROMANCOLUMN);
}


void spawnfunc_furniture_classic_ROMANCOLUMNM()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_ROMANCOLUMNM);
}


void spawnfunc_furniture_classic_IRONBRAZIER()
{
	spawnmultitoolbuildablefrommap(MTB64_FURN_IRONBRAZIER);
}





void spawnfunc_furniture_future_BARRELP()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BARRELP);
}


void spawnfunc_furniture_future_BARRELM()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BARRELM);
}


void spawnfunc_furniture_future_CHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CHAIR);
}


void spawnfunc_furniture_future_CHAIR2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CHAIR2);
}


void spawnfunc_furniture_future_CHAIR3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CHAIR3);
}


void spawnfunc_furniture_future_CHAIR4()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CHAIR4);
}


void spawnfunc_furniture_future_CHAIR5()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CHAIR5);
}


void spawnfunc_furniture_future_SCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SCHAIR);
}


void spawnfunc_furniture_future_OMLCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_OMLCHAIR);
}

void spawnfunc_furniture_future_OMLCHAIR2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_OMLCHAIR2);
}


void spawnfunc_furniture_future_MLHSKCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_MLHSKCHAIR);
}


void spawnfunc_furniture_future_TRIBECACHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TRIBECACHAIR);
}


void spawnfunc_furniture_future_BARCELONACHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BARCELONACHAIR);
}



void spawnfunc_furniture_future_STOOL()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_STOOL);
}


void spawnfunc_furniture_future_CSTOOL()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CSTOOL);
}


void spawnfunc_furniture_future_RETROCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_RETROCHAIR);
}


void spawnfunc_furniture_future_PLSCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_PLSCHAIR);
}

void spawnfunc_furniture_future_SCHINTGRDESK()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SCHINTGRDESK);
}

void spawnfunc_furniture_future_SCHDESKCHAIR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SCHDESKCHAIR);
}

void spawnfunc_furniture_future_RETROTABLE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_RETROTABLE);
}


void spawnfunc_furniture_future_CRATE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_CRATE);
}


void spawnfunc_furniture_future_DESK()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_DESK);
}


void spawnfunc_furniture_future_MGSTDESK()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_MGSTDESK);
}


void spawnfunc_furniture_future_MGSTDESKFLAT()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_MGSTDESKFLAT);
}


void spawnfunc_furniture_future_MGSTDESKFULLCORNER()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_MGSTDESKFULLCORNER);
}

void spawnfunc_furniture_future_TABLE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLE);
}


void spawnfunc_furniture_future_TABLELOW()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLELOW);
}


void spawnfunc_furniture_future_TABLEGLASS()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLEGLASS);
}


void spawnfunc_furniture_future_TABLESQUARE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLESQUARE);
}


void spawnfunc_furniture_future_TABLECIRC()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLECIRC);
}


void spawnfunc_furniture_future_TABLELONG()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TABLELONG);
}


void spawnfunc_furniture_future_FILECABINET()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FILECABINET);
}


void spawnfunc_furniture_future_SHELVES()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SHELVES);
}


void spawnfunc_furniture_future_SERVER()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SERVER);
}


void spawnfunc_furniture_future_LAMP_STREET()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_LAMP_STREET);
}


void spawnfunc_furniture_future_LAMP_STREET2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_LAMP_STREET2);
}


void spawnfunc_furniture_future_LAMP_STREET3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_LAMP_STREET3);
}


void spawnfunc_furniture_future_LAMP_STREET4()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_LAMP_STREET4);
}


void spawnfunc_furniture_future_LAMP_STREET5()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_LAMP_STREET5);
}


void spawnfunc_furniture_future_COMCRATE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_COMCRATE);
}


void spawnfunc_furniture_future_COMCRATE2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_COMCRATE2);
}


void spawnfunc_furniture_future_MTLCRATE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_MTLCRATE);
}


void spawnfunc_furniture_future_TOILET()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TOILET);
}


void spawnfunc_furniture_future_TOILET2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TOILET2);
}


void spawnfunc_furniture_future_TOILET3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_TOILET3);
}


void spawnfunc_furniture_future_SINK()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SINK);
}


void spawnfunc_furniture_future_SINK2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SINK2);
}


void spawnfunc_furniture_future_SINK_PED()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SINK_PED);
}


void spawnfunc_furniture_future_SINK_PED2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SINK_PED2);
}


void spawnfunc_furniture_future_SHOWER()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SHOWER);
}


void spawnfunc_furniture_future_STOVE3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_STOVE3);
}


void spawnfunc_furniture_future_STOVE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_STOVE);
}


void spawnfunc_furniture_future_STOVE2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_STOVE2);
}


void spawnfunc_furniture_future_STOVE4()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_STOVE4);
}


void spawnfunc_furniture_future_FRIDGE()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FRIDGE);
}


void spawnfunc_furniture_future_FRIDGE2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FRIDGE2);
}


void spawnfunc_furniture_future_FRIDGE3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FRIDGE3);
}


void spawnfunc_furniture_future_FRIDGE4()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FRIDGE4);
}


void spawnfunc_furniture_future_BSCKCABINET1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINET1);
}


void spawnfunc_furniture_future_BSCKCABINETTOP1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETTOP1);
}

void spawnfunc_furniture_future_BSCKCABINETTOPDEEP1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETTOPDEEP1);
}

void spawnfunc_furniture_future_BSCKCABINETTOPDEEPSHORT1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1);
}

void spawnfunc_furniture_future_BSCKCABINETTOPSHORT1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETTOPSHORT1);
}

void spawnfunc_furniture_future_BSCKCABINETTOPSHORTSHELVES1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1);
}

void spawnfunc_furniture_future_BSCKCABINET2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINET2);
}

void spawnfunc_furniture_future_BSCKCABINET3()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINET3);
}

void spawnfunc_furniture_future_BSCKCABINET4()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINET4);
}

void spawnfunc_furniture_future_BSCKCABINETCORNER1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNER1);
}

void spawnfunc_furniture_future_BSCKCABINETCORNER2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNER2);
}

void spawnfunc_furniture_future_BSCKCABINETCORNERTOP1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNERTOP1);
}

void spawnfunc_furniture_future_BSCKCABINETCORNERTOP2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNERTOP2);
}


void spawnfunc_furniture_future_BSCKCABINETCORNERTOPDEEP1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1);
}

void spawnfunc_furniture_future_BSCKCABINETCORNERTOPDEEP2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2);
}
void spawnfunc_furniture_future_BSCKCABINETBAR1()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETBAR1);
}

void spawnfunc_furniture_future_BSCKCABINETBARENDR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETBARENDR);
}

void spawnfunc_furniture_future_BSCKCABINETBARENDL()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BSCKCABINETBARENDL);
}

void spawnfunc_furniture_future_FUTON()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_FUTON);
}


void spawnfunc_furniture_future_BED()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BED);
}


void spawnfunc_furniture_future_BED_FOAM()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_BED_FOAM);
}


void spawnfunc_furniture_future_SOFA1BR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA1BR);
}


void spawnfunc_furniture_future_SOFA3BR()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA3BR);
}


void spawnfunc_furniture_future_SOFA1B()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA1B);
}


void spawnfunc_furniture_future_SOFA3B()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA3B);
}


void spawnfunc_furniture_future_SOFA1LW()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA1LW);
}


void spawnfunc_furniture_future_SOFA3LW2()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA3LW2);
}


void spawnfunc_furniture_future_SOFA_FOAM()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA_FOAM);
}


void spawnfunc_furniture_future_SOFA_TARTAN()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA_TARTAN);
}


void spawnfunc_furniture_future_SOFA_POOFY()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA_POOFY);
}


void spawnfunc_furniture_future_SOFA_NORM()
{
	spawnmultitoolbuildablefrommap(MTB64U_FURN_SOFA_NORM);
}


///////////////////////////////////////////////////////
//END//////////////////////////////////////////////////
//SPAWNFUNCTIONS FOR MAPS//////////////////////////////
///////////////////////////////////////////////////////






//This is just for displaying some info about how much turrets, verhicles, etc associated with some buildings cost in terms of forgeparts
//(resources built by forges), So no one will be too suprised if they don't get the vehicle when they didn't have the resources
string multitool_displayforgerequirements (float mycount, string mysentstring) {
	local string addstring;
	local vector forgereq;
	//We use a vector to jot down our 3 variables:
	////////////n r c (forgepieces-nail, f...rockets,f...cells)
	forgereq = '0 0 0';
	
	//These are taken from the code far below, if requirements are updated, make sure to update this so the players know the costs
	if (mycount == 1) {
		if(autocvar_g_balance_multitool_ancientonly) {
			forgereq = '4 0 0';
		} else {
			forgereq = '8 0 0';
		}
	} else if (mycount == 2) {
		forgereq = '4 0 4';
		
	} else if (mycount == 3) {
		forgereq = '4 4 0';
		
	} else if (mycount == 8) {
		forgereq = '4 8 0';
		
	} else if (mycount == 10) {
		forgereq = '5 10 0';
		
	} else if (mycount == 15) {
		if not(autocvar_g_balance_multitool_ancientonly) {
		forgereq = '1 1 0';
		}
		
	} else if (mycount == 16) {
		if not(autocvar_g_balance_multitool_ancientonly) {
		forgereq = '6 0 0';
		}
		
	} else if (mycount == 1005) {
		forgereq = '1 28 0';
		
	} else if (mycount == 1007) {
		forgereq = '2 0 0';
		
	} else if (mycount == 1013) {
		forgereq = '1 0 0';
		
	} else if (mycount == 1014) {
		forgereq = '0 1 0';
		
	} else if (mycount == 1023) {
		forgereq = '1 0 0';
		
	} else if (mycount == 1027) {
		forgereq = '1 0 0';
		
	} else if (mycount == 1029) {
		forgereq = '2 0 0';
		
	} else if (mycount == 1035) {
		forgereq = '1 0 0';
		
	} else if (mycount == 1038) {
		forgereq = '1 0 0';
		
	} else if (mycount == 1120 || mycount == 1121 || mycount == 1122
		|| mycount == 1123 || mycount == 1124 || mycount == 1125
		|| mycount == 1126 || mycount == 1127
		|| mycount == 1130 || mycount == 1131) {
		forgereq = '1 0 0';
	}
	
	if (forgereq_x || forgereq_y || forgereq_z) {
		//Carry on
	} else {
		//No change
		return mysentstring;
	}
	
	
	addstring = "";
	if (forgereq_x)
	{
		addstring = strcat(addstring, "   ^x999", ftos(forgereq_x)," forgeparts-nail^7");
	}
	if (forgereq_y)
	{
		addstring = strcat(addstring, "   ^xE99", ftos(forgereq_y)," forgeparts-rocket^7");
	}
	if (forgereq_z)
	{
		addstring = strcat(addstring, "   ^xC9D", ftos(forgereq_z)," forgeparts-cell^7");
	}
		
	addstring = strcat(mysentstring, addstring);
	
	return addstring;
}

//What to print back (my response) (if anything)
float multitool_hasknowledge (entity player, float mycount, float myresponse, string mysentstring)
{
	local float requirements_met;
	local float req_carpentry;
	local float req_mortise;
	local float req_stonemasonry;
	local float req_ironworking;
	local float req_arch;
	local float req_welding;
	local float req_concrete;
	
	if (autocvar_g_balance_multitool_noknowledgeneeded) {
		if (myresponse == 2) {
			if not (autocvar_g_balance_multitoolutilitool_ignoreforgeparts) {
				mysentstring = multitool_displayforgerequirements (mycount, mysentstring);
			}
			sprint(player, strcat(mysentstring,"\n"));
		}
		return TRUE;
	}
	
	requirements_met = 1; //We start with true, if any are not met (under fulfilment), changed to 0

	req_carpentry = 0;
	req_mortise = 0;
	req_stonemasonry = 0;
	req_ironworking = 0;
	req_arch = 0;
	req_welding = 0;
	req_concrete = 0;
	
	//Requirements;
	
	//Nothing
	if (
	(mycount == 501) //Barley
	|| (mycount >= 520 && mycount <= 529) //Hedgewall
	) {
		//Barley, Just plant
		
	//Welding and Concrete
	} else if (
	(mycount == MTB64U_RCONCRETESQUARE)
	|| (mycount == MTB64U_RCONCRETESQUARE2)
	|| (mycount == 1004) //Glassbase
	|| (mycount == 1005) //Newhangar
	|| (mycount == 1009) //Ammodepot
	|| (mycount == 1010) //Oiltank
	|| (mycount == 1011) //Energy tank
	|| (mycount == 1012) //Apartments
	|| (mycount == 1013) //Tur raised
	|| (mycount == 1014) //Tur medium
	|| (mycount == 1016) //Chem
	|| (mycount == 1017) //Chem
	|| (mycount == 1018) //Chem
	|| (mycount == 1019) //Factory
	|| (mycount == 1020) //Sentry
	|| (mycount == 1021) //Furnace
	|| (mycount == 1022) //OfficeTower
	|| (mycount == 1023) //FireSuppression
	|| (mycount == 1024) //OfficeTwr
	|| (mycount == 1025) //Tension wire tower
	|| (mycount == 1026) //OfficeTwr3
	|| (mycount == 1028) //Covered Garage
	|| (mycount == 1030) //Small energy tank
	|| (mycount == 1032) //Small oil tank
	|| (mycount == 1033) //Distribswitch
	|| (mycount == 1034) //ChemDistribswitch
	|| (mycount == 1038) //Tur AutoSHLAC
	|| (mycount == 1110) //Point Defense
	|| (mycount == 1111)
	|| (mycount == 1112)
	|| (mycount == 1113)
	|| (mycount == 1114)
	|| (mycount == 1115)
	|| (mycount == 1116)
	|| (mycount == 1117)
	|| (mycount == 1118)
	|| (mycount == 1120) //Turrets:
	|| (mycount == 1121)
	|| (mycount == 1122)
	|| (mycount == 1123)
	|| (mycount == 1124)
	|| (mycount == 1125)
	|| (mycount == 1126)
	|| (mycount == 1127)
	|| (mycount == 1130) //Raised Tur
	|| (mycount == 1131)
	|| (mycount == 1136) //Hammerforge
	|| (mycount == 1501) //Greenhouse
	|| (mycount == 1510) //Solarpanel
	|| (mycount >= MTB64U_RCONCRETE && mycount <= MTB64U_RCONCRETELAST)
	) {
		req_concrete = 1;
		req_welding = 1;
		
	//Welding
	} else if (
	(mycount == MTB64U_WINDOW_FUTURE)
	|| (mycount == MTB64U_WINDOW_FUTURE_X)
	|| (mycount == MTB64U_XBEAM_UP)
	|| (mycount == MTB64U_XBEAM_OVER)
	|| (mycount == MTB64U_FLOOR_MTRUSS)
	|| (mycount == MTB64U_BWIRE)
	|| (mycount == MTB64U_BWIRE_X)
	|| (mycount == MTB64U_DOOR_R_PLAIN)
	|| (mycount == MTB64U_DOOR_R_PLAIN2)
	|| (mycount == MTB64U_DOOR_R_STEEL)
	|| (mycount == MTB64U_DOOR_R_GLASS)
	|| (mycount == MTB64U_FITTEDWINDOW_STEELSLIT)
	|| (mycount == MTB64U_FITTEDWINDOW_STEELPLATE)
	|| (mycount == MTB64U_FITTEDWINDOW_CWALL)
	|| (mycount == MTB64U_FITTEDWINDOW_UWINDOW)
	|| (mycount == MTB64U_ARCHIVEBOX)
	|| (mycount == MTB64U_INACT_OIL)
	|| (mycount == MTB64U_ACT_OIL)
	|| (mycount == MTB64U_ACT_EXPL)
	|| (mycount == MTB64U_FURN_BARRELP)
	|| (mycount == MTB64U_FURN_BARRELM)
	|| (mycount == MTB64U_FURN_CHAIR)
	|| (mycount == MTB64U_FURN_CHAIR2)
	|| (mycount == MTB64U_FURN_CHAIR3)
	|| (mycount == MTB64U_FURN_CHAIR4)
	|| (mycount == MTB64U_FURN_CHAIR5)
	|| (mycount == MTB64U_FURN_SCHAIR)
	|| (mycount == MTB64U_FURN_OMLCHAIR)
	|| (mycount == MTB64U_FURN_OMLCHAIR2)
	|| (mycount == MTB64U_FURN_MLHSKCHAIR)
	|| (mycount == MTB64U_FURN_TRIBECACHAIR)
	|| (mycount == MTB64U_FURN_BARCELONACHAIR)
	|| (mycount == MTB64U_FURN_STOOL)
	|| (mycount == MTB64U_FURN_CSTOOL)
	|| (mycount == MTB64U_FURN_RETROCHAIR)
	|| (mycount == MTB64U_FURN_PLSCHAIR)
	|| (mycount == MTB64U_FURN_SCHINTGRDESK)
	|| (mycount == MTB64U_FURN_SCHDESKCHAIR)
	|| (mycount == MTB64U_FURN_RETROTABLE)
	|| (mycount == MTB64U_FURN_CRATE)
	|| (mycount == MTB64U_FURN_DESK)
	|| (mycount == MTB64U_FURN_MGSTDESK)
	|| (mycount == MTB64U_FURN_MGSTDESKFLAT)
	|| (mycount == MTB64U_FURN_MGSTDESKFULLCORNER)
	|| (mycount == MTB64U_FURN_TABLE)
	|| (mycount == MTB64U_FURN_TABLELOW)
	|| (mycount == MTB64U_FURN_TABLEGLASS)
	|| (mycount == MTB64U_FURN_TABLESQUARE)
	|| (mycount == MTB64U_FURN_TABLECIRC)
	|| (mycount == MTB64U_FURN_TABLELONG)
	|| (mycount == MTB64U_FURN_FILECABINET)
	|| (mycount == MTB64U_FURN_SHELVES)
	|| (mycount == MTB64U_FURN_SERVER)
	|| (mycount == MTB64U_FURN_LAMP_STREET)
	|| (mycount == MTB64U_FURN_LAMP_STREET2)
	|| (mycount == MTB64U_FURN_LAMP_STREET3)
	|| (mycount == MTB64U_FURN_LAMP_STREET4)
	|| (mycount == MTB64U_FURN_LAMP_STREET5)
	|| (mycount == MTB64U_FURN_COMCRATE)
	|| (mycount == MTB64U_FURN_COMCRATE2)
	|| (mycount == MTB64U_FURN_MTLCRATE) //Sinks and shower fall to concrete
	|| (mycount == MTB64U_FURN_STOVE3)
	|| (mycount == MTB64U_FURN_STOVE)
	|| (mycount == MTB64U_FURN_STOVE2)
	|| (mycount == MTB64U_FURN_STOVE4)
	|| (mycount == MTB64U_FURN_FRIDGE)
	|| (mycount == MTB64U_FURN_FRIDGE2)
	|| (mycount == MTB64U_FURN_FRIDGE3)
	|| (mycount == MTB64U_FURN_FRIDGE4)
	|| (mycount == MTB64U_FURN_BSCKCABINET1)
	|| (mycount == MTB64U_FURN_BSCKCABINETTOP1)
	|| (mycount == MTB64U_FURN_BSCKCABINETTOPDEEP1)
	|| (mycount == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1)
	|| (mycount == MTB64U_FURN_BSCKCABINETTOPSHORT1)
	|| (mycount == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1)
	|| (mycount == MTB64U_FURN_BSCKCABINET2)
	|| (mycount == MTB64U_FURN_BSCKCABINET3)
	|| (mycount == MTB64U_FURN_BSCKCABINET4)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNER1)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNER2)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNERTOP1)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNERTOP2)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1)
	|| (mycount == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2)
	|| (mycount == MTB64U_FURN_BSCKCABINETBAR1)
	|| (mycount == MTB64U_FURN_BSCKCABINETBARENDR)
	|| (mycount == MTB64U_FURN_BSCKCABINETBARENDL)
	|| (mycount == MTB64U_FURN_FUTON) //.. keeping it simple for now
	|| (mycount == MTB64U_FURN_BED)  //Internal metal supports perhaps
	|| (mycount == MTB64U_FURN_BED_FOAM)
	|| (mycount == MTB64U_FURN_SOFA1BR)
	|| (mycount == MTB64U_FURN_SOFA3BR)
	|| (mycount == MTB64U_FURN_SOFA1B)
	|| (mycount == MTB64U_FURN_SOFA3B)
	|| (mycount == MTB64U_FURN_SOFA1LW)
	|| (mycount == MTB64U_FURN_SOFA3LW)
	|| (mycount == MTB64U_FURN_SOFA1LW2)
	|| (mycount == MTB64U_FURN_SOFA3LW2)
	|| (mycount == MTB64U_FURN_SOFA_FOAM)
	|| (mycount == MTB64U_FURN_SOFA_TARTAN)
	|| (mycount == MTB64U_FURN_SOFA_POOFY)
	|| (mycount == MTB64U_FURN_SOFA_NORM)
	|| (mycount == MTB64U_CLAIMSTONE)
	|| (mycount == 1002) //Shieldgen
	|| (mycount == 1015) //Oilpump
	|| (mycount == 1031) //Shieldgen Canopy
	|| (mycount == 1502) //Recruitment post
	|| (mycount == 1546) //MovingGate steel
	|| (mycount >= 1520 && mycount <= 1529) //Fence Mil
	|| (mycount >= 1650 && mycount <= 1659) //Metal and energy bridge
	|| (mycount >= 1680 && mycount <= 1685) //Metal "vault"s
	|| (mycount >= MTB64U_METAL && mycount <= MTB64U_METALLAST)
	) {
		req_welding = 1;
		
	//Concrete
	} else if (
	(mycount == 1007) //Tankpad
	|| (mycount == 1029) //APC Pad
	|| (mycount == MTB64U_PLATFORM_8)
	|| (mycount == MTB64U_PLATFORM_16)
	|| (mycount == MTB64U_PLATFORM_24)
	|| (mycount == MTB64U_PLATFORM_32)
	//Test the fallback || (mycount == MTB64U_CONCRETESQUARE)
	|| (mycount >= 1530 && mycount <= 1549) //Wall Concrete
	|| (mycount >= 1550 && mycount <= 1559) //Tank Traps
	|| (mycount >= 1630 && mycount <= 1639) //Foundation Concrete
	|| (mycount >= 1686 && mycount <= 1689) //Concrete "vault"
	|| (mycount >= MTB64U_CONCRETE && mycount <= MTB64U_CONCRETELAST)
	) {
		req_concrete = 1;
		
	//Carpentry and mortise (complex wooden joints)
	} else if (
	(mycount == MTB64_DOOR_R_FWOOD)
	|| (mycount == MTB64_FURN_CHAIR_FANCY1)
	|| (mycount == MTB64_FURN_CHAIR_FANCY2)
	|| (mycount == MTB64_FURN_CHAIR_FANCY3)
	|| (mycount == MTB64_FURN_CHAISELOUNGE)
	|| (mycount == MTB64_FURN_TABLE_OCT_WOOD)
	|| (mycount == MTB64_FURN_TABLE_OCT_WOOD2)
	|| (mycount == 20) //Treetop Sentry
	|| (mycount == -3) //Wooden japanese shrine
	|| (mycount == -4) //Wooden japanese dojo
	) {
		req_carpentry = 1;
		req_mortise = 1;
		
	//StoneMasonry, Ironwork and Carpentry
	} else if (
	(mycount == 5)
	|| (mycount == 7)
	|| (mycount == 22) //(Big) Gaol (like an old fortress)
	|| (mycount == 10702) //Castle Wall interior window (big so needs carpentry too)
	) {
		//Castles (have iron doors)
		//Stronghold
		req_stonemasonry = 1;
		req_ironworking = 1;
		req_carpentry = 1;
	
	//StoneMasonry, Ironwork, Mortise and Carpentry
	} else if (
	(mycount == 11)
	) {
		//Gmanse
		req_stonemasonry = 1;
		req_ironworking = 1;
		req_carpentry = 1;
		req_mortise = 1;
		
	//StoneMasonry, Ironwork, Mortise, Arch and Carpentry
	} else if (
	(mycount == 17)
	|| (mycount == 18)
	) {
		//Chataue, Palladian Manor
		req_stonemasonry = 1;
		req_ironworking = 1;
		req_arch = 1;
		req_carpentry = 1;
		req_mortise = 1;
	
	//StoneMasonry, Ironwork, Arch and Carpentry
	} else if (
	(mycount == 10705) //Castle wall interior arch with iron bars grate
	|| (mycount == 10707) //Castle wall interior alcove top w/copper roof
	|| (mycount == 27) //Crusader Stronghold
	) {
		req_stonemasonry = 1;
		req_ironworking = 1;
		req_arch = 1;
		req_carpentry = 1;

	//Bridge Landings: StoneMasonry,Carpentry
	} else if (
	(mycount == 650)
	|| (mycount == 660)
	|| (mycount == 670)
	) {
		req_stonemasonry = 1;
		req_carpentry = 1;	
	//StoneMasonry, Arch and Carpentry
	} else if (
	(mycount == 566) //Curtain Vault
	|| (mycount == 569) //Curtain wall large gate (large arch)
	|| (mycount == 574) //Castle Vault:
	|| (mycount == 575) //Castle Vault: Star chamber
	|| (mycount == 10704) //Castle wall interior arch
	|| (mycount == 10706) //Castle wall interior alcove
	|| (mycount == 10708) //Castle wall large gate (large arch)
	|| (mycount == 583) //Vault Polish
	|| (mycount == 588) //Polish wall large gate (large arch) 
	|| (mycount == 616) //Dome Roof
	|| (mycount >= 650 && mycount <= 659) //Bridge: Curtain
	|| (mycount >= 660 && mycount <= 669) //Bridge: Castle
	|| (mycount >= 670 && mycount <= 679) //Bridge: Polish
	) {
		//Bridges, vaults
		req_arch = 1;
		req_stonemasonry = 1;
		req_carpentry = 1;
	
	//StoneMasonry, Mortise and Carpentry
	} else if (
	(mycount == -615) //Brick Trapdoor
	|| (mycount == 21) //Siege Workshop
	|| (mycount == 10709) //Wooden portcullis
	) {
		req_stonemasonry = 1;
		req_carpentry = 1;
		req_mortise = 1;
	
	//Mortise Ironwork and Carpentry
	} else if (
	(mycount == 610) //Roof, copper (has intracate wood supports tho)
	|| (mycount == 611) //Roof, copper (has intracate wood supports tho)
	|| (mycount == 612) //Roof, copper (has intracate wood supports tho)
	) {
		req_ironworking = 1;
		req_carpentry = 1;
		req_mortise = 1;
	
	//Mortise and Carpentry
	} else if (
	(mycount >= 544 && mycount <= 549) //Roman Palisade
	|| (mycount >= 645 && mycount <= 649) //Roman Bridge
	) {
		req_carpentry = 1;
		req_mortise = 1;
	
	//StoneMasonry and Ironwork
	} else if (
	(mycount == MTB64_FITTEDWINDOW_WINDOW)
	|| (mycount == 10710) //Iron portcullis
	) {
		//Small piece, doesn't need carpentry (or all iron and stone door like iron portcullis)
		req_stonemasonry = 1;
		req_ironworking = 1;
	
	//StoneMasonry and Carpentry
	} else if (
	(mycount == 1)  //MG Tower
	|| (mycount == 2)  //Electrotower
	|| (mycount == 3)  //Rocket
	|| (mycount == -1) //SniperTower
	|| (mycount == -5) //BellTower
	|| (mycount == 6) //StrongTower
	|| (mycount == 8) //Hellion
	|| (mycount == 10) //HK Tower
	|| (mycount == 4)  //Garrison
	|| (mycount == 9)  //Townhall
	|| (mycount == 12) //arsenal
	|| (mycount == 13) //barracks
	|| (mycount == 14) //church (basic, 1 story)
	|| (mycount == 15) //Old hangar
	|| (mycount == 16) //Old tank hangar
	|| (mycount == 19) //Stonehouse
	|| (mycount == 23) //Small jail
	|| (mycount >= 560 && mycount <= 569) //Curtain wall
	|| (mycount >= 570 && mycount <= 579) //CastleWall
	|| (mycount >= 10700 && mycount <= 10799) //CastleWall Interior
	|| (mycount >= 580 && mycount <= 589) //Polish Wall
	) {
		//Stone Buildings
		//Towers
		req_stonemasonry = 1;
		req_carpentry = 1;
		
	//Ironwork and Carpentry
	} else if (
	(mycount == MTB64_FURN_BLKSMHANVIL)
	|| (mycount == 110) //Hotchkissgun or scorpion
	|| (mycount == 111) //Lewisgun
	|| (mycount == 112) //Maximgun
	|| (mycount == MTB64_BWIRE) //Old style barbed wire
	) {
		req_ironworking = 1;
		req_carpentry = 1;
		
	//Ironwork only
	} else if (
	(mycount == MTB64_WINDOW_IRONBAR)
	|| (mycount == MTB64_DOOR_R_IRONBAR)
	|| (mycount == MTB64_FURN_IRONMAIDEN)
	|| (mycount == MTB64_FURN_SPIKEDRACK)
	|| (mycount == MTB64_FURN_GIBBET)
	|| (mycount == MTB64_FURN_IRONBRAZIER)
	|| (mycount == -610) //Iron Spikes floor
	|| (mycount == -618) //Iron Trap Grate
	) {
		req_ironworking = 1;
		
	//(Basic)Carpentry only
	} else if (
	(mycount >= MTB64_FILLED && mycount <= MTB64_FILLED)
	|| (mycount >= MTB64_SHINGLES && mycount <= MTB64_SHINGLESLAST)
	|| (mycount >= MTB64_WOOD1 && mycount <= MTB64_WOOD1)
	|| (mycount >= MTB64_WOOD2 && mycount <= MTB64_WOOD2)
	|| (mycount >= MTB64_SHINGLES2 && mycount <= MTB64_SHINGLES2LAST)
	|| (mycount == MTB64_STAKES_WOOD1)
	|| (mycount == MTB64_WINDOW_WOODBAR)
	|| (mycount == MTB64_DOOR_R_WOOD)
	|| (mycount == MTB64_DOOR_R_JWOOD)
	|| (mycount == MTB64_PLATFORMWOOD_8)
	|| (mycount == MTB64_PLATFORMWOOD_24)
	|| (mycount == MTB64_FURN_CHAIR_WOOD)
	|| (mycount == MTB64_FURN_CHAIR_WOOD2)
	|| (mycount == MTB64_FURN_STOOL_WOOD)
	|| (mycount == MTB64_FURN_BENCH_WOOD)
	|| (mycount == MTB64_FURN_TABLE_WOOD)
	|| (mycount == MTB64_FURN_TABLE_WOOD2)
	|| (mycount == MTB64_FURN_TABLE_WOOD3)
	|| (mycount == MTB64_FURN_WORKBENCH)
	|| (mycount == MTB64_FURN_BLKSMHBELLOWS)
	|| (mycount == MTB64_FURN_BLKSMHFORGE)
	|| (mycount == MTB64_FURN_BLKSMHGRNDSTN)
	|| (mycount == MTB64_FURN_BARREL_WOOD2)
	|| (mycount == MTB64_FURN_BARREL_WOOD)
	|| (mycount == MTB64_FURN_BED_WOOD)
	|| (mycount == MTB64_FURN_CHEST_WOOD)
	|| (mycount == MTB64_FURN_CHESTLARGE_WOOD)
	|| (mycount == MTB64_FURN_EMPTYSHELF_WOOD)
	|| (mycount == MTB64_FURN_BOOKSHELF_WOOD)
	|| (mycount == MTB64_FURN_IMPALEMENTPOLE)
	|| (mycount == MTB64_CLAIMSTONE)
	|| (mycount == -601) //Plank floors
	|| (mycount == -602) //
	|| (mycount == -603) //
	|| (mycount == -604) //
	|| (mycount == -2) //Wooden japanese house //When have other wooden huts will move up to carp plus mortise
	|| (mycount == 24) //Forge bldng
	|| (mycount == 25) //Forge bldng
	|| (mycount == 26) //Forge bldng
	|| (mycount == 502) //Vineyard
	|| (mycount == 503) //Recruitment Post
	|| (mycount >= 540 && mycount <= 543) //Basic palisade
	|| (mycount >= 550 && mycount <= 559) //Berm
	) {
		//Some small stone structures too
		req_carpentry = 1;
	//StoneMasonry only
	} else if (
	(mycount >= MTB64_CURTAIN && mycount <= MTB64_CURTAIN)
	|| (mycount >= MTB64_CASTLE && mycount <= MTB64_CASTLELAST)
	|| (mycount == MTB64_CASTLESQUARE)
	|| (mycount >= MTB64_POLISH && mycount <= MTB64_POLISHLAST)
	|| (mycount >= MTB64_GRAYSTONE && mycount <= MTB64_GRAYSTONELAST)
	|| (mycount == MTB64_SANDSTONEDARK)
	|| (mycount >= MTB64_SANDSTONE && mycount <= MTB64_SANDSTONELAST)
	|| (mycount >= MTB64_MARBLEWHITE && mycount <= MTB64_MARBLEWHITELAST)
	|| (mycount == MTB64_FITTEDWINDOW_CASTLE_ALOOP)
	|| (mycount == MTB64_FITTEDWINDOW_CASTLE_SWALL)
	|| (mycount == MTB64_FURN_GREEKPILLAR)
	|| (mycount == MTB64_FURN_GREEKPILLARM)
	|| (mycount == MTB64_FURN_ROMANCOLUMN)
	|| (mycount == MTB64_FURN_ROMANCOLUMNM)
	|| (mycount >= 530 && mycount <= 539) //Brickwall
	|| (mycount >= 630 && mycount <= 639) //Foundation
	) {
		req_stonemasonry = 1;
	
	//Floor Catch All
	} else if (
	(multitool_countisfloor(mycount))
	) {
		req_carpentry = 1;
		req_mortise = 1;
		//Stone floors
		if (mycount < -620)
		{
			req_stonemasonry = 1;
		}
	
	//Future CatchAll
	} else if (mycount >= 1001 && (mycount < 10000 || mycount >= 20000))
	{
		//Utilitool stuff
		req_concrete = 1;
		
	//Medieval CatchAll
	} else {
		req_carpentry = 1;
	}

	local string mymissingannouncement;
	if (myresponse) {
		mymissingannouncement = "";
	}
	
	//Fulfillment
	if (req_carpentry && (player.knowledge_carpentry < req_carpentry))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" Carpentry",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xBA9Carpentry",mymissingannouncement);
		}
	}
	
	if (req_mortise && (player.knowledge_mortise < req_mortise))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" Mortise",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xBA9Mortise",mymissingannouncement);
		}
	}
	
	if (req_stonemasonry && (player.knowledge_stonemasonry < req_stonemasonry))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" StoneMasonry",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xBB9StoneMasonry",mymissingannouncement);
		}
	}
		
	if (req_arch && (player.knowledge_arch < req_arch))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" Arch",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xBB9Arch",mymissingannouncement);
		}
	}
	
	if (req_ironworking && (player.knowledge_ironworking < req_ironworking))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" IronWorking",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^x999IronWorking",mymissingannouncement);
		}
	}
	
	if (req_welding && (player.knowledge_welding < req_welding))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" Welding",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xCCCWelding",mymissingannouncement);
		}
	}
	
	if (req_concrete && (player.knowledge_concrete < req_concrete))
	{
		requirements_met = 0;
		if (myresponse == 2) {
			mymissingannouncement =  strcat(" Concrete",mymissingannouncement);
		} else if (myresponse == 1) {
			mymissingannouncement =  strcat(",  ^xAAAConcrete",mymissingannouncement);
		}
	}
	
	if (myresponse == 2) {
		if (!requirements_met) {
			sprint(player, strcat("^x222",mysentstring," ^xA22Missing Knowledge:^x722 ",mymissingannouncement,"^7\n"));
		} else {
			if not (autocvar_g_balance_multitoolutilitool_ignoreforgeparts) {
				mysentstring = multitool_displayforgerequirements (mycount, mysentstring);
			}
			
			sprint(player, strcat(mysentstring,"\n"));
		}
	} else if (myresponse == 1) {
		if (!requirements_met) {
			sprint(player, strcat("cannot build this (insufficent knowlege of",mymissingannouncement,"^7)\n"));
		}
	}
	
	return (requirements_met);
}

float multitool_hksprint(entity player, string mysentstring)
{
	local float hksrtrn;
	hksrtrn = multitool_hasknowledge (player, player.multitool_setting, 2, mysentstring);
	return hksrtrn;
}


void() door_go_down;
void() door_go_up;
void() door_rotating_go_down;
void() door_rotating_go_up;
//Same as normal, but different Deathtype (impale rather than crush), don't want portcullis gibbing stuff
void multitool_portcullis_door_blocked()
{

    if((self.spawnflags & 8) && (other.takedamage != DAMAGE_NO)) { // KIll Kill Kill!!
        Damage (other, self, self, 10000, DEATH_IMPALE, other.origin, '0 0 0');
    } else {

        if((self.dmg) && (other.takedamage == DAMAGE_YES))    // Shall we bite?
            Damage (other, self, self, self.dmg, DEATH_IMPALE, other.origin, '0 0 0');

         //Dont chamge direction for dead or dying stuff
        if(other.deadflag != DEAD_NO && (other.takedamage == DAMAGE_NO)) {
            if (self.wait >= 0)
            {
                if (self.state == STATE_DOWN)
			if (self.classname == "door")
			{
				door_go_up ();
			} else
			{
				door_rotating_go_up ();
			}
                else
			if (self.classname == "door")
			{
				door_go_down ();
			} else
			{
				door_rotating_go_down ();
			}
            }
        } else {
            //gib dying stuff just to make sure //(Note: won't be gibbed with impale, but not going to change the code much)
	    if(!self.nogibblocked)
            if((self.dmg) && (other.takedamage != DAMAGE_NO))    // Shall we bite?
                Damage (other, self, self, 10000, DEATH_IMPALE, other.origin, '0 0 0');
        }
    }

	//T_Damage (other, self, self, self.dmg, self.dmg, self.deathtype, DT_IMPACT, (self.absmin + self.absmax) * 0.5, '0 0 0', Obituary_Generic);
// if a door has a negative wait, it would never come back if blocked,
// so let it just squash the object to death real fast
/*	if (self.wait >= 0)
	{
		if (self.state == STATE_DOWN)
			door_go_up ();
		else
			door_go_down ();
	}
*/
}




entity multitool_spawnforgelight(vector myorigin) {
	//Returns the entity of the new forgelight
	local entity newtorchlight;
	local float trand;
	trand = random();
	newtorchlight = spawn();
	newtorchlight.pflags = PFLAGS_FULLDYNAMIC;
	newtorchlight.light_lev = 256;
	newtorchlight.color = '0.90 0.15 0'; //w_torch
	newtorchlight.color_x = newtorchlight.color_x + (0.10*(random () - 0.5));
	newtorchlight.color_y = newtorchlight.color_y + (0.15*(random () - 0.5));
	//print(vtos(newtorchlight.color),"----TorchColor\n");
	
	newtorchlight.style = 0;
		
	newtorchlight.origin = myorigin;
	setorigin(newtorchlight, newtorchlight.origin);
	return newtorchlight;
}

entity multitool_spawnironbrazierlight(vector myorigin, vector mycolor) {
	//Returns the entity of the new brazierlight
	local entity newtorchlight;
	local float trand;
	trand = random();
	newtorchlight = spawn();
	newtorchlight.pflags = PFLAGS_FULLDYNAMIC;
	newtorchlight.light_lev = 512;
	if (mycolor_x
	|| mycolor_y
	|| mycolor_z)
	{
		newtorchlight.color = mycolor;
	} else {
		newtorchlight.color = '0.90 0.50 0'; //w_torch
		newtorchlight.color_x = newtorchlight.color_x + (0.10*(random () - 0.5));
		newtorchlight.color_y = newtorchlight.color_y + (0.40*(random () - 0.5));
	}
	//print(vtos(newtorchlight.color),"----TorchColor\n");
	
	newtorchlight.style = 0;
		
	newtorchlight.origin = myorigin;
	setorigin(newtorchlight, newtorchlight.origin);
	return newtorchlight;
}

entity multitool_spawnlampstreetlight(vector myorigin, float mylightlev) {
	//Returns the entity of the new dynlight
	local entity newtorchlight;
	local float trand;
	trand = random();
	newtorchlight = spawn();
	newtorchlight.pflags = PFLAGS_FULLDYNAMIC;
	newtorchlight.light_lev = mylightlev;
	newtorchlight.color = '0.50 0.50 1'; //w_torch
	newtorchlight.color_x = newtorchlight.color_x + (0.50*(random()));
	newtorchlight.color_y = newtorchlight.color_y + (0.50*(random()));
	//print(vtos(newtorchlight.color),"----TorchColor\n");
	
	newtorchlight.style = 0;
		
	newtorchlight.origin = myorigin;
	setorigin(newtorchlight, newtorchlight.origin);
	return newtorchlight;
}

void multitool_lampstreet_think()
{
	float sufficentenergy;
	sufficentenergy = 0;
	if (self.ammount) {
	///////////////
	//We are on
	///////////////
	
	  if (teamplay)
	  {
	  	//self.ammount2 is the energy needed, it is set when this is spawned.
		//For normal shield generators it is set to 10
		if (self.subordinate4.subordinate4.team == COLOR_TEAM1) {
			if (current_energy_team1 >= self.ammount2) {
				current_energy_team1 = current_energy_team1 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM2) {
			if (current_energy_team2 >= self.ammount2) {
				current_energy_team2 = current_energy_team2 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM3) {
			if (current_energy_team3 >= self.ammount2) {
				current_energy_team3 = current_energy_team3 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM4) {
			if (current_energy_team4 >= self.ammount2) {
				current_energy_team4 = current_energy_team4 - self.ammount2;
				sufficentenergy = 1;
			}
		}
	  }

	  //Can we take from the commons?
	  if ((!sufficentenergy) && (current_energy_world >= self.ammount2)) {
		current_energy_world = current_energy_world - self.ammount2;
		sufficentenergy = 1;
	  }
	  
	  //Can we take from a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  local entity f;
	  local float usedlocalresource;
	  if ((!sufficentenergy) && (numberoflocalenergybatterys)) {
	  	//print (etos(self.subordinate4.subordinate4.realowner), "Building Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "LocalResource Owner\n");
		//print (ftos(self.subordinate4.subordinate4.team), "TEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "TEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), "Energy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.current_energy_local >= self.ammount2) {
						//print("Using\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local - self.ammount2;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficentenergy = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_energy_local >= self.ammount2) {
							//print("Found one\n");
						f.current_energy_local = f.current_energy_local - self.ammount2;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficentenergy = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("Brokeout\n\n");
		}
		//print("Did\n\n");
	  }
	
	///////////////
	//We are on^^^^
	///////////////
	}
	
	if (sufficentenergy && self.ammount) {
		//print("sufficent\n");
		self.subordinate4.light_lev = self.ammount3; //When we spawned this think, we recorded the light_lev in ammount3
	} else {
		//print("INsufficent\n");
		self.subordinate4.light_lev = 0;
	}
	
	self.nextthink = time + 60;
}

float multitool_sanitycheckcastlecolor(float mycolor)
{
	//Has to be 0 to 8, integer
	if (mycolor >= 8) {
		return 8; //Pink
	} else if (mycolor >= 7) {
		return 7; //Mauve
	} else if (mycolor >= 6) {
		return 6; //Black
	} else if (mycolor >= 5) {
		return 5; //Lighttan
	} else if (mycolor >= 4) {
		return 4; //Brown
	} else if (mycolor >= 3) {
		return 3; //Green
	} else if (mycolor >= 2) {
		return 2; //White
	} else if (mycolor >= 1) {
		return 1; //Tan
	} else {
		return 0; //Dark
	} 
}

void multitool_setstartcastlecolormaybe(entity player)
{
	if (autocvar_g_suggested_multitool_castlecolor)
	{
		if not (player.multitool_hassetatstartcastlecolor)
		{
			if (player != world) {  //We don't want to write to world
			 player.multitool_castlecolor = multitool_sanitycheckcastlecolor(autocvar_g_suggested_multitool_castlecolor);
			 player.multitool_hassetatstartcastlecolor = 1;
			}
		}
	}
}

void multitool_forcecastlecolormaybe(entity player)
{
	if (autocvar_g_suggested_multitool_castlecolor_force)
	{
		if (player != world) {  //We don't want to write to world
		 player.multitool_castlecolor = multitool_sanitycheckcastlecolor(autocvar_g_suggested_multitool_castlecolor);
		}
	}
}

float multitool_isbuildingcurtainstone(float mycount)
{
	//Simple list of buildings that use the curtain wall stone texture
	//So that we may switch out to a model that uses mudbrick
	//if we are using tan or lighttan castleblockcolor
	if ((mycount >= 560 && mycount <= 569)
	|| (mycount >= 650 && mycount <= 659)
	|| (mycount >= MTB64_CURTAIN && mycount <= MTB64_CURTAINLAST)
	|| (mycount == -1)
	|| (mycount == -5)
	|| (mycount == 1)
	|| (mycount == 2)
	|| (mycount == 3)
	|| (mycount == 4)
	|| (mycount == 5)
	|| (mycount == 9)
	|| (mycount == 13)
	|| (mycount == 14)
	|| (mycount == 15)
	|| (mycount == 16)
	|| (mycount == 19)
	|| (mycount == 23))
	{
		return TRUE;
	} else {
		return FALSE;
	}
}

float multitool_isbuildingmarbleextra(float mycount)
{
	//Simple list of otherthings that use the marble stone textures
	//So that we may switch out to a model that uses the right color
	//Will add to as more are added
	if (mycount == MTB64_FURN_GREEKPILLARM
	|| mycount == MTB64_FURN_ROMANCOLUMNM)
	{
		return TRUE;
	} else {
		return FALSE;
	}
}


float multitool_isbuildingcastlestoneextra(float mycount)
{
	//Simple list of otherthings that use the castle wall stone texture
	//So that we may switch out to a model that uses the right color
	//Will add to as more are added
	if (mycount == MTB64_FITTEDWINDOW_CASTLE_ALOOP
	|| mycount == MTB64_FITTEDWINDOW_CASTLE_SWALL
	|| mycount == 616)
	{
		return TRUE;
	} else {
		return FALSE;
	}
}

float multitool_tankcrushableextra(float mycount)
{
	//Simple extra list of buildings that are crushable by tank, not allready accounted for
	//or which are flimsy and should come down quickly vs tank
	//Barbed wire, wire fence
	if ((mycount >= 1520 && mycount <= 1529) //Fence Mil
	|| (mycount >= 520 && mycount <= 529) //Hedge
	|| (mycount >= MTB64_HEDGE && mycount <= MTB64_HEDGELAST)
	|| (mycount == MTB64U_WINDOW_FUTURE)
	|| (mycount == MTB64U_WINDOW_FUTURE_X)
	|| (mycount == MTB64U_BWIRE)
	|| (mycount == MTB64U_BWIRE_X)
	|| (mycount == MTB64U_BWIRE_O)
	|| (mycount == MTB64_BWIRE)
	|| (mycount == MTB64_DOOR_R_WOOD)
	|| (mycount == MTB64_DOOR_R_JWOOD)
	|| (mycount == MTB64_DOOR_R_FWOOD)
	|| (mycount == MTB64_DOOR_R_IRONBAR)
	|| (mycount == MTB64U_DOOR_R_PLAIN)
	|| (mycount == MTB64U_DOOR_R_PLAIN2)
	|| (mycount == MTB64U_DOOR_R_STEEL)
	|| (mycount == MTB64U_DOOR_R_GLASS)
	|| (mycount == MTB64U_FITTEDWINDOW_STEELSLIT)
	|| (mycount == MTB64U_FITTEDWINDOW_STEELPLATE) //Concrete omitted
	|| (mycount == MTB64U_FITTEDWINDOW_UWINDOW)
	|| (mycount == 503 || mycount == 1502) //Recruitment Post
	|| (mycount == MTB64_STAKES_WOOD1)
	|| (mycount == MTB64_PLATFORMWOOD_8)
	|| (mycount == MTB64_PLATFORMWOOD_24))
	{
		return TRUE;
	} else {
		return FALSE;
	}
}

void multitool_tracezspecial(vector myorigin, vector mymove, float myblocktype)
{
	local entity e;
	e = spawn();
	e.origin = myorigin;
	traceline(myorigin, myorigin + mymove, myblocktype, e);
	remove(e);
}

float multitool_findoverlappingtriggerprison (entity myself, vector mymins, vector mymaxs, vector myorigin)
{
	local entity e;
	local vector myabsmin;
	local vector myabsmax;
	
	myabsmin_x = myabsmin_x + myorigin_x;
	myabsmin_y = myabsmin_y + myorigin_y;
	myabsmin_z = myabsmin_z + myorigin_z;
	
	myabsmax_x = myabsmax_x + myorigin_x;
	myabsmax_y = myabsmax_y + myorigin_y;
	myabsmax_z = myabsmax_z + myorigin_z;
	
	//Map created prisons have classname set
	e = world;
  	for(e = findchain(classname, "trigger_prison"); e; e = e.chain)
	{
		//print("Found a trigger_prison\n");
		if (e != world) {
		if (e != myself) {			
			if(boxesoverlap(e.absmin, e.absmax, myabsmin, myabsmax))
			{
				if (e.prisonisoffurniture) {
					//Ignore
				} else {
					return 1;
				}
			}
		}
		}
	}
	
	//Multitool built ones do not
	e = world;
  	for(e = findchainfloat(prisonisfrombuilding, 1); e; e = e.chain)
	{
		//print("Found a prisonisfrombuilding\n");
		if (e != world) {
		if (e != myself) {
		if (e.prisonisfrombuilding_owner != world) {
			if(boxesoverlap(e.absmin, e.absmax, myabsmin, myabsmax))
			{
				if (e.prisonisoffurniture) {
					//A .prisonisfrombuilding won't have this set
					//but just incase...
					//Ignore
				} else {
					return 2;
				}
			} else if (e.spawnflags == 0) {
				if(boxesoverlap(e.prisonisfrombuilding_owner.absmin, e.prisonisfrombuilding_owner.absmax, myabsmin, myabsmax)) {
					if (vlen(e.prisonisfrombuilding_owner.origin - myself.origin) < 2048) {
						local vector targvec;
						local vector vecone;
						local vector vectwo;
						targvec = e.prisonisfrombuilding_owner.origin;
						targvec_z = 0;
						vecone = e.origin;
						vectwo = myself.origin;
						vecone_z = 0;
						vectwo_z = 0;
					
						//print (vtos(targvec), "___", vtos(vecone), "___", vtos(vectwo), "___", "\n");
					
						if ((vlen(targvec - vecone)) > (vlen(targvec - vectwo))) {
							//print("freeing prison found, we are closer to than it\n");
							return 2;
						}
					}
				}
			}
		}
		}
		}
	}
	
	return 0;
}	

entity multitool_findspikebldbynumbers (float mycount, float mycount2, float allfloors, float samexy, vector myorign, float myradius, float myminz, float mymaxz)
{
	local entity e;
	local float fndspkes;
	local entity ehighestz;
	fndspkes = 0;
	ehighestz = world;
	e = findradius(myorign, myradius);
	while(e)
	{
		if (e.classname == "bldhitbx") {
			if ((e.count == mycount || e.count == mycount2)
			|| (allfloors && (e.count <= -600 && e.count > -1000)))
			{
				if (e.origin_z < mymaxz)
				if (e.origin_z > myminz)
				{
				  if ((samexy && (myorign_x == e.origin_x && myorign_y == e.origin_y))
				  || !samexy)
				  { //Same tile (or anything if samexy is not set), so we can match only those in our Z column

					if (fndspkes) {
						if (e.origin_z > ehighestz.origin_z)
						{
							ehighestz = e;	
						}
					} else {
						fndspkes = 1;
						ehighestz = e;
					}
				  }
				}	
			}
		}
		e = e.chain;
	}
	
	if (fndspkes)
	{	//Yes I know we set it to world before, just being careful
		return ehighestz;
	}
	
	return world;
}

float mutitool_recruitmentpost_myselectmonster(float mytype, vector myorigin, float myradius)
{
		local entity e;	
		e = findradius(myorigin, myradius);
		while(e)
		{
			if (e.classname == "bldhitbx") {
			 //print("found class\n");
			 if (mytype == 1) {
			 	if (myradius >= 1152) {
					if (e.count == -4) {
						//Dojo
						return MULTITOOLRECRUIT_FIGHTER;
					}
				} else {
			 		//Medeval
					if (e.count == 7) {
						//Small Castle
						return MULTITOOLRECRUIT_ROYALGUARD;
					} else if (e.count == 13 || e.count == 5 || e.count == 27) {
						//Barracks, Stronghold, Crusader Stronghold
						return MULTITOOLRECRUIT_KNIGHT;
					} else if (e.count == -4) {
						//Dojo
						return MULTITOOLRECRUIT_FIGHTER;
					} else if (e.count == -3) {
						//Shrine
						return MULTITOOLRECRUIT_NINJAASSASSIN;
					}
				}
			 } else {
			 	//Futuristic
				if (e.count == 1006 || e.count == 1004) {
					//Security Building, glass base
					return UTILITOOLRECRUIT_SOLIDER;
				} 
			 }
			}
			e = e.chain;
		}
		return 0;
}

void multitool_recruitmentpost_think()
{
	self.nextthink = time + 60;
	if not (self.ammount) {
		return;
	}
	entity myoldself;
	entity mynewmonster;
	float myselectmonster;
	float neededgrain;
	float neededgreens;
	float neededgrapes;
	float neededhousing;
	float sufficentgrain;
	float sufficentgreens;
	float sufficentgrapes;
	float sufficenthousing;
	
	float tankgrainfrom; // 1,2,3,4,(teams),10000(world);
	float tankgreensfrom;
	float tankgrapesfrom;
	float tankhousingfrom;
	myselectmonster = 0;
	
	myselectmonster = mutitool_recruitmentpost_myselectmonster(self.cnt, self.origin, 256);
	if not (myselectmonster) {
		myselectmonster = mutitool_recruitmentpost_myselectmonster(self.cnt, self.origin, 512);	
	}
	if not (myselectmonster) {
		myselectmonster = mutitool_recruitmentpost_myselectmonster(self.cnt, self.origin, 1024);	
	}
	if not (myselectmonster) {
		if (self.cnt == 1) {
			//we are medieval, search for dojo stuff wider
			myselectmonster = mutitool_recruitmentpost_myselectmonster(self.cnt, self.origin, 1536);
		}	
	}
	if not (myselectmonster) {
		self.subordinate5.alpha = 0.5;
		return;
	}
	tankgrainfrom = 0;
	tankgreensfrom = 0;
	tankgrapesfrom = 0;
	tankhousingfrom = 0;
	
	neededgrain = 0;
	neededgreens = 0;
	neededgrapes = 0;
	neededhousing = 0;
	
	if (myselectmonster == MULTITOOLRECRUIT_KNIGHT) {
		//Knight, better armor, slower
		neededgrain = 10;
		neededhousing = 1;
	} else if (myselectmonster == MULTITOOLRECRUIT_ROYALGUARD) {
		//RoyalGuard lots of armor, more health, fast
		neededgrain = 20;
		neededhousing = 1;
	} else if (myselectmonster == UTILITOOLRECRUIT_SOLIDER) {
		//Futuristic Solider
		neededgreens = 10;
		neededhousing = 1;
	} else if (myselectmonster == MULTITOOLRECRUIT_FIGHTER) {
		//Fighter (sorta like a barbarian), fast, less health but lightly armored
		neededgrain = 8;
		neededhousing = 1;
	} else if (myselectmonster == MULTITOOLRECRUIT_NINJAASSASSIN) {
		//Ninja assasin lightly armored, fast
		neededgrain = 16;
		neededhousing = 1;
	}
	
	sufficentgrain = 0;
	sufficentgreens = 0;
	sufficentgrapes = 0;
	sufficenthousing = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (current_food_grain_team1 >= neededgrain) {
				tankgrainfrom = 1;
				sufficentgrain = 1;
			}
			if (current_food_greens_team1 >= neededgreens) {
				tankgreensfrom = 1;
				sufficentgreens = 1;
			}
			if (current_food_grapes_team1 >= neededgrapes) {
				tankgrapesfrom = 1;
				sufficentgrapes = 1;
			}
			//Basically reverse:housing gets filled up, not consumed
			if ((capacity_housing_team1 - current_housing_team1) >= neededhousing) {
				tankhousingfrom = 1;
				sufficenthousing = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (current_food_grain_team2 >= neededgrain) {
				tankgrainfrom = 2;
				sufficentgrain = 1;
			}
			if (current_food_greens_team2 >= neededgreens) {
				tankgreensfrom = 2;
				sufficentgreens = 1;
			}
			if (current_food_grapes_team2 >= neededgrapes) {
				tankgrapesfrom = 2;
				sufficentgrapes = 1;
			}
			//Basically reverse:housing gets filled up, not consumed
			if ((capacity_housing_team2 - current_housing_team2) >= neededhousing) {
				tankhousingfrom = 2;
				sufficenthousing = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (current_food_grain_team3 >= neededgrain) {
				tankgrainfrom = 3;
				sufficentgrain = 1;
			}
			if (current_food_greens_team1 >= neededgreens) {
				tankgreensfrom = 3;
				sufficentgreens = 1;
			}
			if (current_food_grapes_team1 >= neededgrapes) {
				tankgrapesfrom = 3;
				sufficentgrapes = 1;
			}
			//Basically reverse:housing gets filled up, not consumed
			if ((capacity_housing_team3 - current_housing_team3) >= neededhousing) {
				tankhousingfrom = 3;
				sufficenthousing = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (current_food_grain_team4 >= neededgrain) {
				tankgrainfrom = 4;
				sufficentgrain = 1;
			}
			if (current_food_greens_team1 >= neededgreens) {
				tankgreensfrom = 4;
				sufficentgreens = 1;
			}
			if (current_food_grapes_team1 >= neededgrapes) {
				tankgrapesfrom = 4;
				sufficentgrapes = 1;
			}
			//Basically reverse:housing gets filled up, not consumed
			if ((capacity_housing_team4 - current_housing_team4) >= neededhousing) {
				tankhousingfrom = 4;
				sufficenthousing = 1;
			}
		}
	} else {
		//Must build your own housing if teamplay, or capture
		//Basically reverse:housing gets filled up, not consumed
		if ((capacity_housing_world - current_housing_world) >= neededhousing) {
			tankhousingfrom = 10000;
			sufficenthousing = 1;
		}
	}

	//Can we take from the commons?
	if ((!sufficentgrain) && (current_food_grain_world >= neededgrain)) {
		tankgrainfrom = 10000;
		sufficentgrain = 1;
	}
	if ((!sufficentgreens) && (current_food_greens_world >= neededgreens)) {
		tankgreensfrom = 10000;
		sufficentgreens = 1;
	}
	if ((!sufficentgrapes) && (current_food_grapes_world >= neededgrapes)) {
		tankgrapesfrom = 10000;
		sufficentgrapes = 1;
	}
	
	if (sufficentgrain && sufficentgreens && sufficentgrapes && sufficenthousing) {
	//////
	 if (neededgrain) {
	  if (tankgrainfrom == 1) current_food_grain_team1 = current_food_grain_team1 - neededgrain;
	  else if (tankgrainfrom == 2) current_food_grain_team2 = current_food_grain_team2 - neededgrain;
	  else if (tankgrainfrom == 3) current_food_grain_team3 = current_food_grain_team3 - neededgrain;
	  else if (tankgrainfrom == 4) current_food_grain_team4 = current_food_grain_team4 - neededgrain;
	  else if (tankgrainfrom == 10000) current_food_grain_world = current_food_grain_world - neededgrain;
	 }
	 if (neededgreens) {
	  if (tankgreensfrom == 1) current_food_greens_team1 = current_food_greens_team1 - neededgreens;
	  else if (tankgreensfrom == 2) current_food_greens_team2 = current_food_greens_team2 - neededgreens;
	  else if (tankgreensfrom == 3) current_food_greens_team3 = current_food_greens_team3 - neededgreens;
	  else if (tankgreensfrom == 4) current_food_greens_team4 = current_food_greens_team4 - neededgreens;
	  else if (tankgreensfrom == 10000) current_food_greens_world = current_food_greens_world - neededgreens;
	 }
	 if (neededgrapes) {
	  if (tankgrapesfrom == 1) current_food_grapes_team1 = current_food_grapes_team1 - neededgrapes;
	  else if (tankgrapesfrom == 2) current_food_grapes_team2 = current_food_grapes_team2 - neededgrapes;
	  else if (tankgrapesfrom == 3) current_food_grapes_team3 = current_food_grapes_team3 - neededgrapes;
	  else if (tankgrapesfrom == 4) current_food_grapes_team4 = current_food_grapes_team4 - neededgrapes;
	  else if (tankgrapesfrom == 10000) current_food_grapes_world = current_food_grapes_world - neededgrapes;
	 }
	 if (neededhousing) {
	  //Basically reverse:housing gets filled up, not consumed
	  if (tankhousingfrom == 1) current_housing_team1 = current_housing_team1 + neededhousing;
	  else if (tankhousingfrom == 2) current_housing_team2 = current_housing_team2 + neededhousing;
	  else if (tankhousingfrom == 3) current_housing_team3 = current_housing_team3 + neededhousing;
	  else if (tankhousingfrom == 4) current_housing_team4 = current_housing_team4 + neededhousing;
	  else if (tankhousingfrom == 10000) current_housing_world = current_housing_world + neededhousing;
	 }
	 //Spawn soliders etc
	 
	 myoldself = self;
	 mynewmonster = spawn();
	 mynewmonster.origin = self.origin + '0 0 64';
	 mynewmonster.monster_usedhousing = neededhousing;
	 mynewmonster.monster_norespawn = 1;
	 mynewmonster.monster_keepowner = 1;
	 mynewmonster.monster_noteamcolors = 1; //so no _colormod_ (drenching in one color) on spawn (note: _not_ colormap which is shirt/pants colors, which we do below)
	 mynewmonster.monster_marshalable = 1; //We can be marshaled
	 mynewmonster.monster_nodrop = 1; //We don't wish to drop through the map...
	 mynewmonster.monster_noitemdrop = 1; //No dropping items, didn't give them to them, don't drop them, no farming monsters you yourself created
	 if (teamplay) {
	 	mynewmonster.team = self.subordinate4.team;
		mynewmonster.monster_usedhousingteam = self.subordinate4.team;
	 
	 	mynewmonster.colormap = 1024 + (self.subordinate4.team - 1) * 17;
	 } else {
	 	mynewmonster.monster_owner = self.subordinate4.realowner;
	 	
		mynewmonster.colormap = self.subordinate4.realowner.colormap;
	 }
	 
	 self = mynewmonster;
	 if (myselectmonster == MULTITOOLRECRUIT_ROYALGUARD) {
		 spawnfunc_monster_royalguard_grounded();
	 } else if (myselectmonster == MULTITOOLRECRUIT_KNIGHT) {
		 spawnfunc_monster_knight();
	 } else if (myselectmonster == UTILITOOLRECRUIT_SOLIDER) {
		 spawnfunc_monster_soldier();
	 } else if (myselectmonster == MULTITOOLRECRUIT_FIGHTER) {
		 spawnfunc_monster_fighter();
	 } else if (myselectmonster == MULTITOOLRECRUIT_NINJAASSASSIN) {
		 spawnfunc_monster_ninjaassassin();
	 }
	 
	 self = myoldself;
	//////
	}
}

void multitool_trigger_recruitmentpost_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if (other.prisonerlevel == 3 || other.handcuffed) {
		return;
	}
	
	if (!other.BUTTON_USE) {
		return;
	}
	
	if((clienttype(other) == CLIENTTYPE_REAL) || (clienttype(other) == CLIENTTYPE_BOT))
	{
	
	
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.subordinate4.ammount) {
			self.subordinate4.ammount = 0; //.think
			self.subordinate5.alpha = 0.8; //Flag
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Recruitment set to Disabled\n");	
			}		
		} else {
			self.subordinate4.ammount = 1; //.think
			self.subordinate5.alpha = 1; //Flag
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Recruitment set to Enabled\n");
			}
		}
		
		//self.subordinate is the think;
		//self.subordinate.cnt is the type (medeval or future)	
		//self.subordinate5 is the flag;
	}
}

void spawnfunc_multitool_trigger_recruitmentpost()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_recruitmentpost_touch;
}


void multitool_trigger_solarpanelcontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if (other.prisonerlevel == 3 || other.handcuffed) {
		return;
	}
	
	if (!other.BUTTON_USE) {
		return;
	}
	
	if((clienttype(other) == CLIENTTYPE_REAL) || (clienttype(other) == CLIENTTYPE_BOT))
	{
	
	
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.subordinate4.ammount) {
			self.subordinate4.ammount = 0; //.think
			self.subordinate7.solid = SOLID_NOT;
        		self.subordinate7.movetype = MOVETYPE_NONE;
			self.subordinate7.alpha = -1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				if (teamplay) {
					sprint(other, "Power distribution set to Team\n");
				} else {
					sprint(other, "Power distribution set to Global\n");
				}
				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.85, ATTN_NORM);
			}		
		} else {
			self.subordinate4.ammount = 1; //.think
			self.subordinate7.solid = SOLID_BSP;
        		self.subordinate7.movetype = MOVETYPE_PUSH;
			self.subordinate7.alpha = 1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Power distribution set to Local\n");
				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/menu2.wav", VOL_BASE * 0.85, ATTN_NORM);
			}
		}
	}
}

void spawnfunc_multitool_trigger_solarpanelcontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_solarpanelcontrol_touch;
}





void multitool_trigger_munitionsfactorycontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if (other.prisonerlevel == 3 || other.handcuffed) {
		return;
	}
	
	if (!other.BUTTON_USE) {
		return;
	}
	
	if((clienttype(other) == CLIENTTYPE_REAL) || (clienttype(other) == CLIENTTYPE_BOT))
	{
	
	
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.subordinate4.ammount) {
			self.subordinate4.ammount = 0; //.think
			self.subordinate7.solid = SOLID_NOT;
        		self.subordinate7.movetype = MOVETYPE_NONE;
			self.subordinate7.alpha = -1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				if (teamplay) {
					sprint(other, "Munitions distribution set to Team\n");
				} else {
					sprint(other, "Munitions distribution set to Global\n");
				}
				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.85, ATTN_NORM);
			}		
		} else {
			self.subordinate4.ammount = 1; //.think
			self.subordinate7.solid = SOLID_BSP;
        		self.subordinate7.movetype = MOVETYPE_PUSH;
			self.subordinate7.alpha = 1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Munitions distribution set to Local\n");
				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/menu2.wav", VOL_BASE * 0.85, ATTN_NORM);
			}
		}
	}
}

void spawnfunc_multitool_trigger_munitionsfactorycontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_munitionsfactorycontrol_touch;
}




void multitool_trigger_oilpumpcontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if(((clienttype(other) == CLIENTTYPE_REAL) && !other.BUTTON_USE)
	|| (other.prisonerlevel == 3 || other.handcuffed)) {
		return;
	}
		local entity e;
		
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.ammount) {
			self.ammount = 0;
			
			self.subordinate7.solid = SOLID_NOT;
        		self.subordinate7.movetype = MOVETYPE_NONE;
			self.subordinate7.alpha = -1; //Lock model
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				if (teamplay) {
					sprint(other, "Oil distribution set to Team\n");
				} else {
					sprint(other, "Oil distribution set to Global\n");
				}
				
				spamsound (self.subordinate5, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.85, ATTN_NORM);

			}			
		} else {
			self.ammount = 1;
			
			self.subordinate7.solid = SOLID_BSP;
        		self.subordinate7.movetype = MOVETYPE_PUSH;
			self.subordinate7.alpha = 1; //Lock model
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Oil distribution set to Local\n");
				
				spamsound (self.subordinate5, CH_SHOTS, "misc/menu2.wav", VOL_BASE * 0.85, ATTN_NORM);

			}					
		}
						
		e = findradius(self.origin, 4096);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				if (e.count == 1015) {
					//print(etos(e.owner.subordinate.subordinate), " -s2\n");
					//print(etos(e.owner.subordinate.subordinate.subordinate), " -s3\n");
					if (e.owner.subordinate.subordinate)
					if (e.owner.subordinate.subordinate != world) {
						e.owner.subordinate.subordinate.ammount = self.ammount;
					}
				}
			}
			e = e.chain;
		}
}
		
void spawnfunc_multitool_trigger_oilpumpcontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_oilpumpcontrol_touch;
}


void multitool_trigger_chemicalcontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if(((clienttype(other) == CLIENTTYPE_REAL) && !other.BUTTON_USE)
	|| (other.prisonerlevel == 3 || other.handcuffed)) {
		return;
	}
		local entity e;
		
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.ammount) {
			self.ammount = 0;
			
			self.subordinate7.solid = SOLID_NOT;
        		self.subordinate7.movetype = MOVETYPE_NONE;
			self.subordinate7.alpha = -1; //Lock model
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				if (teamplay) {
					sprint(other, "Oil distribution set to Team\n");
				} else {
					sprint(other, "Oil distribution set to Global\n");
				}
				
				spamsound (self.subordinate5, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.85, ATTN_NORM);

			}			
		} else {
			self.ammount = 1;
			
			self.subordinate7.solid = SOLID_BSP;
        		self.subordinate7.movetype = MOVETYPE_PUSH;
			self.subordinate7.alpha = 1; //Lock model
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Oil distribution set to Local\n");
				
				spamsound (self.subordinate5, CH_SHOTS, "misc/menu2.wav", VOL_BASE * 0.85, ATTN_NORM);

			}					
		}
						
		e = findradius(self.origin, 4096);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				if (e.count == 1016 || e.count == 1017 || e.count == 1018) {
					//print(etos(e.owner.subordinate.subordinate), " -s2\n");
					//print(etos(e.owner.subordinate.subordinate.subordinate), " -s3\n");
					if (e.owner.subordinate.subordinate)
					if (e.owner.subordinate.subordinate != world) {
						e.owner.subordinate.subordinate.ammount = self.ammount;
					}
				}
			}
			e = e.chain;
		}
}
		
void spawnfunc_multitool_trigger_chemicalcontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_chemicalcontrol_touch;
}



void multitool_trigger_shieldcontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if (other.prisonerlevel == 3 || other.handcuffed) {
		return;
	}
	
	if (!other.BUTTON_USE) {
		return;
	}
	
	if((clienttype(other) == CLIENTTYPE_REAL) || (clienttype(other) == CLIENTTYPE_BOT))
	{
	
	
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.subordinate4.ammount) {
			self.subordinate4.ammount = 0; //.think
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Shield set to Disabled\n");	
			}		
		} else {
			self.subordinate4.ammount = 1; //.think
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Shield set to Enabled\n");
			}
		}
	}
}

void spawnfunc_multitool_trigger_shieldcontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_shieldcontrol_touch;
}


void multitool_trigger_bridgecontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if(((clienttype(other) == CLIENTTYPE_REAL) && !other.BUTTON_USE)
	|| (other.prisonerlevel == 3 || other.handcuffed)) {
		return;
	}
		local entity e;
		
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.ammount) {
			self.ammount = 0;
			sprint(other, "Shield Bridges set to Disable\n");			
		} else {
			self.ammount = 1;
			sprint(other, "Shield Bridges set to Enable\n");					
		}
						
		e = findradius(self.origin, 4096);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				if (e.count == 1652) {
					if (e.owner.subordinate.subordinate.subordinate)
					if (e.owner.subordinate.subordinate.subordinate != world) {
						e.owner.subordinate.subordinate.subordinate.ammount = self.ammount;
						if (e.owner.subordinate.subordinate.subordinate.nextthink > (time+3)) {
							e.owner.subordinate.subordinate.subordinate.nextthink = time + 3;
						}
					}
				}
			}
			e = e.chain;
		}
}
		
void spawnfunc_multitool_trigger_bridgecontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_bridgecontrol_touch;
}

void multitool_trigger_bellows_trace4fire(entity ent, entity myowner, vector originoffset)
{
	//print (etos(myowner), "ownr\n");
	tracebox(ent.origin + originoffset, ent.mins, ent.maxs, ent.origin + ('0 0 1' * 128), MOVE_NORMAL, ent);
	
	if (trace_ent)
	if (trace_ent != world)
	if (isPlayerOrMonsterByClassname(trace_ent)) {
		Fire_AddDamage(trace_ent, myowner, autocvar_g_balance_torch_fire_damage * autocvar_g_balance_torch_fire_burntime, autocvar_g_balance_torch_fire_burntime, WEP_TORCH | HITTYPE_SECONDARY);
		return;
	}
	
	//print(vtos(ent.origin + originoffset),"...",etos(trace_ent), "::Tracent", trace_ent.model, "-model\n");
	
	if (trace_ent)
	if (trace_ent != world)
	if (trace_ent.classname == "building")
	if (trace_ent.multitool_hitbox)
	if (trace_ent.multitool_hitbox != world)
	if (trace_ent.multitool_hitbox.classname == "bldhitbx")
	if (multitool_iswooden(trace_ent.multitool_hitbox.count)) {
		//print ("setting burn\n");
		Fire_AddDamage(trace_ent.multitool_hitbox, myowner, autocvar_g_balance_torch_fire_damage * autocvar_g_balance_torch_fire_burntime, autocvar_g_balance_torch_fire_burntime, WEP_TORCH | HITTYPE_SECONDARY);
	}
}

void multitool_trigger_bellows_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if(((clienttype(other) == CLIENTTYPE_REAL) && !other.BUTTON_USE)
	|| (other.prisonerlevel == 3 || other.handcuffed)) {
		return;
	}
		local entity e;
		
		self.pushltime = time + 0.5;
						
		e = findradius(self.origin, 64);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				////Blacksmith forge, or the building forge or the building rocket forge (not the cells one tho)
				if (e.count == MTB64_FURN_BLKSMHFORGE
				|| e.count == 24
				|| e.count == 25) {
					if (e.count == MTB64_FURN_BLKSMHFORGE) {
						if (e.owner.subordinate4)
						if (e.owner.subordinate4 != world) {
							Fire_AddDamage(e.owner.subordinate4, self.realowner, autocvar_g_balance_torch_fire_damage * autocvar_g_balance_torch_fire_burntime, autocvar_g_balance_torch_fire_burntime, WEP_TORCH | HITTYPE_SECONDARY);
							multitool_trigger_bellows_trace4fire(e.owner.subordinate4, other, '0 0 0');
						}
					} else {
						//subordinate.subordinate.subordinate.subordinate here is the burining/coals 
						if (e.owner.subordinate.subordinate.subordinate.subordinate)
						if (e.owner.subordinate.subordinate.subordinate.subordinate != world)
						if (e.owner.subordinate.subordinate.subordinate.subordinate.alpha != -1) {
							//Tell the think that someone has been blowing the bellows:
							e.owner.subordinate.subordinate.ammount3 = e.owner.subordinate.subordinate.ammount3 + 1;
							
							//Show off, need to for this one for somereason
							pointparticles(particleeffectnum("EF_FLAME"), e.owner.subordinate.subordinate.subordinate.subordinate.origin, '0 0 0', 1);
							
							Fire_AddDamage(e.owner.subordinate.subordinate.subordinate.subordinate, self.realowner, autocvar_g_balance_torch_fire_damage * autocvar_g_balance_torch_fire_burntime, autocvar_g_balance_torch_fire_burntime, WEP_TORCH | HITTYPE_SECONDARY);
							multitool_trigger_bellows_trace4fire(e.owner.subordinate.subordinate.subordinate.subordinate, other, '0 0 32');
						}
					}
				}
			}
			e = e.chain;
		}
}

void spawnfunc_multitool_trigger_bellows()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_bellows_touch;
}

void multitool_forge_think()
{
	self.nextthink = time + 0.90 + (random()*0.25);
	if (self.subordinate4)
	if (self.subordinate4 != world) {
		if (self.subordinate4.fire_endtime) {
			self.subordinate4.fire_endtime = time;
		}
	}
}


void multitool_trigger_hurt_touch_impale()
{
	if (self.active != ACTIVE_ACTIVE) 
		return;

	if(self.team)
		if((self.spawnflags & 4 == 0) == (self.team != other.team))
			return;

	// only do the EXACTTRIGGER_TOUCH checks when really needed (saves some cpu)
	if (other.iscreature)
	{
		if (other.takedamage)
		if (other.triggerhurttime < time)
		{
			EXACTTRIGGER_TOUCH;
			other.triggerhurttime = time + 1;

			entity own;
			own = self.enemy;
			if(own.classname != "player")
			{
				own = self;
				self.enemy = world; // I still hate you all
			}

			Damage (other, self, own, self.dmg, DEATH_IMPALE, other.origin, '0 0 0');
		}
	}
	else if(other.damagedbytriggers)
	{
		if(other.takedamage)
		{
			EXACTTRIGGER_TOUCH;
			Damage(other, self, self, self.dmg, DEATH_IMPALE, other.origin, '0 0 0');
		}
	}
	else
	{
		if (!other.owner)
		{
			if (other.classname == "rune")			// reset runes
			{
				EXACTTRIGGER_TOUCH;
				other.nextthink = min(other.nextthink, time + 1);
			}
		}
	}

	return;
}


void multitool_trigger_hurt_touch_cut()
{
	if (self.active != ACTIVE_ACTIVE) 
		return;

	if(self.team)
		if((self.spawnflags & 4 == 0) == (self.team != other.team))
			return;

	// only do the EXACTTRIGGER_TOUCH checks when really needed (saves some cpu)
	if (other.iscreature)
	{
		if (other.takedamage)
		if (other.triggerhurttime < time)
		{
			EXACTTRIGGER_TOUCH;
			other.triggerhurttime = time + 1;

			entity own;
			own = self.enemy;
			if(own.classname != "player")
			{
				own = self;
				self.enemy = world; // I still hate you all
			}

			Damage (other, self, own, self.dmg, DEATH_CUT, other.origin, '0 0 0');
		}
	}
	else if(other.damagedbytriggers)
	{
		if(other.takedamage)
		{
			EXACTTRIGGER_TOUCH;
			Damage(other, self, self, self.dmg, DEATH_CUT, other.origin, '0 0 0');
		}
	}
	else
	{
		if (!other.owner)
		{
			if (other.classname == "rune")			// reset runes
			{
				EXACTTRIGGER_TOUCH;
				other.nextthink = min(other.nextthink, time + 1);
			}
		}
	}

	return;
}


void multitool_dropflagbase(vector sorigin, float sradius);

void multitool_flagdropper_think()
{
	multitool_dropflagbase(self.origin, 128);
	remove(self);
}

void remove_mtextrasafely(entity rmv)
{
	//This removes things safely, and checks if there is a flagbase that needs to be 
	//dropped from it's now non-existant perch.
	entity mtfldrop;
	if (rmv.multitool_iscontrolpoint)
	{
		//print("found, dropping flagbase\n");
		//Rather than doing it here, we have to do it later
		//Has to be done this way, otherwise nuke doesn't destroy most things for some reason
		//Probably has to do with .chain interference if we do a while loop. but who knows
		//An important rule in quakec: if what you're doing isnt working for some unknown
		//reason, spawn an entity and do it in a think next frame or so.
		mtfldrop = spawn();
		mtfldrop = mtfldrop;
		mtfldrop.think = multitool_flagdropper_think;
		mtfldrop.nextthink = time + 3;
		mtfldrop.origin = rmv.origin;
		setorigin(mtfldrop, mtfldrop.origin);
	}
	remove_safely(rmv);
}

void droptenthousandworldonly(entity moveme)
{
	traceline(moveme.origin + '2 0 0', moveme.origin - '0 0 10000', MOVE_WORLDONLY, moveme);
	moveme.origin = trace_endpos;
	moveme.origin_z = moveme.origin_z + 42;
	setorigin(moveme, moveme.origin);
}

float multitool_countisfloor (float mycount)
{	
	if ((mycount < -600) && (mycount > -800)) {
		//Count is a floor suitable for locking rotation
		return(TRUE);
	} else {
		return(FALSE);
	}
}

void multitool_meleethink (float wmelee_time, float wmelee_range, float wprimary_damage, float wmelee_nonplayerdamage)
{
	// declarations
	float i, f, swing, swing_factor, swing_damage, meleetime, is_player;
	entity target_victim;
	vector targpos;

	if(!self.cnt) // set start time of melee
	{
		self.cnt = time; 
		W_PlayStrengthSound(self.realowner);
	}

	makevectors(self.realowner.v_angle); // update values for v_* vectors
	
	// calculate swing percentage based on time
	meleetime = wmelee_time * W_WeaponRateFactor();
	swing = bound(0, (self.cnt + meleetime - time) / meleetime, 10);
	f = ((1 - swing) * autocvar_g_balance_multitool_primary_melee_traces);
	
	// check to see if we can still continue, otherwise give up now
	if((self.realowner.deadflag != DEAD_NO) && autocvar_g_balance_multitool_primary_melee_no_doubleslap)
	{
		remove(self);
		return;
	}
	
	// if okay, perform the traces needed for this frame 
	for(i=self.swing_prev; i < f; ++i)
	{
		swing_factor = ((1 - (i / autocvar_g_balance_multitool_primary_melee_traces)) * 2 - 1);
		
		targpos = (self.realowner.origin + self.realowner.view_ofs 
			+ (v_forward * wmelee_range)
			+ (v_up * swing_factor * autocvar_g_balance_multitool_primary_melee_swing_up)
			+ (v_right * swing_factor * autocvar_g_balance_multitool_primary_melee_swing_side));

		WarpZone_traceline_antilag(self, self.realowner.origin + self.realowner.view_ofs, targpos, FALSE, self, ANTILAG_LATENCY(self.realowner));
		
		// draw lightning beams for debugging
		//te_lightning2(world, targpos, self.realowner.origin + self.realowner.view_ofs + v_forward * 5 - v_up * 5); 
		//te_customflash(targpos, 40,  2, '1 1 1');
		
		is_player = (trace_ent.classname == "player" || trace_ent.classname == "body");

		if((trace_fraction < 1) // if trace is good, apply the damage and remove self
			&& (trace_ent.takedamage == DAMAGE_AIM)  
			&& (trace_ent != self.swing_alreadyhit)
			&& (is_player || wmelee_nonplayerdamage))
		{
			target_victim = trace_ent; // so it persists through other calls
			
			if(is_player) // this allows us to be able to nerf the non-player damage done in e.g. assault or onslaught.
				swing_damage = (wprimary_damage * min(1, swing_factor + 1));
			else
				swing_damage = (wmelee_nonplayerdamage * min(1, swing_factor + 1));
			
			//print(strcat(self.realowner.netname, " hitting ", target_victim.netname, " with ", strcat(ftos(swing_damage), " damage (factor: ", ftos(swing_factor), ") at "), ftos(time), " seconds.\n"));
			
			if (is_player) {
				swing_damage = W_CritHitCalc_Blunt(swing_damage, self.realowner.origin + self.realowner.view_ofs, targpos, target_victim, self.realowner, WEP_MULTITOOL);
			}
			
				Damage(target_victim, self.realowner, self.realowner, 
				swing_damage, WEP_MULTITOOL, 
				self.realowner.origin + self.realowner.view_ofs, 
				v_forward * autocvar_g_balance_multitool_primary_force);
			
			if(accuracy_isgooddamage(self.realowner, target_victim)) { accuracy_add(self.realowner, WEP_MULTITOOL, 0, swing_damage); }
				
			// draw large red flash for debugging
			//te_customflash(targpos, 200, 2, '15 0 0');
			
			if(autocvar_g_balance_multitool_primary_melee_multihit) // allow multiple hits with one swing, but not against the same player twice.
			{
				self.swing_alreadyhit = target_victim;
				continue; // move along to next trace
			}
			else
			{
				remove(self);
				return;
			}
		}
	}
	
	if(time >= self.cnt + meleetime)
	{
		// melee is finished
		remove(self);
		return;
	}
	else
	{
		// set up next frame 
		self.swing_prev = i;
		self.nextthink = time;
	}
}

void multitool_primarythink (void)
{
	multitool_meleethink(
		autocvar_g_balance_multitool_primary_melee_time,
		autocvar_g_balance_multitool_primary_melee_range,
		autocvar_g_balance_multitool_primary_damage,
		autocvar_g_balance_multitool_primary_melee_nonplayerdamage
		);
}

void W_MultiTool_Attack (void)
{
	sound (self, CH_WEAPON_A, "weapons/shotgun_melee.wav", VOL_BASE, ATTN_NORM);
	weapon_thinkf(WFRAME_FIRE2, autocvar_g_balance_multitool_primary_animtime, w_ready);

	entity meleetemp;
	meleetemp = spawn();
	meleetemp.realowner = self;
	meleetemp.think = multitool_primarythink;
	meleetemp.nextthink = time + autocvar_g_balance_multitool_primary_melee_delay * W_WeaponRateFactor();
	W_SetupShot_Range(self, TRUE, 0, "", 0, autocvar_g_balance_multitool_primary_damage, autocvar_g_balance_multitool_primary_melee_range);
}

.float multitool_primarytime;
// end weapon frames

void multitool_dropflagbase(vector sorigin, float sradius)
{
	//ex: multitool_dropflagbase(fbsorg, fbsrad);
	//ftarg_z = ftarg_z + 42;
	if (teamplay) {
		entity f;
		f = findradius(sorigin, sradius);
  		while(f)
  		{
			if (f.classname == "item_flag_team_base")
			{
				droptenthousandworldonly(f);
				f.ctf_spawnorigin = f.origin;
			}
			else if (f.classname == "item_flag_team")
			{
				droptenthousandworldonly(f);
				f.ctf_spawnorigin = f.origin ;
			}
	    		f = f.chain;	
		}	
	}
}

void multitool_moveflagbase(vector ftarg, vector sorigin, float sradius)
{
	//ftarg == where to move to, sorigin = origin of search, sradius = radius to search in.
	//ex: multitool_moveflagbase(fbspot, fbsorg, fbsrad);
	ftarg_z = ftarg_z + 42;
	if (teamplay) {
		entity f;
		f = findradius(sorigin, sradius);
  		while(f)
  		{
			if (f.classname == "item_flag_team_base")
			{
				f.origin = ftarg;
				f.ctf_spawnorigin = ftarg;
				setorigin(f, f.origin);
			}
			else if (f.classname == "item_flag_team")
			{
				f.origin = ftarg;
				f.ctf_spawnorigin = ftarg;
				setorigin(f, f.origin);
			}
	    		f = f.chain;	
		}	
	}
}


float multitool_setcrusaderstrongholdbannermodels(entity bnnr1, entity bnnr2, entity player, float dotheprecache, float doinganupdate)
{	
	entity newbnnr1;
	entity newbnnr2;
	if (bnnr1 == world || bnnr2 == world || player == world)
		return 0;
		
	if (bnnr1.flags & FL_MONSTER || bnnr2.flags & FL_MONSTER)
		return 0;
		
	if (bnnr1.flags & FL_PROJECTILE || bnnr2.flags & FL_PROJECTILE)
		return 0;
		
	if (bnnr1.health || bnnr2.health)
		return 0;
	
	if (bnnr1.vehicle_flags & VHF_ISVEHICLE || bnnr2.vehicle_flags & VHF_ISVEHICLE)
		return 0;
		
	if (bnnr1.vehicle_health || bnnr2.vehicle_health)
		return 0;
		
	if (bnnr1.tur_health || bnnr2.tur_health)
		return 0;
		
	//print(etos(bnnr1), " Banner 1 Current model to be changed:", bnnr1.model,"\n");
	//print(etos(bnnr2), " Banner 2 Current model to be changed:", bnnr2.model,"\n");	
	//print(etos(player), " Player netname:", player.netname,"\n");
	
	
	local float my_sclr;
	local float my_pclr;
	
	my_sclr = floor(player.clientcolors / 16); //Shirt
	my_pclr = mod(player.clientcolors, 16); //Pants
	
	if (doinganupdate) {
		if (bnnr1.cnt == my_sclr
		&& bnnr2.cnt == my_pclr) {
			//print("Multitool Banner: No change needed\n");
			return 0;
		}
	}
	
	if (teamplay) {
		if (player.team == COLOR_TEAM1) {
			my_sclr = my_pclr  = 4;
		} else if (player.team == COLOR_TEAM2) {
			my_sclr = my_pclr  = 11;
		} else if (player.team == COLOR_TEAM3) {
			my_sclr = my_pclr  = 12;
		} else if (player.team == COLOR_TEAM4) {
			my_sclr = my_pclr  = 10;
		}
	} 
	
	
	bnnr1.cnt = my_sclr;
	bnnr2.cnt = my_pclr;
	
	switch(my_sclr)
	{	
		case  0:
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_whitemisc.bsp";
			break; //White
		case  1: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_orange2.bsp";
			break; //Orange
		case  2: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_cyan.bsp";
			break; //Seabreeze
		case  3: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_green.bsp";
			break; //green
		case  4: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_red.bsp";
			break; //red
		case  5: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_blue2.bsp";
			break; //light blue
		case  6: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_cyan.bsp";
			break; //cyan
		case  7: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_green.bsp";
			break; //light green / neon green /slime
		case  8: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_purple.bsp";
			break; //purple
		case  9: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_purple2.bsp";
			break; //magenta
		case 10: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_rose.bsp";
			break; //rose
		case 11: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_blue.bsp";
			break; //blue
		case 12: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_yellow.bsp";
			break; //yellow
		case 13: 
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_blue.bsp";
			break; //sorta light blue
		case 14:
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_orange.bsp";
			break; //Orange
		default:
		case 15:
			bnnr1.model = "maps/buildables/building_crusaderstronghold_banners_colormap.bsp";
			bnnr1.colormap = player.colormap;
			break;
	}
	
	
	switch(my_pclr)
	{	
		default:
		case  0:
		case  4:
		case 10:
			bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_white.bsp";
			break; //White /red/crusader
		case  2:
		case  5:
		case  6: 
			bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_whitecyanblue.bsp";
			break; //cyan
		case 11: 
			if (my_sclr == 5 || my_sclr == 11) {
				bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_bluewhite.bsp";
			} else {
				bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_bluepurple.bsp";
			}
			break; //blue
		case  3:
		case 12: 
			bnnr2.model = "maps/buildables/building_crusaderstronghold_banners_whiteyellowall.bsp";
			break; //yellow
		case 13: 
			bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_bluewhite.bsp";
			break; //sorta light blue
		case  1:
		case 14:
			bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_whiteorangemisc.bsp";
			break; //Orange
		case  7:
		case  8:
		case  9:
		case 15:
			bnnr2.model = "maps/buildables/building_crusaderstronghold_altbanners_whitemisc.bsp";
			break;
	}
	
			
	if (dotheprecache) {
		precache_model(bnnr1.model);
		precache_model(bnnr2.model);
	}
	
	return 1;
}



//oldself.owner = ent1; self = flag
void multitool_flag_colors(entity flag, entity ent1)
{
	if (teamplay) {
		flag.team = ent1.team;
		if (ent1.team == COLOR_TEAM1) {
			flag.skin = 1;
		} else if (ent1.team == COLOR_TEAM2) {
			flag.skin = 2;
		} else if (ent1.team == COLOR_TEAM3) {
			flag.skin = 3;
		} else if (ent1.team == COLOR_TEAM4) {
			flag.skin = 4;
		} else {
			flag.skin = 0;
			flag.colormap = 1024 + (ent1.team - 1) * 17;
		}
	} else {
		flag.skin = 0;
		flag.colormap = ent1.colormap;
	}
}

float multitool_capturetooclose(entity player, entity targ, entity cpoint)
{
	if (targ.multitool_hitbox.count == 4
	|| targ.multitool_hitbox.count == 5
	|| targ.multitool_hitbox.count == 6
	|| targ.multitool_hitbox.count == 7
	|| targ.multitool_hitbox.count == 9
	|| targ.multitool_hitbox.count == 27
	|| targ.multitool_hitbox.count == 1001)
	{
		//Garrisons and other bases don't have the restriction
		return FALSE;
	}
	
	entity f;
	f = findradius(player.origin, autocvar_g_balance_multitool_maxradiusbase);
  	while(f)
  	{
		if (f.classname == "bldhitbx")
		{
			//These buildings can help hold land
			if (f.count == 4
			|| f.count == 5
			|| f.count == 6
			|| f.count == 7
			|| f.count == 9
			|| f.count == 27
			|| f.count == 1001)
			{
				//print(ftos(player.team), "team\n");
    				if (teamplay) {
					if (player.team != f.team) {
						if not(multitool_controlpointencased(f)) {
							//print(ftos(f.team), "fteam\n");
							if((cpoint.pushltime + 1) < time)  // prevent flooding message
							{
								sprint(player, "Too close to enemy team's garrison, stronghold, strongtower, townhall, or castle\n");
								cpoint.pushltime = time + 2;
							}
							return TRUE;
						}
					}
				} else if (player != f.realowner) {
					if not(multitool_controlpointencased(f)) {
						if((cpoint.pushltime + 1) < time)  // prevent flooding message
						{
							sprint(player, "Too close to another player's garrison, stronghold, strongtower, townhall, or castle\n");
							cpoint.pushltime = time + 2;
						}
						return TRUE;
					}
				}
			}
		}
    		f = f.chain;
  	}
	
	if (teamplay)
	{
		f = findradius(player.origin, autocvar_g_balance_multitool_minradiusflag);
  		while(f)
  		{
			if (f.classname == "item_flag_team_base"
			|| f.classname == "onslaught_generator")
			{
				if (player.team != f.team) {
					if((cpoint.pushltime + 1) < time)  // prevent flooding message
					{
						sprint(player, "Too close to enemy team's flag\n");
						cpoint.pushltime = time + 2;
					}
					return TRUE;
				}	
			}
	    		f = f.chain;	
		}
	}

	return FALSE;
}

float multitool_getmyhousingamnt (float mycount)
{	
	//Returns 0 if not, so can be used to test if even housing.
	if (mycount == MTB64_FURN_BED_WOOD
	|| mycount == MTB64U_FURN_BED
	|| mycount == MTB64U_FURN_BED_FOAM
	|| mycount == MTB64U_FURN_FUTON) {
		return HSNG_BED_CAPACITY;
	} else if (mycount == 19 || mycount == 1003) {
		return HSNG_HOUSE_CAPACITY;
	} else if (mycount == -2) {
		return HSNG_JHOUSE_CAPACITY;
	} else if (mycount == 1012) {
		return HSNG_APART_CAPACITY;
	} else if (mycount == 5) {
		return HSNG_STRNGHLD_CAPACITY;
	} else if (mycount == 13) {
		return HSNG_BARRACKS_CAPACITY;
	} else if (mycount == 11 || mycount == 17
		|| mycount == 18) {
		return HSNG_MANSE_CAPACITY;
	} else {
		return 0;
	}
}

void multitool_addinithousingcapacity (entity myself, float myhousing)
{
		if (teamplay)
		{
			if (myself.team == COLOR_TEAM1) {
				capacity_housing_team1 = capacity_housing_team1 + myhousing;
			} else if (myself.team == COLOR_TEAM2) {
				capacity_housing_team2 = capacity_housing_team2 + myhousing;
			} else if (myself.team == COLOR_TEAM3) {
				capacity_housing_team3 = capacity_housing_team3 + myhousing;
			} else if (myself.team == COLOR_TEAM4) {
				capacity_housing_team4 = capacity_housing_team4 + myhousing;
			} else {
				capacity_housing_world = capacity_housing_world + myhousing;
			}
		} else {
			capacity_housing_world = capacity_housing_world + myhousing;
		}
}

void multitool_housing_change(entity targ)
{
	local float myhousing;
	myhousing = multitool_getmyhousingamnt(targ.multitool_hitbox.count);
	//if (targ.multitool_hitbox.count == 1011) { //Old way
	if(myhousing) {		
		//Housing
		entity t1;
		if (teamplay) {
			t1 = targ.subordinate;
			//print(ftos(t1.team), " old team\n");
			//print(ftos(other.team), " new team\n");

			//Remove energy and capacity from old team
			if (t1.team == COLOR_TEAM1) {
				//if (current_housing_team1) {
				//	current_housing_team1 = current_housing_team1 - (current_housing_team1*(myhousing/capacity_housing_team1));
				//}
				capacity_housing_team1 = capacity_housing_team1 - myhousing;
			} else if (t1.team == COLOR_TEAM2) {
				//if (current_housing_team2) {
				//	current_housing_team2 = current_housing_team2 - (current_housing_team2*(myhousing/capacity_housing_team2));
				//}
				capacity_housing_team2 = capacity_housing_team2 - myhousing;
			} else if (t1.team == COLOR_TEAM3) {
				//if (current_housing_team3) {
				//	current_housing_team3 = current_housing_team3 - (current_housing_team3*(myhousing/capacity_housing_team3));
				//}
				capacity_housing_team3 = capacity_housing_team3 - myhousing;
			} else if (t1.team == COLOR_TEAM4) {
				//if (current_housing_team4) {
				//	current_housing_team4 = current_housing_team4 - (current_housing_team4*(myhousing/capacity_housing_team4));
				//}
				capacity_housing_team4 = capacity_housing_team4 - myhousing;
			}
			
			//Add capacity only to new team
			if (other.team == COLOR_TEAM1) {
				capacity_housing_team1 = capacity_housing_team1 + myhousing;
			} else if (other.team == COLOR_TEAM2) {
				capacity_housing_team2 = capacity_housing_team2 + myhousing;
			} else if (other.team == COLOR_TEAM3) {
				capacity_housing_team3 = capacity_housing_team3 + myhousing;
			} else if (other.team == COLOR_TEAM4) {
				capacity_housing_team4 = capacity_housing_team4 + myhousing;
			}
		}
	}
}

void multitool_oiltank_change(entity targ)
{
	if (targ.multitool_hitbox.count == 1010) {
		//Oil Tank
		entity t1;
		if (teamplay) {
			t1 = targ.subordinate;
			//print(ftos(t1.team), " old team\n");
			//print(ftos(other.team), " new team\n");

			//Remove crude and capacity from old team
			if (t1.team == COLOR_TEAM1) {
				if (current_crude_team1) {
					current_crude_team1 = current_crude_team1 - (current_crude_team1*(OIL_TANK_CAPACITY/capacity_crude_team1));
				}
				capacity_crude_team1 = capacity_crude_team1 - OIL_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM2) {
				if (current_crude_team2) {
					current_crude_team2 = current_crude_team2 - (current_crude_team2*(OIL_TANK_CAPACITY/capacity_crude_team2));
				}
				capacity_crude_team2 = capacity_crude_team2 - OIL_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM3) {
				if (current_crude_team3) {
					current_crude_team3 = current_crude_team3 - (current_crude_team3*(OIL_TANK_CAPACITY/capacity_crude_team3));
				}
				capacity_crude_team3 = capacity_crude_team3 - OIL_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM4) {
				if (current_crude_team4) {
					current_crude_team4 = current_crude_team4 - (current_crude_team4*(OIL_TANK_CAPACITY/capacity_crude_team4));
				}
				capacity_crude_team4 = capacity_crude_team4 - OIL_TANK_CAPACITY;
			}
			
			//Add capacity only to new team
			if (other.team == COLOR_TEAM1) {
				capacity_crude_team1 = capacity_crude_team1 + OIL_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM2) {
				capacity_crude_team2 = capacity_crude_team2 + OIL_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM3) {
				capacity_crude_team3 = capacity_crude_team3 + OIL_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM4) {
				capacity_crude_team4 = capacity_crude_team4 + OIL_TANK_CAPACITY;
			}
		}
	}
	
	if (targ.multitool_hitbox.count == 1011) {
		//Energy Tank
		entity t1;
		if (teamplay) {
			t1 = targ.subordinate;
			//print(ftos(t1.team), " old team\n");
			//print(ftos(other.team), " new team\n");

			//Remove energy and capacity from old team
			if (t1.team == COLOR_TEAM1) {
				if (current_energy_team1) {
					current_energy_team1 = current_energy_team1 - (current_energy_team1*(ENERGY_TANK_CAPACITY/capacity_energy_team1));
				}
				capacity_energy_team1 = capacity_energy_team1 - ENERGY_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM2) {
				if (current_energy_team2) {
					current_energy_team2 = current_energy_team2 - (current_energy_team2*(ENERGY_TANK_CAPACITY/capacity_energy_team2));
				}
				capacity_energy_team2 = capacity_energy_team2 - ENERGY_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM3) {
				if (current_energy_team3) {
					current_energy_team3 = current_energy_team3 - (current_energy_team3*(ENERGY_TANK_CAPACITY/capacity_energy_team3));
				}
				capacity_energy_team3 = capacity_energy_team3 - ENERGY_TANK_CAPACITY;
			} else if (t1.team == COLOR_TEAM4) {
				if (current_energy_team4) {
					current_energy_team4 = current_energy_team4 - (current_energy_team4*(ENERGY_TANK_CAPACITY/capacity_energy_team4));
				}
				capacity_energy_team4 = capacity_energy_team4 - ENERGY_TANK_CAPACITY;
			}
			
			//Add capacity only to new team
			if (other.team == COLOR_TEAM1) {
				capacity_energy_team1 = capacity_energy_team1 + ENERGY_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM2) {
				capacity_energy_team2 = capacity_energy_team2 + ENERGY_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM3) {
				capacity_energy_team3 = capacity_energy_team3 + ENERGY_TANK_CAPACITY;
			} else if (other.team == COLOR_TEAM4) {
				capacity_energy_team4 = capacity_energy_team4 + ENERGY_TANK_CAPACITY;
			}
		}
	}
}

void multitool_controlpoint_change(entity targ)
{
	//print(etos(targ)," targ\n");
	//print(etos(targ.multitool_hitbox)," hitbox\n");
	if (targ.multitool_hitbox.count == -4
	|| targ.multitool_hitbox.count == -5
	|| targ.multitool_hitbox.count == -3
	|| targ.multitool_hitbox.count == -2
	|| targ.multitool_hitbox.count == 9
	|| targ.multitool_hitbox.count == 11
	|| targ.multitool_hitbox.count == 12
	|| targ.multitool_hitbox.count == 13
	|| targ.multitool_hitbox.count == 14
	|| targ.multitool_hitbox.count == 15
	|| targ.multitool_hitbox.count == 16
	|| targ.multitool_hitbox.count == 19
	|| targ.multitool_hitbox.count == 20
	|| targ.multitool_hitbox.count == 21
	|| targ.multitool_hitbox.count == 22
	|| targ.multitool_hitbox.count == 23
	|| targ.multitool_hitbox.count == 24
	|| targ.multitool_hitbox.count == 25
	|| targ.multitool_hitbox.count == 26
	|| targ.multitool_hitbox.count == 580
	|| targ.multitool_hitbox.count == 581
	|| targ.multitool_hitbox.count == MTB64U_WINDOW_FUTURE
	|| targ.multitool_hitbox.count == MTB64U_WINDOW_FUTURE_X
	|| targ.multitool_hitbox.count == MTB64U_DOOR_R_GLASS
	|| targ.multitool_hitbox.count == MTB64U_FITTEDWINDOW_UWINDOW
	|| targ.multitool_hitbox.count == MTB64_CLAIMSTONE
	|| targ.multitool_hitbox.count == MTB64U_CLAIMSTONE
	|| ((targ.multitool_hitbox.count == MTB64_FURN_IRONBRAZIER) && (targ.multitool_hitbox.multitool_flamecolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64_FURN_CHAIR_FANCY1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64_FURN_CHAIR_FANCY2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64_FURN_CHAIR_FANCY3) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64_FURN_CHAISELOUNGE) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_STOVE2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_FRIDGE3) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BED_FOAM) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SOFA_FOAM) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SOFA_TARTAN) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SOFA_POOFY) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SOFA_NORM) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_CSTOOL) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINET1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETTOP1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETTOPDEEP1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETTOPSHORT1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINET2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINET3) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINET4) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNER1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNER2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNERTOP1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNERTOP2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETBAR1) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETBARENDR) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_BSCKCABINETBARENDL) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_RETROCHAIR) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_PLSCHAIR) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SCHINTGRDESK) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SCHDESKCHAIR) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_RETROTABLE) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count == MTB64U_FURN_SCHAIR) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count >= MTB64_SHINGLES && targ.multitool_hitbox.count <= MTB64_SHINGLESLAST) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count >= MTB64_SHINGLES2 && targ.multitool_hitbox.count <= MTB64_SHINGLES2LAST) && (targ.multitool_hitbox.multitool_roofcolor == -10))
	|| ((targ.multitool_hitbox.count >= MTB64_WOOD1 && targ.multitool_hitbox.count <= MTB64_WOOD1LAST) && (targ.multitool_hitbox.multitool_woodcolor == -10))
	|| targ.multitool_hitbox.count == 1002
	|| targ.multitool_hitbox.count == 1003
	|| targ.multitool_hitbox.count == 1004
	|| targ.multitool_hitbox.count == 1006
	|| targ.multitool_hitbox.count == 1012
	|| targ.multitool_hitbox.count == 1019
	|| targ.multitool_hitbox.count == 1023
	|| targ.multitool_hitbox.count == 1026
	|| targ.multitool_hitbox.count == 1031
	|| targ.multitool_hitbox.count == 1652
	|| (targ.multitool_hitbox.count == 1015 && targ.subordinate.subordinate.cnt) //Must be pumping oil, otherwise no color
	) {
		//Colored buildings
		if (teamplay) {
			targ.team = other.team;
			targ.colormap = 1024 + (other.team - 1) * 17;
			
			if (targ.multitool_hitbox.count == 1002 || targ.multitool_hitbox.count == 1031 || targ.multitool_hitbox.count == 1652 || targ.multitool_hitbox.count == MTB64U_DOOR_R_GLASS)
			{
				targ.subordinate.subordinate.team = targ.team;
				targ.subordinate.subordinate.colormap = targ.colormap;	
			}
		} else {
			targ.colormap = other.colormap;
			if (targ.multitool_hitbox.count == 1002 || targ.multitool_hitbox.count == 1031 || targ.multitool_hitbox.count == 1652 || targ.multitool_hitbox.count == MTB64U_DOOR_R_GLASS)
			{
				targ.subordinate.subordinate.colormap = targ.colormap;	
			}
		}	
	}
	
	if (targ.multitool_hitbox.count == 1007
	|| targ.multitool_hitbox.count == 1008
	|| targ.multitool_hitbox.count == 1009
	|| targ.multitool_hitbox.count == 1010
	|| targ.multitool_hitbox.count == 1011
	|| targ.multitool_hitbox.count == 1015
	|| targ.multitool_hitbox.count == 1016
	|| targ.multitool_hitbox.count == 1017
	|| targ.multitool_hitbox.count == 1018
	|| targ.multitool_hitbox.count == 1020
	|| targ.multitool_hitbox.count == 1021
	|| targ.multitool_hitbox.count == 1025
	|| targ.multitool_hitbox.count == 1027
	|| targ.multitool_hitbox.count == 1028
	|| targ.multitool_hitbox.count == 1029
	|| targ.multitool_hitbox.count == 1030
	|| targ.multitool_hitbox.count == 1032
	|| targ.multitool_hitbox.count == 1033
	|| targ.multitool_hitbox.count == 1034
	|| targ.multitool_hitbox.count == 1035
	|| targ.multitool_hitbox.count == 1036
	|| targ.multitool_hitbox.count == 1037
	|| targ.multitool_hitbox.count == 1120
	|| targ.multitool_hitbox.count == 1121
	|| targ.multitool_hitbox.count == 1122
	|| targ.multitool_hitbox.count == 1123
	|| targ.multitool_hitbox.count == 1124
	|| targ.multitool_hitbox.count == 1125
	|| targ.multitool_hitbox.count == 1126
	|| targ.multitool_hitbox.count == 1127
	|| targ.multitool_hitbox.count == 1130
	|| targ.multitool_hitbox.count == 1131
	|| targ.multitool_hitbox.count == 1510
	|| targ.multitool_hitbox.count == 110
	|| targ.multitool_hitbox.count == 111
	|| targ.multitool_hitbox.count == 112
	|| targ.multitool_hitbox.count == 1110
	|| targ.multitool_hitbox.count == 1111
	|| targ.multitool_hitbox.count == 1112
	|| targ.multitool_hitbox.count == 1113
	|| targ.multitool_hitbox.count == 1114
	|| targ.multitool_hitbox.count == 1115
	|| targ.multitool_hitbox.count == 1116
	|| targ.multitool_hitbox.count == 1117
	|| targ.multitool_hitbox.count == 1118
	) {
		//Colored Control Point
		if (teamplay) {
			targ.subordinate.team = other.team;
			targ.subordinate.colormap = 1024 + (other.team - 1) * 17;
		} else {
			targ.subordinate.colormap = other.colormap;
		}
	}
	
	if (targ.multitool_hitbox.count == 1120
	|| targ.multitool_hitbox.count == 1121
	|| targ.multitool_hitbox.count == 1122
	|| targ.multitool_hitbox.count == 1123
	|| targ.multitool_hitbox.count == 1124
	|| targ.multitool_hitbox.count == 1125
	|| targ.multitool_hitbox.count == 1126
	|| targ.multitool_hitbox.count == 1127
	|| targ.multitool_hitbox.count == 1130
	|| targ.multitool_hitbox.count == 1131
	|| targ.multitool_hitbox.count == 110
	|| targ.multitool_hitbox.count == 111
	|| targ.multitool_hitbox.count == 112
	|| targ.multitool_hitbox.count == 1110
	|| targ.multitool_hitbox.count == 1111
	|| targ.multitool_hitbox.count == 1112
	|| targ.multitool_hitbox.count == 1113
	|| targ.multitool_hitbox.count == 1114
	|| targ.multitool_hitbox.count == 1115
	|| targ.multitool_hitbox.count == 1116
	|| targ.multitool_hitbox.count == 1117
	|| targ.multitool_hitbox.count == 1118)
	{
		//Change Mannable Turret team and color etc.
		if (teamplay) {
			//If didn't have enough forgeparts to build, these subentities wont exist
			//(We allow the building itself to be built, however, ofcourse: freedom to build/design)
			if (targ.subordinate2.tur_head) {
				targ.subordinate2.tur_head.team = targ.subordinate2.team = other.team;
				targ.subordinate2.tur_head.colormap = targ.subordinate2.colormap = 1024 + (other.team - 1) * 17;
			}
			
			if (targ.subordinate2.gun2) {
				targ.subordinate2.gun2.colormap = targ.subordinate2.colormap;
			}
		} else {
			//If didn't have enough forgeparts to build, these subentities wont exist
			if (targ.subordinate2.tur_head) {
				targ.subordinate2.tur_head.colormap = targ.subordinate2.colormap = other.colormap;
			}
			
			if (targ.subordinate2.gun2) {
				targ.subordinate2.gun2.colormap = targ.subordinate2.colormap;
			}
		}
		
	}
	
	if (targ.multitool_hitbox.count == 20)
	{
		//Change mounted gun team and color etc.
		if (teamplay) {
			targ.subordinate2.tur_head.team = targ.subordinate2.team = other.team;
			targ.subordinate2.tur_head.colormap = targ.subordinate2.colormap = 1024 + (other.team - 1) * 17;
		
			targ.subordinate2a.tur_head.team = targ.subordinate2a.team = other.team;
			targ.subordinate2a.tur_head.colormap = targ.subordinate2a.colormap = 1024 + (other.team - 1) * 17;
			
			targ.subordinate3.tur_head.team = targ.subordinate3.team = other.team;
			targ.subordinate3.tur_head.colormap = targ.subordinate3.colormap = 1024 + (other.team - 1) * 17;
		
			targ.subordinate3a.tur_head.team = targ.subordinate3a.team = other.team;
			targ.subordinate3a.tur_head.colormap = targ.subordinate3a.colormap = 1024 + (other.team - 1) * 17;
		} else {
			targ.subordinate2.tur_head.colormap = targ.subordinate2.colormap = other.colormap;
			
			targ.subordinate2a.tur_head.colormap = targ.subordinate2a.colormap = other.colormap;
			
			targ.subordinate3.tur_head.colormap = targ.subordinate3.colormap = other.colormap;
			
			targ.subordinate3a.tur_head.colormap = targ.subordinate3a.colormap = other.colormap;
		}
		
	}
	
	if ((targ.multitool_hitbox.count >= 500
	&& targ.multitool_hitbox.count < 1000)
	|| (targ.multitool_hitbox.count >= 10000
	&& targ.multitool_hitbox.count < 20000)
	||  (targ.multitool_hitbox.count <= -500
	&& targ.multitool_hitbox.count > -1000)
	|| (targ.multitool_hitbox.count >= 1500
	&& targ.multitool_hitbox.count < 2000))
	{
		//Wall capture points
		if (teamplay) {
			targ.subordinate.team = other.team;
			targ.subordinate.colormap = 1024 + (other.team - 1) * 17;
		} else {
			targ.subordinate.colormap = other.colormap;
		}
	}
	
	if (targ.multitool_hitbox.count == 4) {
		//Garrison
		multitool_flag_colors(targ.subordinate, other);
	}
	
	if (targ.multitool_hitbox.count == 503 || targ.multitool_hitbox.count == 1502) {
		//RecruitmentPost
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate, other);
	}
	
	if (targ.multitool_hitbox.count == 5) {
		//Stronghold
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
	}
	
	if (targ.multitool_hitbox.count == 6) {
		//Strong Tower
		multitool_flag_colors(targ.subordinate, other);
	}
	
	if (targ.multitool_hitbox.count == 7) {
		//Small Castle
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
	}
	
	if (targ.multitool_hitbox.count == 27) {
		//Crusader Stronghold
		local entity ourcontrolpoint;
		local entity oldbnnr1;
		local entity oldbnnr2;
		local entity newbnnr1;
		local entity newbnnr2;
		entity ouroldself;
		
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		multitool_flag_colors(targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate, other);
		//Control point would be here in the subordinate chain for Crusader Stronghold
		ourcontrolpoint = targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
		
		oldbnnr1 = targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
		oldbnnr2 = targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
		                      
		if (multitool_setcrusaderstrongholdbannermodels(oldbnnr1, oldbnnr2, other, 1, 1))
		{		      
			newbnnr1 = spawn();
			newbnnr2 = spawn();
		
			//Take the place of the old in the chain
			ourcontrolpoint.subordinate = newbnnr1;
			newbnnr1.subordinate = newbnnr2;
			newbnnr2.subordinate = oldbnnr2.subordinate;
		
			if (ourcontrolpoint.subordinate == world) { print("Multitool Banner Error in substituting chain A\n"); }
			if (newbnnr1.subordinate == world) { print("Multitool Banner Error in substituting chain B\n"); }
			if (newbnnr2.subordinate == world) { print("Multitool Banner Error in substituting chain C\n"); }
		
			//Copy
			newbnnr1.origin = oldbnnr1.origin;
			newbnnr1.angles = oldbnnr1.angles;
			newbnnr1.solid = oldbnnr1.solid;
			newbnnr1.cnt = oldbnnr1.cnt; //Used to store color
			newbnnr1.movetype = oldbnnr1.movetype;
			newbnnr1.model = oldbnnr1.model;
			newbnnr1.skin = oldbnnr1.skin;
			newbnnr1.colormap = oldbnnr1.colormap;
		
			newbnnr2.origin = oldbnnr2.origin;
			newbnnr2.angles = oldbnnr2.angles;
			newbnnr2.solid = oldbnnr2.solid;
			newbnnr2.cnt = oldbnnr2.cnt; //Used to store color
			newbnnr2.movetype = oldbnnr2.movetype;
			newbnnr2.model = oldbnnr2.model;
			newbnnr2.skin = oldbnnr2.skin;
			newbnnr2.colormap = oldbnnr2.colormap;
		
			ouroldself = self;
		
			self = newbnnr1;
			setorigin(self, self.origin);
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
		
			self = newbnnr2;
			setorigin(self, self.origin);
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
		
			self = ouroldself;
		
			remove(oldbnnr1);
			remove(oldbnnr2);
		}
		
	}
	
	if (targ.multitool_hitbox.count == 1001) {
		//Commandpost
		multitool_flag_colors(targ.subordinate, other);
	}
	
	if ((targ.multitool_hitbox.count > 0 && targ.multitool_hitbox.count < 4) || (targ.multitool_hitbox.count == 8) || (targ.multitool_hitbox.count == 10)) {
		entity t1, t2, t3, t4, t5;
		t1 = targ.subordinate.subordinate.subordinate;
		t2 = targ.subordinate.subordinate.subordinate.subordinate;
		t3 = targ.subordinate.subordinate.subordinate.subordinate.subordinate;
		t4 = targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
		t5 = targ.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
		
		//print(etos(t1),"  ",etos(t2),"  ",etos(t3),"  ",etos(t4),"  ",etos(t5)," etos\n");
		
		if (t1.tur_head || t2.tur_head || t3.tur_head || t4.tur_head || (targ.multitool_hitbox.count == 10 && t5.tur_head)) {
			//Normal if we spawned the turrets
		
			t1.colormap =
			t1.tur_head.colormap =
			t2.colormap =
			t2.tur_head.colormap = 
			t3.colormap =
			t3.tur_head.colormap = 
			t4.colormap =
			t4.tur_head.colormap =
			other.colormap;
		
			if (targ.multitool_hitbox.count == 10) {
			t5.colormap = 
			t5.tur_head.colormap = other.colormap;
			}
		
			if (teamplay) {
			t1.team =
			t1.tur_head.team =
			t2.team =
			t2.tur_head.team = 
			t3.team =
			t3.tur_head.team = 
			t4.team =
			t4.tur_head.team =
			other.team;
				if (targ.multitool_hitbox.count == 10) {
					t5.team = 
					t5.tur_head.team = other.team;
				}
			}
			///////////////////////
		} else {
			//If we didn't spawn them due to insufficent forgeparts
			t1.colormap =
			t2.colormap =
			t3.colormap =
			t4.colormap =
			other.colormap;
		
			if (targ.multitool_hitbox.count == 10) {
			t5.colormap = other.colormap;
			}
		
			if (teamplay) {
			t1.team =
			t2.team =
			t3.team =
			t4.team =
			other.team;
				if (targ.multitool_hitbox.count == 10) {
					t5.team = other.team;
				}
			}
			///////////////////////
		}
		
		t1.realowner = 
		t2.realowner = 
		t3.realowner = 
		t4.realowner =
		other;
		
		if (targ.multitool_hitbox.count == 10) {
		t5.realowner = other;
		}
		
		t1.SendFlags = 
		t2.SendFlags = 
		t3.SendFlags = 
		t4.SendFlags = 
		TNSF_FULL_UPDATE;
		
		if (targ.multitool_hitbox.count == 10) {
		t5.SendFlags = TNSF_FULL_UPDATE;
		}
	}
	
	if (targ.multitool_hitbox.count == 1013 || targ.multitool_hitbox.count == 1014 || targ.multitool_hitbox.count == 1038) {
		entity t1;
		
		t1 = targ.subordinate.subordinate;
		
		if (t1.tur_head) {
			//Normal, spawned turret
					
			t1.colormap = t1.tur_head.colormap = other.colormap;
			
			if (teamplay) {
				t1.team = t1.tur_head.team = other.team;
			}
		
		} else {
			//If we didn't have enough forgeparts to spawn turret
					
			t1.colormap = other.colormap;
			
			if (teamplay) {
				t1.team = other.team;
			}
		}
		
		t1.realowner = other;
		
		t1.SendFlags = TNSF_FULL_UPDATE;
	}
	
	if (targ.multitool_hitbox != world) {
		targ.multitool_hitbox.realowner = other;
		targ.multitool_hitbox.team = other.team;
	} else {
		print("error, mutitool_hitbox is world, which means it doesn't exist. Orphaned control point likely\n");
	}
	
	entity e;
	e = targ;
	
	e.SendFlags = TNSF_FULL_UPDATE;
	
	while (e) {
		if (e.realowner) e.realowner = other;
		if (!teamplay &&
		((e.turrcaps_flags & TFL_TURRCAPS_ISTURRET)
		|| (e.owner.turrcaps_flags & TFL_TURRCAPS_ISTURRET)))
		{
			//In non team games we don't wish to touch
			//Turrets or their turret head
			//(Though this code normally will not reach a turret head
			//as turret heads usually are not set as .subordinate)
			//But there is a check here for completeness
			//print("avoid\n");
		} else {
			//This was the normal code before
			//Since it generally works fine
			//And only causes problems with turrets in non-team games
			//We carved out an exception above
			if (e.team) e.team = other.team;
		}
		e = e.subordinate;
		//print("doing\n");
	}
	//print("Changed\n");
}

void multitool_orphancontrolpointreaper_think()
{
	entity e;
  	for(e = world; (e = find(e, classname, "bldctrlpt")); )
	{
		//print(etos(e.owner),"\n");
		if (e.owner == world
		|| !e.owner
		|| !e.owner.multitool_hitbox
		|| e.owner.multitool_hitbox == world) { //Owner should be the tower/building
   			print("Removing orphan control point found at ", vtos(e.origin), "\n");
			remove_safely(e);
		}
    	}
	
	for(e = world; (e = find(e, classname, "bldhitbx")); )
	{
		if (e.owner == world
		|| !e.owner) { //Owner should be the tower/building
   			print("Removing orphan bldhitbox found at ", vtos(e.origin), "\n");
			remove_safely(e);
		}
    	}
	self.nextthink = time + 60;
}

void spawnfunc_multitool_orphancontrolpointreaper()
{	
	self.think = multitool_orphancontrolpointreaper_think;
	self.nextthink = time + 60;
	orphancontrolpointreaper = 1;
}

entity multitool_findneartree(vector sorigin, float sradius)
{
	
	entity f;
	f = findradius(sorigin, sradius);
  	while(f)
  	{
		if (f.classname == "tree")
		{
			return(f);
		}
	    	f = f.chain;	
	}
	return(world);	
}

float multitool_findnearbldngtype(vector sorigin, float sradius, float mybldnum, float dolookforscaffold)
{
	
	entity f;
	f = findradius(sorigin, sradius);
  	while(f)
  	{
		if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if (dolookforscaffold) {
				   if (f.amnt == mybldnum) {
					//amnt is only found on scaffolds in this code
					//its just like count
					return TRUE;
				   }
				}
				 
    				if (f.count == mybldnum) {
					return TRUE;
				}
			}
	    	f = f.chain;	
	}
	return FALSE;	
}

float multitool_findnearbldngclass(vector sorigin, float sradius, float mybldclass)
{
	
	entity f;
	f = findradius(sorigin, sradius);
  	while(f)
  	{
			if (f.classname == "building")
			{
				 
    				if (f.building_class == mybldclass) {
					return TRUE;
				}
			}
	    	f = f.chain;	
	}
	return FALSE;	
}

float DragTestFurnInSolid(entity e);
void multitool_DropDrageeToFloor (entity draggee) {
	if not(DragTestFurnInSolid(draggee)) {
		local entity myoldself;
		myoldself = self;
		self = draggee;
		traceline(self.origin + '0 0 0.1', self.origin - ('0 0 1' * autocvar_sv_gravity * frametime), MOVE_NORMAL, self);
		setorigin(self, trace_endpos);
		self = myoldself;
	}
}

void multitool_controlpoint_think()
{
	self.cnt = 0; //Used to limit amount of players who can contribute
	self.nextthink = time;
	if (self.multitool_dragable) {
		multitool_DropDrageeToFloor(self.multitool_dragmaster);
		setorigin(self, self.multitool_dragmaster.origin);
	}
}

void multitool_controlpoint_touch()
{
	local float helpoutfriend;
	helpoutfriend = 0;
		
	//print("touched\n");
	if (other.classname != "player")
			return;
	
	if (self.cnt >= 6)
			return;
			
	if (multitool_capturetooclose(other, self.owner, self))
		return;
		
	if (teamplay) {
		if (self.team == other.team) {
			if (self.health < self.max_health) {
				self.health = self.health + (2 * sys_frametime);
				self.alpha = bound(0.2, self.health/self.max_health, 1);
			}
		} else {
			self.health = self.health - (2 * sys_frametime);
			if (self.health <= 0) {
				self.health = 20;
				self.alpha = bound(0.2, self.health/self.max_health, 1);
				multitool_oiltank_change(self.owner);
				multitool_housing_change(self.owner);
				self.team = other.team;
				self.realowner = other;
				multitool_controlpoint_change(self.owner);
			}
		}
		self.cnt++;
	} else {
		if (autocvar_g_allow_friends) {
			//Here if the person _standing_ on the control point has
			//set the owner of the control point as his friend
			//then that person standing on the control point,
			//because _he_ considers owner a friend, helps the owner.
			//This is not based on the opinion the owner has for the 
			//person standing.
			if (self.realowner != other) {
			if (self.realowner && self.realowner != world) {
			if(quickIsFriendOf(other, self.realowner)) {
				helpoutfriend = 1;
			}
			}
			}
		}
		
		if (self.realowner == other || helpoutfriend) {
			if (self.health < self.max_health) {
				self.health = self.health + (2 * sys_frametime);
				self.alpha = bound(0.2, self.health/self.max_health, 1);
			}
		} else {
			self.health = self.health - (2 * sys_frametime);
			if (self.health <= 0) {
				self.health = 20;
				self.alpha = bound(0.2, self.health/self.max_health, 1);
				self.realowner = other;
				multitool_controlpoint_change(self.owner);
			}
		}
		self.cnt++;
	}
	
	if((self.pushltime + 1) < time)  // prevent flooding message
	{
		if (teamplay) {
			if(self.team == COLOR_TEAM1) {
				sprint(other, sprintf(_("^xF66%.0f / %.0f^7\n"), self.health, self.max_health));
			} else if(self.team == COLOR_TEAM2) {
				sprint(other, sprintf(_("^x66F%.0f / %.0f^7\n"), self.health, self.max_health));
			} else if(self.team == COLOR_TEAM3) {
				sprint(other, sprintf(_("^xFF6%.0f / %.0f^7\n"), self.health, self.max_health));
			} else if(self.team == COLOR_TEAM4) {
				sprint(other, sprintf(_("^xF6F%.0f / %.0f^7\n"), self.health, self.max_health));
			} else {
				if (self.realowner.team == other.team) {
					sprint(other, sprintf(_("%.0f / %.0f\n"), self.health, self.max_health));
				} else {
					sprint(other, sprintf(_("^x322%.0f / %.0f^7\n"), self.health, self.max_health));
				}
			}
		} else {
			if (self.realowner == other || helpoutfriend) {
				if (self.realowner && self.realowner != world) {
					//Some color for the text
					local vector my_c0, my_c1, my_c2;
					local string myhexc;
	
					my_c0 = colormapPaletteColor(floor(self.realowner.clientcolors / 16), 0); //Shirt
					my_c1 = colormapPaletteColor(mod(self.realowner.clientcolors, 16), 1);    //Pants
					my_c2 = my_c0+my_c1;
		
					myhexc = rgb_to_hexcolor(my_c2);
					sprint(other, strcat(myhexc,sprintf(_("%.0f / %.0f\n"), self.health, self.max_health) ));
				} else {
					sprint(other, sprintf(_("%.0f / %.0f\n"), self.health, self.max_health));
				}
			} else {
				sprint(other, sprintf(_("^x322%.0f / %.0f^7\n"), self.health, self.max_health));
			}
		}
		self.pushltime = time + 2;
	}
			
	//WaypointSprite_UpdateBuildFinished(self.sprite, time + (self.max_health - self.health) / (e.count / sys_frametime));
}

void spawnfunc_multitool_controlpoint()
{
	//entity e;
	precache_model("models/onslaught/controlpoint_pad.md3");
	self.solid = SOLID_TRIGGER;
	self.movetype = MOVETYPE_NONE;
	self.scale = 0.5;
	setmodel(self, "models/onslaught/controlpoint_pad.md3");
	setsize(self, '-32 -32 0', '32 32 38');
	self.multitool_iscontrolpoint = 1;
	//if (!self.noalign)
        //droptofloor();
	
	setorigin(self, self.origin);
	self.touch = multitool_controlpoint_touch;
	self.classname = "bldctrlpt";
	if not(self.max_health) self.max_health = 600;
	if not(self.health)self.health = 10;
	self.alpha = bound(0.2, self.health/self.max_health, 1);
	self.think = multitool_controlpoint_think;
	self.nextthink = time;
	
	if (self.owner.multitool_dragable) {
		//print("is dragable\n");
		self.multitool_dragable = 1;
		self.multitool_dragmaster = self.owner;
	}
}

void multitool_stockpilethink()
{
	local entity eburn;
	eburn = findradius(self.origin, self.count);
	while(eburn)
	{
		if (eburn.flags & (FL_ITEM | FL_WEAPON | FL_POWERUP))
		if not(eburn.flags & FL_MONSTER)
		if not(eburn.flags & FL_CLIENT)
		{
			if ((eburn.alpha && eburn.alpha == 1)
			|| !(eburn.alpha))
			{
				eburn.nextthink = time + 10;
				//print(etos(eburn),"\n");
			}
		}
	eburn = eburn.chain;
	}
	self.nextthink = time + 4;
		
}

float g_skycycle;
float g_skycycle_started;
float skycycle_intensity_realmax; 
float skycycle_intensity_current;
float skycycle_ambient_realmax;
float skycycle_ambient_current;
float multitool_solarpanel_tracetosky(entity myself)
{
	//Yes this should collide with energy shields.
	//Got to build your solar panels where they have a clear view of the sky
	if (g_skycycle) {
	 if (g_skycycle_started) {
	 	//Using these as they also change with nukes
	 	local float notenoughlight;
		notenoughlight = 0;
		if ((skycycle_ambient_realmax * 0.25) > skycycle_ambient_current) {
			notenoughlight = notenoughlight + 1;
		}
	
		if ((skycycle_intensity_realmax * 0.25) > skycycle_intensity_current) {
			notenoughlight = notenoughlight + 1;
		}
		
		if (notenoughlight >= 2) {
			//print("not enough light\n");
			return 0;
		}
		
		//print("enough light\n");
	 }
	}
	local entity e;
	local vector testpoint;
	local vector firstpoint;
	e = spawn();
	e.origin = myself.origin;
	e.origin_z = e.origin_z + 608;
	e.mins = '-3 -3 -3';
	e.maxs = '3 3 3';
	//print(vtos(myself.origin), "_solarpanel model origin\n");
	//print(vtos(e.origin), "_solarpanel trace to sky testing origin\n");
	//Start slightly above the surface of the panel.
	tracebox(e.origin, e.mins, e.maxs, e.origin + ('0 0 1' * MAX_SHOT_DISTANCE), MOVE_WORLDONLY, e);
	firstpoint = trace_endpos;
	
	tracebox(e.origin, e.mins, e.maxs, e.origin + ('0 0 1' * MAX_SHOT_DISTANCE), MOVE_NORMAL, e);
	
	remove(e);
	
	//print(vtos(firstpoint), "_trace worldonly end\n");
	//print(vtos(trace_endpos), "_trace normal end\n");
	
	if (trace_endpos_z < firstpoint_z) {
		//print("Solar must have hit something, first worldonly test higher than second\n");
		return 0;
	}
	
	if(trace_dphitq3surfaceflags & Q3SURFACEFLAG_SKY) {
		return 1;
	} else if(trace_dphitcontents & DPCONTENTS_SOLID) {
		//print("Solar hit solid\n");
		return 0;
	}
	
	if (pointcontents (trace_endpos) == CONTENT_SKY) {
		return 1;
	} else if (pointcontents (trace_endpos) == CONTENT_SOLID) {
		//print("Solar very near content solid\n");
		return 0;
	}
	
	testpoint = trace_endpos;
	testpoint_z = testpoint_z + 1;
	
	if (pointcontents (testpoint) == CONTENT_SKY) {
		return 1;
	} else if (pointcontents (testpoint) == CONTENT_SOLID) {
		//print("Solar very near content +1 solid\n");
		return 0;
	}
	
	testpoint = trace_endpos;
	testpoint_z = testpoint_z - 1;
	
	if (pointcontents (testpoint) == CONTENT_SOLID) {
		//print("Solar very near content -1 solid\n");
		return 0;
	}
	
	//print("Hanging in air, fine allow\n");
	return 1; //Hanging in air
}

void multitool_solarpanel_think()
{
	self.nextthink = time + 60;
	if not (multitool_solarpanel_tracetosky(self.subordinate5))
	{
		//Subordinate5 is set to the actual e entity of the solar panel, thus will have correct origin for trace to sky
		//print("Solar panel blocked from sky, will not produce energy this cycle\n");
		return;
	}
	
	if (!self.ammount) {
	  //Sending energy to global
	  if (teamplay)
	  {
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (capacity_energy_team1 > current_energy_team1) {
				current_energy_team1 = current_energy_team1 + SOLARPANEL_ENERGY;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (capacity_energy_team2 > current_energy_team2) {
				current_energy_team2 = current_energy_team2 + SOLARPANEL_ENERGY;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (capacity_energy_team3 > current_energy_team3) {
				current_energy_team3 = current_energy_team3 + SOLARPANEL_ENERGY;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (capacity_energy_team4 > current_energy_team4) {
				current_energy_team4 = current_energy_team4 + SOLARPANEL_ENERGY;
			}
		} else {
			if (capacity_energy_world > current_energy_world) {
				current_energy_world = current_energy_world + SOLARPANEL_ENERGY;
			}
		}
	  } else {
		if (capacity_energy_world > current_energy_world) {
			current_energy_world = current_energy_world + SOLARPANEL_ENERGY;
		}
	  }
	} else {
	  //Sending energy to Local
	  /////////////////////////////////////////////////////////////////////////////////////
	  //Could have done something more complex with searching for a new battery
	  //If the current one is full after allready assigned,
	  // but decided not to as didn't want to be constantly running the loop every
	  // min or so for each solar panel in the vain hope that another battery will be built.
	  //(Same for other similar code in other blocks below (shields etc))
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  //Can we giveto a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  local entity f;
	  local float usedlocalresource;
	  if (numberoflocalenergybatterys) {
	  	//print (etos(self.subordinate4.subordinate4.realowner), " Sp_Building Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), " Sp_LocalResource Owner\n");
		//print (ftos(self.subordinate4.subordinate4.team), " Sp_TEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), " Sp_TEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), " Sp_Energy LocalResource\n");
	  	//print (ftos(self.subordinate6.capacity_energy_local), " Sp_Energy LocalResourceCapacity\n");
		
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.capacity_energy_local > self.subordinate6.current_energy_local) {
						//print(" Sp_Using\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local + SOLARPANEL_ENERGY;
					usedlocalresource = 1; //So we don't go into the loop
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
			////Our model, got to use this as our think ent doesn't have origin set (and shouldnt in this case)
			////We made a seperate think entity because doing so on the model was unreliable, only thought once in awhile
			////And seemingly only when people were around. Our simple think ent always thinks on time
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS); //For solarpanelthink, subordinate5 is set to the e(model)
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
			    		//print("Sp Here1\n");
				
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
						//print("Sp Here2\n");
						//print (ftos(f.current_energy_local), " SpF_Energy LocalResource\n");
	  					//print (ftos(f.capacity_energy_local), " SpF_Energy LocalResourceCapacity\n");
					
					if(f.capacity_energy_local > f.current_energy_local) {
							//print(" Sp_Found one\n");
						f.current_energy_local = f.current_energy_local + SOLARPANEL_ENERGY;
						//usedlocalresource = 1; //No real need to set this now, but eh
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print(" Sp_Brokeout\n\n");
		}
		//print(" Sp_Did\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	}
}

void multitool_field_grain_think()
{
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (capacity_food_grain_team1 > current_food_grain_team1) {
				current_food_grain_team1 = current_food_grain_team1 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (capacity_food_grain_team2 > current_food_grain_team2) {
				current_food_grain_team2 = current_food_grain_team2 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (capacity_food_grain_team3 > current_food_grain_team3) {
				current_food_grain_team3 = current_food_grain_team3 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (capacity_food_grain_team4 > current_food_grain_team4) {
				current_food_grain_team4 = current_food_grain_team4 + FIELD_FOOD;
			}
		} else {
			if (capacity_food_grain_world > current_food_grain_world) {
				current_food_grain_world = current_food_grain_world + FIELD_FOOD;
			}
		}
	} else {
		if (capacity_food_grain_world > current_food_grain_world) {
			current_food_grain_world = current_food_grain_world + FIELD_FOOD;
		}
	}
	self.nextthink = time + 55 + (10 * random()); // 1/2 lower than 60, 1/2 higher
}

void multitool_field_greens_think()
{
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (capacity_food_greens_team1 > current_food_greens_team1) {
				current_food_greens_team1 = current_food_greens_team1 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (capacity_food_greens_team2 > current_food_greens_team2) {
				current_food_greens_team2 = current_food_greens_team2 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (capacity_food_greens_team3 > current_food_greens_team3) {
				current_food_greens_team3 = current_food_greens_team3 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (capacity_food_greens_team4 > current_food_greens_team4) {
				current_food_greens_team4 = current_food_greens_team4 + FIELD_FOOD;
			}
		} else {
			if (capacity_food_greens_world > current_food_greens_world) {
				current_food_greens_world = current_food_greens_world + FIELD_FOOD;
			}
		}
	} else {
		if (capacity_food_greens_world > current_food_greens_world) {
			current_food_greens_world = current_food_greens_world + FIELD_FOOD;
		}
	}
	self.nextthink = time + 40 + (40 * random()); // 1/2 lower than 60, 1/2 higher
}

void multitool_field_grapes_think()
{
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (capacity_food_grapes_team1 > current_food_grapes_team1) {
				current_food_grapes_team1 = current_food_grapes_team1 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (capacity_food_grapes_team2 > current_food_grapes_team2) {
				current_food_grapes_team2 = current_food_grapes_team2 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (capacity_food_grapes_team3 > current_food_grapes_team3) {
				current_food_grapes_team3 = current_food_grapes_team3 + FIELD_FOOD;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (capacity_food_grapes_team4 > current_food_grapes_team4) {
				current_food_grapes_team4 = current_food_grapes_team4 + FIELD_FOOD;
			}
		} else {
			if (capacity_food_grapes_world > current_food_grapes_world) {
				current_food_grapes_world = current_food_grapes_world + FIELD_FOOD;
			}
		}
	} else {
		if (capacity_food_grapes_world > current_food_grapes_world) {
			current_food_grapes_world = current_food_grapes_world + FIELD_FOOD;
		}
	}
	self.nextthink = time + 70 + (40 * random()); //Vineyards are slower
}


void multitool_mannableturret_think()
{
	if (self.subordinate5) {
		if (self.subordinate5.colormap != self.subordinate4.colormap) {
			self.subordinate5.tur_head.colormap = self.subordinate5.colormap = self.subordinate4.colormap;
			//print("changecolormap\n");
		}
		
		//if (self.subordinate5.origin != self.origin) {
		if ((self.subordinate5.origin_z - self.origin_z > 1)
		|| (self.subordinate5.origin_z - self.origin_z < -1)
		|| (self.subordinate5.origin_y - self.origin_y > 1)
		|| (self.subordinate5.origin_y - self.origin_y < -1)
		|| (self.subordinate5.origin_x - self.origin_x > 1)
		|| (self.subordinate5.origin_x - self.origin_x < -1)) {
			//print(vtos(self.origin)," vs ",vtos(self.subordinate5.origin)," ResetOrigin\n");
			self.subordinate5.origin = self.origin;
			setorigin(self.subordinate5, self.subordinate5.origin);
		}

		if (teamplay)
		{
			if (self.subordinate5.team != self.subordinate4.team) {
				print("Teams\n");
				self.subordinate5.tur_head.team = self.subordinate5.team = self.subordinate4.team;
			}
		}
	} else {
		print("Notfound\n");
	}
	self.nextthink = time + 1;
}

void multitool_mountedgun_think()
{
	if (self.subordinate5) {
		//if (self.subordinate5.origin != self.origin) {
		if ((self.subordinate5.origin_z - self.origin_z > 1)
		|| (self.subordinate5.origin_z - self.origin_z < -1)
		|| (self.subordinate5.origin_y - self.origin_y > 1)
		|| (self.subordinate5.origin_y - self.origin_y < -1)
		|| (self.subordinate5.origin_x - self.origin_x > 1)
		|| (self.subordinate5.origin_x - self.origin_x < -1)) {
			//print(vtos(self.origin)," vs ",vtos(self.subordinate5.origin)," ResetOrigin\n");
			self.subordinate5.origin = self.origin;
			setorigin(self.subordinate5, self.subordinate5.origin);
		}
	} else {
		print("Notfound\n");
	}
	self.nextthink = time + 1;
}

//Called by mutitool_oilpump_lookforoil
float mutitool_oilpump_prospectoil(vector myorigin, float myradius)
{
	//Do this if can't find oil
	local vector mysnappedorigin;
	local float plcedoilrsrc;
	local float myrandvar;
	entity oilprospect;
	plcedoilrsrc = 0; //Nothing by default, will return 0 if no oil and just placed an empty prospect
	mysnappedorigin = myorigin;
	mysnappedorigin_x = fsnap(mysnappedorigin_x, myradius);
	mysnappedorigin_y = fsnap(mysnappedorigin_y, myradius);
	
	oilprospect = spawn();
	oilprospect.origin = mysnappedorigin;
	
	if (random() < autocvar_g_resource_oil_rate) {
		//EX: Usually (random() < 0.1)
		//print(vtos(mysnappedorigin),"Placed rsrc oil\n");
		oilprospect.classname = "rsrc_oil";
		myrandvar = random();
		
		if (myrandvar < 0.1) {
			oilprospect.ammount = 1 + (random()*1.5); //Big one
		} else if (myrandvar < 0.5) {
			oilprospect.ammount = 0.6 + (random()*0.5); //Moderate
		} else {
			oilprospect.ammount = 0.1 + random();
		}
		
		plcedoilrsrc = oilprospect.ammount;
	} else {
		//print(vtos(mysnappedorigin),"Placed prospect\n");
		oilprospect.classname = "prspct_oil";
	}
	
	setorigin(oilprospect, oilprospect.origin);

	return plcedoilrsrc;
}		

//Called by mutitool_oilpump_lookforoil
float mutitool_oilpump_findoil(vector myorigin, float myradius)
{
		local entity e;
		local float foundprspct;
		local float foundrsrc;
		local vector lastrsrcorigin;
		lastrsrcorigin = '0 0 0';
		foundrsrc = 0;
		foundprspct = 0;
		e = findradius(myorigin, myradius);
		while(e)
		{
			if (e.classname == "rsrc_oil") {
				//print("found oil resource\n");
				if (e.ammount) {
				  //print("ammount is set as it should be\n");
		
				  if (foundrsrc) {
					if (vlen(e.origin-myorigin) < vlen(lastrsrcorigin-myorigin))
					{
					  //print("found oil resource closer\n");
					  //If this new origin is closer
					  foundrsrc = e.ammount;
					}
				  } else {
				  	//print("found first oil resource with ammount\n");
					foundrsrc = e.ammount;
				  }
				  
				  lastrsrcorigin = e.origin;
				}
			} else if (e.classname == "prspct_oil") {
				//print("found empty oil prospect\n");
				foundprspct = 1;
			}
			e = e.chain;
		}
		
		if (foundrsrc) {
			return foundrsrc;
		} else if (foundprspct) {
			return -1;
		}
		
		return 0; //Didn't find anything, we should go an put a rsrc or prospect down next.
}

//This is called when an oil pump is built.
float mutitool_oilpump_lookforoil(vector myorigin, float myradius)
{
	//We look for oil, or prospects, if none, then put one down.
	local float anyoilnear;
	
	if (g_spawnfoliagearound_oillevel)
	{
	 //Oil Ocean exists
	 //print (ftos(g_spawnfoliagearound_oillevel),"There is an oil ocean\n");
	 if (g_spawnfoliagearound_oillevel_started)
	 {
	  //print (ftos(g_spawnfoliagearound_oillevel_started),"It has been started\n");
	  if (g_spawnfoliagearound_oillevel_unchanging != 0)
	  {
	  	//print (ftos(g_spawnfoliagearound_oillevel_unchanging),"Oil level is set\n");
		if ((myorigin_z - 4096) < g_spawnfoliagearound_oillevel_unchanging) {
			//print ("We are near enough to it or in it\n");
			if ((myorigin_z + 128) < g_spawnfoliagearound_oillevel_unchanging) {
				//print ("Well doesn't work so well completely submerged under oil\n");
				return -3;
			}
			
			if ((myorigin_z - 512) < g_spawnfoliagearound_oillevel_unchanging) {
				//print ("We are very close\n");
				return 2.5; //Lots of oil to freely pump
			}
			
			if ((myorigin_z - 1024) < g_spawnfoliagearound_oillevel_unchanging) {
				//print ("We are close\n");
				return 2; //Lots of oil to freely pump
			}
			
			if ((myorigin_z - 2048) < g_spawnfoliagearound_oillevel_unchanging) {
				//print ("We are somewhat close\n");
				return 1.5; //Lots of oil to freely pump
			}
			return 1;
		}
	  }
	 }
	}
	
	anyoilnear = mutitool_oilpump_findoil(myorigin, myradius);
	if (anyoilnear == -1) {
		return 0; //Found empty prospects only, don't make any oil
	} else if (anyoilnear > 0) {
		return anyoilnear;
	} else {
		anyoilnear = mutitool_oilpump_prospectoil(myorigin, myradius*0.5); //0 if empty prospect placed, using half radius for placement snap
		return anyoilnear;
	}
}


void multitool_oilpump_think()
{
	if (!self.ammount) {
		if (teamplay)
		{
			if (self.subordinate4.team == COLOR_TEAM1) {
				if (capacity_crude_team1 > current_crude_team1) {
					current_crude_team1 = current_crude_team1 + self.cnt;
				}
			} else if (self.subordinate4.team == COLOR_TEAM2) {
				if (capacity_crude_team2 > current_crude_team2) {
					current_crude_team2 = current_crude_team2 + self.cnt;
				}
			} else if (self.subordinate4.team == COLOR_TEAM3) {
				if (capacity_crude_team3 > current_crude_team3) {
					current_crude_team3 = current_crude_team3 + self.cnt;
				}
			} else if (self.subordinate4.team == COLOR_TEAM4) {
				if (capacity_crude_team4 > current_crude_team4) {
					current_crude_team4 = current_crude_team4 + self.cnt;
				}
			} else {
				if (capacity_crude_world > current_crude_world) {
					current_crude_world = current_crude_world + self.cnt;
				}
			}
		} else {
			if (capacity_crude_world > current_crude_world) {
				current_crude_world = current_crude_world + self.cnt;
			}
		}
	} else {
	  //Subordinate5 is set to the actual e entity
	  //Sending energy to Local
	  /////////////////////////////////////////////////////////////////////////////////////
	  //Could have done something more complex with searching for a new tank
	  //If the current one is full after allready assigned,
	  // but decided not to as didn't want to be constantly running the loop every
	  // min or so for each solar panel in the vain hope that another tank will be built.
	  //(Same for other similar code in other blocks below (shields etc))
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  //Can we giveto a local tank?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  local entity f;
	  local float usedlocalresource;
	  if (numberoflocaloiltanks) {
	  	//print (etos(self.subordinate4.subordinate4.realowner), " Sp_Building Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), " Sp_LocalResource Owner\n");
		//print (ftos(self.subordinate4.subordinate4.team), " Sp_TEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), " Sp_TEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_crude_local), " Sp_Crude LocalResource\n");
	  	//print (ftos(self.subordinate6.capacity_crude_local), " Sp_Crude LocalResourceCapacity\n");
		
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.capacity_crude_local > self.subordinate6.current_crude_local) {
						//print(" Sp_Using\n");
					self.subordinate6.current_crude_local = self.subordinate6.current_crude_local + self.cnt;
					usedlocalresource = 1; //So we don't go into the loop
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
			////Our model, got to use this as our think ent doesn't have origin set (and shouldnt in this case)
			////We made a seperate think entity because doing so on the model was unreliable, only thought once in awhile
			////And seemingly only when people were around. Our simple think ent always thinks on time
		
		if (!usedlocalresource) {
	  		//We dont have a local tank set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS); //For solarpanelthink, subordinate5 is set to the e(model)
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
			    		//print("Sp Here1\n");
				
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
						//print("Sp Here2\n");
						//print (ftos(f.current_crude_local), " SpF_Crude LocalResource\n");
	  					//print (ftos(f.capacity_crude_local), " SpF_Crude LocalResourceCapacity\n");
					
					if(f.capacity_crude_local > f.current_crude_local) {
							//print(" Sp_Found one\n");
						f.current_crude_local = f.current_crude_local + self.cnt;
						//usedlocalresource = 1; //No real need to set this now, but eh
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print(" Sp_Brokeout\n\n");
		}
		//print(" Sp_Did\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////////////
	}
	
	
	self.nextthink = time + 60;
}

void multitool_shieldgen_think()
{
	float sufficentenergy;
	sufficentenergy = 0;
	if (self.ammount) {
	///////////////
	//We are on
	///////////////
	
	  if (teamplay)
	  {
	  	//self.ammount2 is the energy needed, it is set when this is spawned.
		//For normal shield generators it is set to 10
		if (self.subordinate4.subordinate4.team == COLOR_TEAM1) {
			if (current_energy_team1 >= self.ammount2) {
				current_energy_team1 = current_energy_team1 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM2) {
			if (current_energy_team2 >= self.ammount2) {
				current_energy_team2 = current_energy_team2 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM3) {
			if (current_energy_team3 >= self.ammount2) {
				current_energy_team3 = current_energy_team3 - self.ammount2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM4) {
			if (current_energy_team4 >= self.ammount2) {
				current_energy_team4 = current_energy_team4 - self.ammount2;
				sufficentenergy = 1;
			}
		}
	  }

	  //Can we take from the commons?
	  if ((!sufficentenergy) && (current_energy_world >= self.ammount2)) {
		current_energy_world = current_energy_world - self.ammount2;
		sufficentenergy = 1;
	  }
	  
	  //Can we take from a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  local entity f;
	  local float usedlocalresource;
	  if ((!sufficentenergy) && (numberoflocalenergybatterys)) {
	  	//print (etos(self.subordinate4.subordinate4.realowner), "Building Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "LocalResource Owner\n");
		//print (ftos(self.subordinate4.subordinate4.team), "TEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "TEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), "Energy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.current_energy_local >= self.ammount2) {
						//print("Using\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local - self.ammount2;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficentenergy = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_energy_local >= self.ammount2) {
							//print("Found one\n");
						f.current_energy_local = f.current_energy_local - self.ammount2;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficentenergy = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("Brokeout\n\n");
		}
		//print("Did\n\n");
	  }
	
	///////////////
	//We are on^^^^
	///////////////
	}
	
	if (sufficentenergy && self.ammount) {
		//print("sufficent\n");
		self.subordinate4.solid = SOLID_BSP;
        	self.subordinate4.movetype = MOVETYPE_PUSH;
		self.subordinate4.alpha = 1;
	} else {
		//print("INsufficent\n");
		self.subordinate4.solid = SOLID_NOT;
        	self.subordinate4.movetype = MOVETYPE_NONE;
		self.subordinate4.alpha = 0.001;
	}
	
	self.nextthink = time + 60;
}



void multitool_bridgefuturelight_think()
{
	float sufficentenergy;
	sufficentenergy = 0;
	if (self.ammount) {
	///////////////
	//We are on
	///////////////
	
	  if (teamplay)
	  {
		if (self.subordinate4.subordinate4.team == COLOR_TEAM1) {
			if (current_energy_team1 >= 2) {
				current_energy_team1 = current_energy_team1 - 2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM2) {
			if (current_energy_team2 >= 2) {
				current_energy_team2 = current_energy_team2 - 2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM3) {
			if (current_energy_team3 >= 2) {
				current_energy_team3 = current_energy_team3 - 2;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.subordinate4.team == COLOR_TEAM4) {
			if (current_energy_team4 >= 2) {
				current_energy_team4 = current_energy_team4 - 2;
				sufficentenergy = 1;
			}
		}
	  }

	  //Can we take from the commons?
	  if ((!sufficentenergy) && (current_energy_world >= 2)) {
		current_energy_world = current_energy_world - 2;
		sufficentenergy = 1;
	  }
	  
	  /////////////////////////////////////////////////////////////////////////////////
	  /////////////////////////////////////////////////////////////////////////////////
	  //Can we take from a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  local entity f;
	  local float usedlocalresource;
	  if ((!sufficentenergy) && (numberoflocalenergybatterys)) {
	  	//print (etos(self.subordinate4.subordinate4.realowner), " BrBuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), " BrLocalResource Owner\n");
		//print (ftos(self.subordinate4.subordinate4.team), " BrTEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), " BrTEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), " BrEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.current_energy_local >= 2) {
						//print("BrUsing\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local - 2;
					usedlocalresource = 1;  //Don't have to go into while loop
					sufficentenergy = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_energy_local >= 2) {
							//print("BrFound one\n");
						f.current_energy_local = f.current_energy_local - 2;
						//usedlocalresource = 1; //No reason to set this now
						sufficentenergy = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
				//print("BrBrokeout\n\n");
		}
			//print("BrDid\n\n");
	  }
	  /////////////////////////////////////////////////////////////////////////////////
	  /////////////////////////////////////////////////////////////////////////////////
	
	///////////////
	//We are on^^^^
	///////////////
	}
	
	if (sufficentenergy && self.ammount) {
		//print("sufficent\n");
		self.subordinate4.solid = SOLID_BSP;
        	self.subordinate4.movetype = MOVETYPE_PUSH;
		self.subordinate4.alpha = 1;
	} else {
		//print("INsufficent\n");
		self.subordinate4.solid = SOLID_NOT;
        	self.subordinate4.movetype = MOVETYPE_NONE;
		self.subordinate4.alpha = 0.001;
	}
	
	self.nextthink = time + 60;
}




void multitool_chemicalplant_think()
{
	//print("chemplantthink\n");
	local entity f;
	float sufficentenergy;
	float sufficentcrude;
	sufficentenergy = 0;
	sufficentcrude = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (current_energy_team1 >= CHEMICAL_INPUT_E) {
				current_energy_team1 = current_energy_team1 - CHEMICAL_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (current_energy_team2 >= CHEMICAL_INPUT_E) {
				current_energy_team2 = current_energy_team2 - CHEMICAL_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (current_energy_team3 >= CHEMICAL_INPUT_E) {
				current_energy_team3 = current_energy_team3 - CHEMICAL_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (current_energy_team4 >= CHEMICAL_INPUT_E) {
				current_energy_team4 = current_energy_team4 - CHEMICAL_INPUT_E;
				sufficentenergy = 1;
			}
		}
	}

	//Can we take from the commons?
	if ((!sufficentenergy) && (current_energy_world >= CHEMICAL_INPUT_E)) {
		current_energy_world = current_energy_world - CHEMICAL_INPUT_E;
		sufficentenergy = 1;
	}
	
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	  //subordinate5 is the model
	  //Can we take from a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  //local entity f;
	  local float usedlocalresource;
	  if ((!sufficentenergy) && (numberoflocalenergybatterys)) {
	  	//print (etos(self.subordinate4.realowner), "CBuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "CLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "CTEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "CTEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), "CEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.current_energy_local >= CHEMICAL_INPUT_E) {
						//print("CUsing\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local - CHEMICAL_INPUT_E;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficentenergy = 1;
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_energy_local >= CHEMICAL_INPUT_E) {
							//print("CFound one\n");
						f.current_energy_local = f.current_energy_local - CHEMICAL_INPUT_E;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficentenergy = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("CBrokeout\n\n");
		}
		//print("CDid\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	
	
	
	if (sufficentenergy) { //Energy is sufficent, so now onto the next input: Crude Oil
	  //print("sufficent\n");
	  if (teamplay)
	  {
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (current_crude_team1 >= CHEMICAL_INPUT_C) {
				current_crude_team1 = current_crude_team1 - CHEMICAL_INPUT_C;
				sufficentcrude = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (current_crude_team2 >= CHEMICAL_INPUT_C) {
				current_crude_team2 = current_crude_team2 - CHEMICAL_INPUT_C;
				sufficentcrude = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (current_crude_team3 >= CHEMICAL_INPUT_C) {
				current_crude_team3 = current_crude_team3 - CHEMICAL_INPUT_C;
				sufficentcrude = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (current_crude_team4 >= CHEMICAL_INPUT_C) {
				current_crude_team4 = current_crude_team4 - CHEMICAL_INPUT_C;
				sufficentcrude = 1;
			}
		} else if (current_crude_world >= CHEMICAL_INPUT_C) {
			current_crude_world = current_crude_world - CHEMICAL_INPUT_C;
			sufficentcrude = 1;
		}
	  }
	  
	  //Can we take from the commons?
	  if ((!sufficentcrude) && (current_crude_world >= CHEMICAL_INPUT_C)) {
		current_crude_world = current_crude_world - CHEMICAL_INPUT_C;
		sufficentcrude = 1;
	  }
	  
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	  //subordinate5 is the model
	  //Can we take from a local oil tank?
	  //If we find one we set it as .subordinate8, so we don't have to look again
	  //Becareful how you place these
	  //local entity f;
	  local float usedsecondlocalresource;
	  if ((!sufficentcrude) && (numberoflocaloiltanks)) {
	  	//print (etos(self.subordinate4.realowner), "COILBuilding Owner\n");
		//print (etos(self.subordinate8.subordinate4.realowner), "COILLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "COILTEAM Building\n");
		//print (ftos(self.subordinate8.subordinate4.team), "COILTEAM LocalResource\n");
		//print (ftos(self.subordinate8.current_crude_local), "COILEnergy LocalResource\n");
	  	
		usedsecondlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate8 && self.subordinate8 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate8.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate8.subordinate4.realowner)) )
			{
				if(self.subordinate8.current_crude_local >= CHEMICAL_INPUT_C) {
						//print("COILUsing\n");
					self.subordinate8.current_crude_local = self.subordinate8.current_crude_local - CHEMICAL_INPUT_C;
					usedsecondlocalresource = 1; //Don't have to go into while loop
					sufficentcrude = 1;
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
		
		if (!usedsecondlocalresource) {
	  		//We dont have a local oil tank set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS2);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_crude_local >= CHEMICAL_INPUT_C) {
							//print("COILFound one\n");
						f.current_crude_local = f.current_crude_local - CHEMICAL_INPUT_C;
						//usedsecondlocalresource = 1; //Don't need to set here, just above
						sufficentcrude = 1;
						self.subordinate8 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("COILBrokeout\n\n");
		}
		//print("COILDid\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	
	}
	
	
	
	//Produce
	if (sufficentenergy && sufficentcrude) {
	  if (!self.ammount) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_fuel_team1 = resource_fuel_team1 + CHEMICAL_OUTPUT_A;
					resource_rockets_team1 = resource_rockets_team1 + CHEMICAL_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_fuel_team2 = resource_fuel_team2 + CHEMICAL_OUTPUT_A;
					resource_rockets_team2 = resource_rockets_team2 + CHEMICAL_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_fuel_team3 = resource_fuel_team3 + CHEMICAL_OUTPUT_A;
					resource_rockets_team3 = resource_rockets_team3 + CHEMICAL_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_fuel_team4 = resource_fuel_team4 + CHEMICAL_OUTPUT_A;
					resource_rockets_team4 = resource_rockets_team4 + CHEMICAL_OUTPUT_B;
			} else {
				resource_fuel_world = resource_fuel_world + CHEMICAL_OUTPUT_A;
				resource_rockets_world = resource_rockets_world + CHEMICAL_OUTPUT_B;
			}
		  } else {
			resource_fuel_world = resource_fuel_world + CHEMICAL_OUTPUT_A;
			resource_rockets_world = resource_rockets_world + CHEMICAL_OUTPUT_B;
		  }
	  } else {
	  	//Give to local, subordinate9 is our tank of chemicals
	  	self.subordinate9.resource_fuel_local = self.subordinate9.resource_fuel_local + CHEMICAL_OUTPUT_A;
		self.subordinate9.resource_rockets_local = self.subordinate9.resource_rockets_local + CHEMICAL_OUTPUT_B;
	  }
	}
	
	self.nextthink = time + 60;
}

/////////////////////////
/////////////////////////
//Using forgepieces
/////////////////////////


//First test, then do.
float multitool_use_forgebuilding_nails(float a_amnt, entity myplayer, float testingrun)
{
	float sufficent;
	sufficent = 0;
	//In teamgames forges donate to team, in non team they donate to themselves
	if (teamplay)
	{
		if (myplayer.team == COLOR_TEAM1)
		{
			if (resource_forgeparts_nails_team1 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_nails_team1 = resource_forgeparts_nails_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM2)
		{
			if (resource_forgeparts_nails_team2 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_nails_team2 = resource_forgeparts_nails_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM3)
		{
			if (resource_forgeparts_nails_team3 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_nails_team3 = resource_forgeparts_nails_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM4)
		{
			if (resource_forgeparts_nails_team4 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_nails_team4 = resource_forgeparts_nails_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	} else {
		////////////////////////////////////////////////////////////////////////////////////////
		//In non team games we look for local forges

			local entity f;
			local float mytally;
			mytally = 0;
		
			f = findradius(myplayer.origin, RESOURCELOCAL_RADIUSFINDFORGERCRCS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
			    	//print("HereXX\n");
				if (myplayer == f.subordinate4.realowner)
				{
					if(f.resource_forgeparts_nails_local >= (a_amnt - mytally)) {
						//print("Sufficent\n");
						
						if not (testingrun) f.resource_forgeparts_nails_local = f.resource_forgeparts_nails_local - (a_amnt - mytally);
						
						mytally = (a_amnt - mytally);
						
						sufficent = 1;
						
						break;
					} else if(f.resource_forgeparts_nails_local) {
						//print("Took Some\n");
						
						mytally = mytally + f.resource_forgeparts_nails_local;
						
						if not (testingrun) f.resource_forgeparts_nails_local = 0;
					}
				}
			    }
				
			    f = f.chain;
			}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

//First test, then do.
float multitool_use_forgebuilding_rockets(float a_amnt, entity myplayer, float testingrun)
{
	float sufficent;
	sufficent = 0;
	//In teamgames forges donate to team, in non team they donate to themselves
	if (teamplay)
	{
		if (myplayer.team == COLOR_TEAM1)
		{
			if (resource_forgeparts_rockets_team1 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_rockets_team1 = resource_forgeparts_rockets_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM2)
		{
			if (resource_forgeparts_rockets_team2 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_rockets_team2 = resource_forgeparts_rockets_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM3)
		{
			if (resource_forgeparts_rockets_team3 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_rockets_team3 = resource_forgeparts_rockets_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM4)
		{
			if (resource_forgeparts_rockets_team4 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_rockets_team4 = resource_forgeparts_rockets_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	} else {
		////////////////////////////////////////////////////////////////////////////////////////
		//In non team games we look for local forges

			local entity f;
			local float mytally;
			mytally = 0;
		
			f = findradius(myplayer.origin, RESOURCELOCAL_RADIUSFINDFORGERCRCS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
			    	//print("HereXX\n");
				if (myplayer == f.subordinate4.realowner)
				{
					if(f.resource_forgeparts_rockets_local >= (a_amnt - mytally)) {
						//print("Sufficent\n");
						
						if not (testingrun) f.resource_forgeparts_rockets_local = f.resource_forgeparts_rockets_local - (a_amnt - mytally);
						
						mytally = (a_amnt - mytally);
						
						sufficent = 1;
						
						break;
					} else if(f.resource_forgeparts_rockets_local) {
						//print("Took Some\n");
						
						mytally = mytally + f.resource_forgeparts_rockets_local;
						
						if not (testingrun) f.resource_forgeparts_rockets_local = 0;
					}
				}
			    }
				
			    f = f.chain;
			}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

//First test, then do.
float multitool_use_forgebuilding_cells(float a_amnt, entity myplayer, float testingrun)
{
	float sufficent;
	sufficent = 0;
	//In teamgames forges donate to team, in non team they donate to themselves
	if (teamplay)
	{
		if (myplayer.team == COLOR_TEAM1)
		{
			if (resource_forgeparts_cells_team1 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_cells_team1 = resource_forgeparts_cells_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM2)
		{
			if (resource_forgeparts_cells_team2 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_cells_team2 = resource_forgeparts_cells_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM3)
		{
			if (resource_forgeparts_cells_team3 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_cells_team3 = resource_forgeparts_cells_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (myplayer.team == COLOR_TEAM4)
		{
			if (resource_forgeparts_cells_team4 >= a_amnt)
			{
				if not (testingrun) resource_forgeparts_cells_team4 = resource_forgeparts_cells_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	} else {
		////////////////////////////////////////////////////////////////////////////////////////
		//In non team games we look for local forges

			local entity f;
			local float mytally;
			mytally = 0;
		
			f = findradius(myplayer.origin, RESOURCELOCAL_RADIUSFINDFORGERCRCS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
			    	//print("HereXX\n");
				if (myplayer == f.subordinate4.realowner)
				{
					if(f.resource_forgeparts_cells_local >= (a_amnt - mytally)) {
						//print("Sufficent\n");
						
						if not (testingrun) f.resource_forgeparts_cells_local = f.resource_forgeparts_cells_local - (a_amnt - mytally);
						
						mytally = (a_amnt - mytally);
						
						sufficent = 1;
						
						break;
					} else if(f.resource_forgeparts_cells_local) {
						//print("Took Some\n");
						
						mytally = mytally + f.resource_forgeparts_cells_local;
						
						if not (testingrun) f.resource_forgeparts_cells_local = 0;
					}
				}
			    }
				
			    f = f.chain;
			}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

//This is the routine that should be used
float multitool_use_forgebuilding_materials(entity myplayer, string mysentstring, float myforgenails, float myforgerockets, float myforgecells)
{
	float sufficentnails;
	float sufficentrockets;
	float sufficentcells;
	
	if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts)
		return TRUE; //We ignore this requirement
	
	if (myplayer == world) {
		if (autocvar_g_balance_multitool_ignoreforgepartsforworld)
			return TRUE; //We ignore this requirement
	}
	
	sufficentnails = 0;
	sufficentrockets = 0;
	sufficentcells = 0;
	
	//First test to see if enough resources:
	if (myforgenails) {
		if (multitool_use_forgebuilding_nails(myforgenails, myplayer, TRUE)) {
			sufficentnails = 1;
		}
	} else {
		sufficentnails = 1;
	}
	
	if (myforgerockets) {
		if (multitool_use_forgebuilding_rockets(myforgerockets, myplayer, TRUE)) {
			sufficentrockets = 1;
		}
	} else {
		sufficentrockets = 1;
	}
	
	if (myforgecells) {
		if (multitool_use_forgebuilding_cells(myforgecells, myplayer, TRUE)) {
			sufficentcells = 1;
		}
	} else {
		sufficentcells = 1;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////
	//Take resources
	if (sufficentnails && sufficentrockets && sufficentcells) {
		if (myforgenails) multitool_use_forgebuilding_nails(myforgenails, myplayer, FALSE);
		
		if (myforgerockets) multitool_use_forgebuilding_rockets(myforgerockets, myplayer, FALSE);
		
		if (myforgecells) multitool_use_forgebuilding_cells(myforgecells, myplayer, FALSE);
		
		return TRUE;
	} else {
		if ((clienttype(myplayer) == CLIENTTYPE_REAL)) {
				if (!sufficentnails) {
					mysentstring = strcat(mysentstring,"^x999 forgeparts-nail^7");
				}
				
				if (!sufficentrockets) {
					mysentstring = strcat(mysentstring,"^xE99 forgeparts-rocket^7");
				}
				
				if (!sufficentcells) {
					mysentstring = strcat(mysentstring,"^xC9D forgeparts-cell^7");
				}
				
				sprint(myplayer, strcat(mysentstring,"\n"));
		}
		return FALSE;
	}
}
/////////////////////////
/////////////////////////
//End Using forgepieces
/////////////////////////


/////////////////////////
/////////////////////////
/////////////////////////
////ForgeBuilding stuff
/////////////////////////
/////////////////////////
/////////////////////////
float multitool_forgebuilding_nails(float a_amnt, entity myplayer)
{
	float sufficent;
	sufficent = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			if (resource_nails_team1 >= a_amnt)
			{
				resource_nails_team1 = resource_nails_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			if (resource_nails_team2 >= a_amnt)
			{
				resource_nails_team2 = resource_nails_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_nails_team3 >= a_amnt)
			{
				resource_nails_team3 = resource_nails_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_nails_team4 >= a_amnt)
			{
				resource_nails_team4 = resource_nails_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (!sufficent) {
		if (resource_nails_world >= a_amnt)
		{
			resource_nails_world = resource_nails_world - a_amnt;
			return 1;
		}
	}
	
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate6, so we don't have to look again
	//Becareful how you place these
	//If anything else that makes nails resource is created, add to the ( && (numberoflocalmunitionsfactories))
	local entity f;
	local float usedlocalresource;
	if ((!sufficent) && (numberoflocalmunitionsfactories)) {
	  	//print (etos(self.subordinate4.realowner), "ABuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "ALocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ATEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "ATEAM LocalResource\n");
		//print (ftos(self.subordinate6.resource_nails_local), "AEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.resource_nails_local >= a_amnt) {
						//print("AUsing\n");
					self.subordinate6.resource_nails_local = self.subordinate6.resource_nails_local - a_amnt;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficent = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSFORGEBLDNG);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_nails_local >= a_amnt) {
							//print("AFound one\n");
						f.resource_nails_local = f.resource_nails_local - a_amnt;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficent = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ABrokeout\n\n");
		}
		//print("ADid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	if (!sufficent && teamplay) {
		//Teamplay
		if (self.subordinate4.team == COLOR_TEAM1 ||
		self.subordinate4.team == COLOR_TEAM2 ||
		self.subordinate4.team == COLOR_TEAM3 ||
		self.subordinate4.team == COLOR_TEAM4)
		{
			entity srchplyr;
			for(srchplyr = world; (srchplyr = find(srchplyr, classname, "player")); ) {
			  if (self.subordinate4.team == srchplyr.team) {
				if (srchplyr.multitool_ammocurrent >= a_amnt)
				{
					srchplyr.multitool_ammocurrent = srchplyr.multitool_ammocurrent - a_amnt;
					multitool_thirdpartycallupdateammoon(srchplyr); //Update hud display of ammount if applicable
					return 1;
				}	
			  }
			}
		}
	} else if (!sufficent && !teamplay) {
		if (myplayer)
		if (myplayer != world)
		{
			if (myplayer.multitool_ammocurrent >= a_amnt)
			{
				myplayer.multitool_ammocurrent = myplayer.multitool_ammocurrent - a_amnt;
				multitool_thirdpartycallupdateammoon(myplayer); //Update hud display of ammount if applicable
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

float multitool_forgebuilding_rockets(float a_amnt, entity myplayer)
{
	float sufficent;
	sufficent = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			if (resource_rockets_team1 >= a_amnt)
			{
				resource_rockets_team1 = resource_rockets_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			if (resource_rockets_team2 >= a_amnt)
			{
				resource_rockets_team2 = resource_rockets_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_rockets_team3 >= a_amnt)
			{
				resource_rockets_team3 = resource_rockets_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_rockets_team4 >= a_amnt)
			{
				resource_rockets_team4 = resource_rockets_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (!sufficent) {
		if (resource_rockets_world >= a_amnt)
		{
			resource_rockets_world = resource_rockets_world - a_amnt;
			return 1;
		}
	}
	
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate6, so we don't have to look again
	//Becareful how you place these
	//If anything else that makes rockets resource is created, add to the ( && (numberoflocalmunitionsfactories))
	local entity f;
	local float usedlocalresource;
	if ((!sufficent) && (numberoflocalmunitionsfactories)) {
	  	//print (etos(self.subordinate4.realowner), "ABuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "ALocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ATEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "ATEAM LocalResource\n");
		//print (ftos(self.subordinate6.resource_rockets_local), "AEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.resource_rockets_local >= a_amnt) {
						//print("AUsing\n");
					self.subordinate6.resource_rockets_local = self.subordinate6.resource_rockets_local - a_amnt;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficent = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSFORGEBLDNG);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_rockets_local >= a_amnt) {
							//print("AFound one\n");
						f.resource_rockets_local = f.resource_rockets_local - a_amnt;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficent = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ABrokeout\n\n");
		}
		//print("ADid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	if (!sufficent && teamplay) {
		//Teamplay
		if (self.subordinate4.team == COLOR_TEAM1 ||
		self.subordinate4.team == COLOR_TEAM2 ||
		self.subordinate4.team == COLOR_TEAM3 ||
		self.subordinate4.team == COLOR_TEAM4)
		{
			entity srchplyr;
			for(srchplyr = world; (srchplyr = find(srchplyr, classname, "player")); ) {
			  if (self.subordinate4.team == srchplyr.team) {
				if (srchplyr.multitool_ammocurrentr >= a_amnt)
				{
					srchplyr.multitool_ammocurrentr = srchplyr.multitool_ammocurrentr - a_amnt;
					multitool_thirdpartycallupdateammoon(srchplyr); //Update hud display of ammount if applicable
					return 1;
				}	
			  }
			}
		}
	} else if (!sufficent && !teamplay) {
		if (myplayer)
		if (myplayer != world)
		{
			if (myplayer.multitool_ammocurrentr >= a_amnt)
			{
				myplayer.multitool_ammocurrentr = myplayer.multitool_ammocurrentr - a_amnt;
				multitool_thirdpartycallupdateammoon(myplayer); //Update hud display of ammount if applicable
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

float multitool_forgebuilding_cells(float a_amnt, entity myplayer)
{
	float sufficent;
	sufficent = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			if (resource_cells_team1 >= a_amnt)
			{
				resource_cells_team1 = resource_cells_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			if (resource_cells_team2 >= a_amnt)
			{
				resource_cells_team2 = resource_cells_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_cells_team3 >= a_amnt)
			{
				resource_cells_team3 = resource_cells_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_cells_team4 >= a_amnt)
			{
				resource_cells_team4 = resource_cells_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (!sufficent) {
		if (resource_cells_world >= a_amnt)
		{
			resource_cells_world = resource_cells_world - a_amnt;
			return 1;
		}
	}
	
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Currently there isn't anything that makes cells
	////Can we take from a local factory?
	////If we find one we set it as .subordinate6, so we don't have to look again
	////Becareful how you place these
	//local entity f;
	//local float usedlocalresource;
	//if ((!sufficent) && (numberoflocalmunitionsfactories)) {
	//  	//print (etos(self.subordinate4.realowner), "ABuilding Owner\n");
	//	//print (etos(self.subordinate6.subordinate4.realowner), "ALocalResource Owner\n");
	//	//print (ftos(self.subordinate4.team), "ATEAM Building\n");
	//	//print (ftos(self.subordinate6.subordinate4.team), "ATEAM LocalResource\n");
	//	//print (ftos(self.subordinate6.resource_cells_local), "AEnergy LocalResource\n");
	//  	
	//	usedlocalresource = 0;
	//	//Make sure it exists
	//  	if (self.subordinate6 && self.subordinate6 != world) {
	//		//Make sure it is on our team or owned by us
	//		if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
	//		|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
	//		{
	//			if(self.subordinate6.resource_cells_local >= a_amnt) {
	//					//print("AUsing\n");
	//				self.subordinate6.resource_cells_local = self.subordinate6.resource_cells_local - a_amnt;
	//				usedlocalresource = 1; //Don't have to go into while loop
	//				sufficent = 1;
	//			}
	//		}
	//	}
	//	
	//		//print(vtos(self.origin));
	//	
	//	if (!usedlocalresource) {
	//  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
	//		//We will search
	//		f = findradius(self.origin, RESOURCELOCAL_RADIUSFORGEBLDNG);
  	//		while(f)
  	//		{
	//		    if (f.islocalresourceprovider) {
	//			if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
	//			|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
	//			{
	//				if(f.resource_cells_local >= a_amnt) {
	//						//print("AFound one\n");
	//					f.resource_cells_local = f.resource_cells_local - a_amnt;
	//					//usedlocalresource = 1; //Don't need to set here, just above
	//					sufficent = 1;
	//					self.subordinate6 = f; //Being powered so we'll set it
	//					break;
	//				}
	//			}
	//		    }
	//			
	//		    f = f.chain;
	//		}
	//	
	//		//print("ABrokeout\n\n");
	//	}
	//	//print("ADid\n\n");
	//}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	if (!sufficent && teamplay) {
		//Teamplay
		if (self.subordinate4.team == COLOR_TEAM1 ||
		self.subordinate4.team == COLOR_TEAM2 ||
		self.subordinate4.team == COLOR_TEAM3 ||
		self.subordinate4.team == COLOR_TEAM4)
		{
			entity srchplyr;
			for(srchplyr = world; (srchplyr = find(srchplyr, classname, "player")); ) {
			  if (self.subordinate4.team == srchplyr.team) {
				if (srchplyr.multitool_ammocurrentc >= a_amnt)
				{
					srchplyr.multitool_ammocurrentc = srchplyr.multitool_ammocurrentc - a_amnt;
					multitool_thirdpartycallupdateammoon(srchplyr); //Update hud display of ammount if applicable
					return 1;
				}	
			  }
			}
		}
	} else if (!sufficent && !teamplay) {
		if (myplayer)
		if (myplayer != world)
		{
			if (myplayer.multitool_ammocurrentc >= a_amnt)
			{
				myplayer.multitool_ammocurrentc = myplayer.multitool_ammocurrentc - a_amnt;
				multitool_thirdpartycallupdateammoon(myplayer); //Update hud display of ammount if applicable
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}


void multitool_trigger_forgebuildingcontrol_touch()
{
	if(self.pushltime > time)
		return;
	
	if not(other.iscreature)
		return;
		
	if (other.prisonerlevel == 3 || other.handcuffed) {
		return;
	}
	
	if (!other.BUTTON_USE) {
		return;
	}
	
	if((clienttype(other) == CLIENTTYPE_REAL) || (clienttype(other) == CLIENTTYPE_BOT))
	{
	
	
		self.pushltime = time + 0.5;
		
		//Ammount is used to control on/off of shields.
		if (self.subordinate4.ammount) {
			self.subordinate4.ammount = 0; //.think
			self.subordinate7.solid = SOLID_NOT;
        		self.subordinate7.movetype = MOVETYPE_NONE;
			self.subordinate7.alpha = -1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Forge Disabled\n");

				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/decreasevalue.wav", VOL_BASE * 0.85, ATTN_NORM);
			}		
		} else {
			self.subordinate4.ammount = 1; //.think
			self.subordinate7.solid = SOLID_BSP;
        		self.subordinate7.movetype = MOVETYPE_PUSH;
			self.subordinate7.alpha = 1; //Lock model
			
			if (self.subordinate4.nextthink > (time+3)) {
				self.subordinate4.nextthink = time + 3;
			}
			
			if (clienttype(other) == CLIENTTYPE_REAL) {
				sprint(other, "Forge Enabled\n");
				//the self.thinkent.subordinate5 = the e model
				//Hence, self.subordinate4.subordinate5
				spamsound (self.subordinate4.subordinate5, CH_SHOTS, "misc/menu2.wav", VOL_BASE * 0.85, ATTN_NORM);
			}
		}
	}
}

void spawnfunc_multitool_trigger_forgebuildingcontrol()
{

	EXACTTRIGGER_INIT;
	self.touch = multitool_trigger_forgebuildingcontrol_touch;
}

void multitool_forgebuilding_nails_think()
{
	local entity f;
	local entity myplayer;
	float sufficentinput;
	sufficentinput = 0;
	
	
	//Ammount 3 is used to keep track of bellows
	if (self.ammount3 >= 50) {
			//50 strokes gets you down to almost half the time
			//print("50 strokes\n");
		self.nextthink = time + 35;
		self.ammount3 = 10; //Keep a few for next time (residual heat)
	} else if (self.ammount3) {
			//print("some strokes\n");
		self.nextthink = time + (60 - (self.ammount3*0.5));
		self.ammount3 = 5; //Keep a few 
	} else {
			//print("no strokes\n");
		self.nextthink = time + 60;
		self.ammount3 = 0;
	}
	

	if not (self.ammount)
		return;

	myplayer = self.subordinate4.realowner;
	
	if not (teamplay) {
		if (myplayer == world) {
			return;
		}
		
		if not (myplayer)
			return;
	}

	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
	if (multitool_forgebuilding_nails(FORGEBLD_INPUT_A, myplayer))
	{
		sufficentinput = 1;
	}
	
	
	//Produce
	if (sufficentinput) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_forgeparts_nails_team1 = resource_forgeparts_nails_team1 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_forgeparts_nails_team2 = resource_forgeparts_nails_team2 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_forgeparts_nails_team3 = resource_forgeparts_nails_team3 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_forgeparts_nails_team4 = resource_forgeparts_nails_team4 + FORGEBLD_OUTPUT_A;
			}
		  } else {//Give to local, subordinate9 is our "tank"
	  		self.subordinate9.resource_forgeparts_nails_local = self.subordinate9.resource_forgeparts_nails_local + FORGEBLD_OUTPUT_A;
		  }
	}
}

void multitool_forgebuilding_cells_think()
{
	local entity f;
	local entity myplayer;
	float sufficentinput;
	sufficentinput = 0;
	
	self.nextthink = time + 60;

	if not (self.ammount)
		return;

	myplayer = self.subordinate4.realowner;
	
	if not (teamplay) {
		if (myplayer == world) {
			return;
		}
		
		if not (myplayer)
			return;
	}

	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
	if (multitool_forgebuilding_cells(FORGEBLD_INPUT_A, myplayer))
	{
		sufficentinput = 1;
	}
	
	
	//Produce
	if (sufficentinput) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_forgeparts_cells_team1 = resource_forgeparts_cells_team1 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_forgeparts_cells_team2 = resource_forgeparts_cells_team2 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_forgeparts_cells_team3 = resource_forgeparts_cells_team3 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_forgeparts_cells_team4 = resource_forgeparts_cells_team4 + FORGEBLD_OUTPUT_A;
			}
		  } else {//Give to local, subordinate9 is our "tank"
	  		self.subordinate9.resource_forgeparts_cells_local = self.subordinate9.resource_forgeparts_cells_local + FORGEBLD_OUTPUT_A;
		  }
	}
}

void multitool_forgebuilding_rockets_think()
{
	local entity f;
	local entity myplayer;
	float sufficentinput;
	sufficentinput = 0;
	
	//Ammount 3 is used to keep track of bellows presses
	//This one is not as easy as the other, can only bring it down to 40 sec
	if (self.ammount3 >= 40) {
		self.nextthink = time + 40;
	} else if (self.ammount3) {
		self.nextthink = time + (60 - (self.ammount3*0.5));
	} else {
		self.nextthink = time + 60;
	}
	
	self.ammount3 = 0;
	

	if not (self.ammount)
		return;

	myplayer = self.subordinate4.realowner;
	
	if not (teamplay) {
		if (myplayer == world) {
			return;
		}
		
		if not (myplayer)
			return;
	}

	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
	if (multitool_forgebuilding_rockets(FORGEBLD_INPUT_A, myplayer))
	{
		sufficentinput = 1;
	}
	
	
	//Produce
	if (sufficentinput) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_forgeparts_rockets_team1 = resource_forgeparts_rockets_team1 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_forgeparts_rockets_team2 = resource_forgeparts_rockets_team2 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_forgeparts_rockets_team3 = resource_forgeparts_rockets_team3 + FORGEBLD_OUTPUT_A;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_forgeparts_rockets_team4 = resource_forgeparts_rockets_team4 + FORGEBLD_OUTPUT_A;
			}
		  } else {//Give to local, subordinate9 is our "tank"
	  		self.subordinate9.resource_forgeparts_rockets_local = self.subordinate9.resource_forgeparts_rockets_local + FORGEBLD_OUTPUT_A;
		  }
	}
}

//This one has two sides, one for each type
void multitool_forgebuilding_hammerforge_think()
{
	local entity f;
	local entity myplayer;
	float sufficentinput;
	sufficentinput = 0;
	
	
	
	
	self.nextthink = time + 60;

	if not (self.ammount)
		return;

	myplayer = self.subordinate4.realowner;
	
	if not (teamplay) {
		if (myplayer == world) {
			return;
		}
		
		if not (myplayer)
			return;
	}

	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
	if (multitool_forgebuilding_nails(FORGEBLD_INPUT_B, myplayer))
	{
		sufficentinput = 1;
	}
	
	
	//Produce
	if (sufficentinput) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_forgeparts_nails_team1 = resource_forgeparts_nails_team1 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_forgeparts_nails_team2 = resource_forgeparts_nails_team2 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_forgeparts_nails_team3 = resource_forgeparts_nails_team3 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_forgeparts_nails_team4 = resource_forgeparts_nails_team4 + FORGEBLD_OUTPUT_B;
			}
		  } else {//Give to local, subordinate9 is our "tank"
	  		self.subordinate9.resource_forgeparts_nails_local = self.subordinate9.resource_forgeparts_nails_local + FORGEBLD_OUTPUT_B;
		  }
	}
	
	/////Rockets
	sufficentinput = 0;
	
	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
	if (multitool_forgebuilding_rockets(FORGEBLD_INPUT_B, myplayer))
	{
		sufficentinput = 1;
	}
	
	
	//Produce
	if (sufficentinput) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_forgeparts_rockets_team1 = resource_forgeparts_rockets_team1 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_forgeparts_rockets_team2 = resource_forgeparts_rockets_team2 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_forgeparts_rockets_team3 = resource_forgeparts_rockets_team3 + FORGEBLD_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_forgeparts_rockets_team4 = resource_forgeparts_rockets_team4 + FORGEBLD_OUTPUT_B;
			}
		  } else {//Give to local, subordinate9 is our "tank"
	  		self.subordinate9.resource_forgeparts_rockets_local = self.subordinate9.resource_forgeparts_rockets_local + FORGEBLD_OUTPUT_B;
		  }
	}
	
	
	//Check if there are any furnaces near
	if (numberoffurnaces) {
		//print(vtos(self.origin),"\n");
		entity e;
		float c;
		c = 0;	
		e = findradius(self.origin, 4096);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				if (e.count == 1021) {
					c = c + 1;
					//print("found 1\n");
				}
			}
			e = e.chain;
		}
	
		if (c >= 3) {
			self.nextthink = time + 20;
		} else if (c == 2) {
			self.nextthink = time + 30;
		} else if (c == 1) {
			self.nextthink = time + 40;
		} else {
			self.nextthink = time + 60;
		}
	} else {
		self.nextthink = time + 60;
	}
}

/////////////////////////
/////////////////////////
///End ForgeBuilding stuff
/////////////////////////
/////////////////////////

void multitool_factory_think()
{
	local entity f;
	float sufficentenergy;
	float sufficentfuel;
	sufficentenergy = 0;
	sufficentfuel = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (current_energy_team1 >= FACTORY_INPUT_E) {
				current_energy_team1 = current_energy_team1 - FACTORY_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (current_energy_team2 >= FACTORY_INPUT_E) {
				current_energy_team2 = current_energy_team2 - FACTORY_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (current_energy_team3 >= FACTORY_INPUT_E) {
				current_energy_team3 = current_energy_team3 - FACTORY_INPUT_E;
				sufficentenergy = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (current_energy_team4 >= FACTORY_INPUT_E) {
				current_energy_team4 = current_energy_team4 - FACTORY_INPUT_E;
				sufficentenergy = 1;
			}
		}
	}

	//Can we take from the commons?
	if ((!sufficentenergy) && (current_energy_world >= FACTORY_INPUT_E)) {
		current_energy_world = current_energy_world - FACTORY_INPUT_E;
		sufficentenergy = 1;
	}
	
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	  //subordinate5 is the model
	  //Can we take from a local battery?
	  //If we find one we set it as .subordinate6, so we don't have to look again
	  //Becareful how you place these
	  //local entity f;
	  local float usedlocalresource;
	  if ((!sufficentenergy) && (numberoflocalenergybatterys)) {
	  	//print (etos(self.subordinate4.realowner), "FBuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "FLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "FTEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "FTEAM LocalResource\n");
		//print (ftos(self.subordinate6.current_energy_local), "FEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.current_energy_local >= FACTORY_INPUT_E) {
						//print("FUsing\n");
					self.subordinate6.current_energy_local = self.subordinate6.current_energy_local - FACTORY_INPUT_E;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficentenergy = 1;
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.current_energy_local >= FACTORY_INPUT_E) {
							//print("FFound one\n");
						f.current_energy_local = f.current_energy_local - FACTORY_INPUT_E;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficentenergy = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("FBrokeout\n\n");
		}
		//print("FDid\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	
	
	if (sufficentenergy) {
	  //print("sufficent\n");
	  if (teamplay)
	  {
		if (self.subordinate4.team == COLOR_TEAM1) {
			if (resource_fuel_team1 >= FACTORY_INPUT_C) {
				resource_fuel_team1 = resource_fuel_team1 - FACTORY_INPUT_C;
				sufficentfuel = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2) {
			if (resource_fuel_team2 >= FACTORY_INPUT_C) {
				resource_fuel_team2 = resource_fuel_team2 - FACTORY_INPUT_C;
				sufficentfuel = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3) {
			if (resource_fuel_team3 >= FACTORY_INPUT_C) {
				resource_fuel_team3 = resource_fuel_team3 - FACTORY_INPUT_C;
				sufficentfuel = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4) {
			if (resource_fuel_team4 >= FACTORY_INPUT_C) {
				resource_fuel_team4 = resource_fuel_team4 - FACTORY_INPUT_C;
				sufficentfuel = 1;
			}
		} else if (resource_fuel_world >= FACTORY_INPUT_C) {
			resource_fuel_world = resource_fuel_world - FACTORY_INPUT_C;
			sufficentfuel = 1;
		}
	  }
	  
	  //Can we take from the commons?
	  if ((!sufficentfuel) && (resource_fuel_world >= FACTORY_INPUT_C)) {
		resource_fuel_world = resource_fuel_world - FACTORY_INPUT_C;
		sufficentfuel = 1;
	  }
	  
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	  //subordinate5 is the model
	  //Can we take from a local oil tank?
	  //If we find one we set it as .subordinate8, so we don't have to look again
	  //Becareful how you place these
	  //local entity f;
	  local float usedsecondlocalresource;
	  if ((!sufficentfuel) && (numberoflocaloiltanks)) {
	  	//print (etos(self.subordinate4.realowner), "FFuelBuilding Owner\n");
		//print (etos(self.subordinate8.subordinate4.realowner), "FFuelLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "FFuelTEAM Building\n");
		//print (ftos(self.subordinate8.subordinate4.team), "FFuelTEAM LocalResource\n");
		//print (ftos(self.subordinate8.resource_fuel_local), "FFuelEnergy LocalResource\n");
	  	
		usedsecondlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate8 && self.subordinate8 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate8.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate8.subordinate4.realowner)) )
			{
				if(self.subordinate8.resource_fuel_local >= FACTORY_INPUT_C) {
						//print("FFuelUsing\n");
					self.subordinate8.resource_fuel_local = self.subordinate8.resource_fuel_local - FACTORY_INPUT_C;
					usedsecondlocalresource = 1; //Don't have to go into while loop
					sufficentfuel = 1;
				}
			}
		}
		
			//print(vtos(self.subordinate5.origin));
		
		if (!usedsecondlocalresource) {
	  		//We dont have a local oil tank set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.subordinate5.origin, RESOURCELOCAL_RADIUS2);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_fuel_local >= FACTORY_INPUT_C) {
							//print("FFuelFound one\n");
						f.resource_fuel_local = f.resource_fuel_local - FACTORY_INPUT_C;
						//usedsecondlocalresource = 1; //Don't need to set here, just above
						sufficentfuel = 1;
						self.subordinate8 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("FFuelBrokeout\n\n");
		}
		//print("FFuelDid\n\n");
	  }
	  ////////////////////////////////////////////////////////////////////////////////////////
	  ////////////////////////////////////////////////////////////////////////////////////////
	  	
	}
	
	
	//Produce
	if (sufficentenergy && sufficentfuel) {
	  if (!self.ammount) {
	  	if (teamplay)
	  	{
			if (self.subordinate4.team == COLOR_TEAM1) {
					resource_nails_team1 = resource_nails_team1 + FACTORY_OUTPUT_A;
					resource_shells_team1 = resource_shells_team1 + FACTORY_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM2) {
					resource_nails_team2 = resource_nails_team2 + FACTORY_OUTPUT_A;
					resource_shells_team2 = resource_shells_team2 + FACTORY_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM3) {
					resource_nails_team3 = resource_nails_team3 + FACTORY_OUTPUT_A;
					resource_shells_team3 = resource_shells_team3 + FACTORY_OUTPUT_B;
			} else if (self.subordinate4.team == COLOR_TEAM4) {
					resource_nails_team4 = resource_nails_team4 + FACTORY_OUTPUT_A;
					resource_shells_team4 = resource_shells_team4 + FACTORY_OUTPUT_B;
			} else {
				resource_nails_world = resource_nails_world + FACTORY_OUTPUT_A;
				resource_shells_world = resource_shells_world + FACTORY_OUTPUT_B;
			}
		  } else {
			resource_nails_world = resource_nails_world + FACTORY_OUTPUT_A;
			resource_shells_world = resource_shells_world + FACTORY_OUTPUT_B;
		  }
	  } else {
	  	//Give to local, subordinate9 is our "tank"
	  	self.subordinate9.resource_nails_local = self.subordinate9.resource_nails_local + FACTORY_OUTPUT_A;
		self.subordinate9.resource_shells_local = self.subordinate9.resource_shells_local + FACTORY_OUTPUT_B;
	  }
	}
	
	
	//Check if there are any furnaces near
	if (numberoffurnaces) {
		//print(vtos(self.origin),"\n");
		entity e;
		float c;
		c = 0;	
		e = findradius(self.origin, 4096);
		while(e)
		{
			if (e.classname == "bldhitbx") {
				//print("found class\n");
				if (e.count == 1021) {
					c = c + 1;
					//print("found 1\n");
				}
			}
			e = e.chain;
		}
	
		if (c >= 3) {
			self.nextthink = time + 20;
		} else if (c == 2) {
			self.nextthink = time + 30;
		} else if (c == 1) {
			self.nextthink = time + 40;
		} else {
			self.nextthink = time + 60;
		}
	} else {
		self.nextthink = time + 60;
	}
}

void multitool_ammodepot_fire()
{
    //print("FIRE\n");
    vector fl_org;

    self.enemy.vehicle_ammo1_current = min(self.enemy.vehicle_ammo1_current + self.shot_dmg, self.enemy.vehicle_ammo1_max);
    self.enemy.vehicle_ammo2_current = min(self.enemy.vehicle_ammo2_current + self.shot_dmg, self.enemy.vehicle_ammo2_max);
    
    self.enemy.ammo = min(self.enemy.ammo + self.shot_dmg,self.enemy.ammo_max);
    fl_org = 0.5 * (self.enemy.absmin + self.enemy.absmax);
    te_smallflash(fl_org);
}

float multitool_ammodepot_nailsrockets(float a_amnt, float r_amnt)
{
	//print("ThinkNR\n");
	
	//print(ftos(self.subordinate4.team),"\n");
	local entity mynailsfactory;
	local entity myrocketsfactory;
	
	mynailsfactory = world;
	myrocketsfactory = world;
	
	local float sufficentnailsteam1, sufficentnailsteam2, sufficentnailsteam3, sufficentnailsteam4, sufficentnailsworld;
	local float sufficentrocketsteam1, sufficentrocketsteam2, sufficentrocketsteam3, sufficentrocketsteam4, sufficentrocketsworld;
	local float sufficentnails;
	local float sufficentrockets;
	sufficentnailsteam1 = 0;
	sufficentnailsteam2 = 0;
	sufficentnailsteam3 = 0;
	sufficentnailsteam4 = 0;
	sufficentnailsworld = 0;
	sufficentrocketsteam1 = 0;
	sufficentrocketsteam2 = 0; 
	sufficentrocketsteam3 = 0;
	sufficentrocketsteam4 = 0;
	sufficentrocketsworld = 0;
	sufficentnails = 0;
	sufficentrockets = 0;
	
	//First we check if we have the resources and where.
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			//print("RRR\n");
			if (resource_nails_team1 >= a_amnt)
			{
				sufficentnailsteam1 = 1;
			}
			
			if (resource_rockets_team1 >= r_amnt)
			{
				sufficentrocketsteam1 = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			//print("BBB\n");
			if (resource_nails_team2 >= a_amnt)
			{
				sufficentnailsteam2 = 1;
			}
			
			if (resource_rockets_team2 >= r_amnt)
			{
				sufficentrocketsteam2 = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_nails_team3 >= a_amnt)
			{
				sufficentnailsteam3 = 1;
			}
			
			if (resource_rockets_team3 >= r_amnt)
			{
				sufficentrocketsteam3 = 1;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_nails_team4 >= a_amnt)
			{
				sufficentnailsteam4 = 1;
			}
			
			if (resource_rockets_team4 >= r_amnt)
			{
				sufficentrocketsteam4 = 1;
			}
		}
	}
	
	//Check world
	if (resource_nails_world >= a_amnt)
	{
		sufficentnailsworld = 1;
	}
	
	if (resource_rockets_world >= r_amnt)
	{
		sufficentrocketsworld = 1;
	}
	
	
	//Then we try to use them
	if ((sufficentnailsteam1
	|| sufficentnailsteam2
	|| sufficentnailsteam3
	|| sufficentnailsteam4
	|| sufficentnailsworld)
	&& (sufficentrocketsteam1
	|| sufficentrocketsteam2
	|| sufficentrocketsteam3
	|| sufficentrocketsteam4
	|| sufficentrocketsworld))
	{
		if (sufficentnailsteam1) {
			resource_nails_team1 = resource_nails_team1 - a_amnt;
			sufficentnails = 1;	
		} else if (sufficentnailsteam2) {
			resource_nails_team2 = resource_nails_team2 - a_amnt;
			sufficentnails = 1;
		} else if (sufficentnailsteam3) {
			resource_nails_team3 = resource_nails_team3 - a_amnt;
			sufficentnails = 1;
		} else if (sufficentnailsteam4) {
			resource_nails_team4 = resource_nails_team4 - a_amnt;
			sufficentnails = 1;
		} else if (sufficentnailsworld) {
			resource_nails_world = resource_nails_world - a_amnt;
			sufficentnails = 1;
		}
	
		if (sufficentrocketsteam1) {
			resource_rockets_team1 = resource_rockets_team1 - r_amnt;
			sufficentrockets = 1;
		} else if (sufficentrocketsteam2) {
			resource_rockets_team2 = resource_rockets_team2 - r_amnt;
			sufficentrockets = 1;
		} else if (sufficentrocketsteam3) {
			resource_rockets_team3 = resource_rockets_team3 - r_amnt;
			sufficentrockets = 1;
		} else if (sufficentrocketsteam4) {
			resource_rockets_team4 = resource_rockets_team4 - r_amnt;
			sufficentrockets = 1;
		} else if (sufficentrocketsworld) {
			resource_rockets_world = resource_rockets_world - r_amnt;
			sufficentrockets = 1;
		}
	
	}
	
	//If successful we leave
	if (sufficentnails && sufficentrockets) {
		return 1;
	}
	
	//Since we didn't have enough, let's try locals
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate6, so we don't have to look again
	//Becareful how you place these
	//subordinate6 is used for nails as seen below, suborinate10 will be for rockets
	local entity f;
	local float usedlocalresource;
	if ((!sufficentnails) && (numberoflocalmunitionsfactories)) {
	  	//print (etos(self.subordinate4.realowner), "ABuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "ALocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ATEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "ATEAM LocalResource\n");
		//print (ftos(self.subordinate6.resource_nails_local), "AEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.resource_nails_local >= a_amnt) {
						//print("AUsing\n");
					mynailsfactory = self.subordinate6; //Will take later
					usedlocalresource = 1; //Don't have to go into while loop
					sufficentnails = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSAMMODEPOT);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_nails_local >= a_amnt) {
							//print("AFound one\n");
						mynailsfactory = f; //Will take later
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficentnails = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ABrokeout\n\n");
		}
		//print("ADid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	//Can we leave now?
	if (sufficentnails && sufficentrockets) {
		return 1;
	}
	
	//Lets see if with the nails from a locality, we have enough if we take the rocket from team or global
	
	if (sufficentrocketsteam1) {
		resource_rockets_team1 = resource_rockets_team1 - r_amnt;
		sufficentrockets = 1;
	} else if (sufficentrocketsteam2) {
		resource_rockets_team2 = resource_rockets_team2 - r_amnt;
		sufficentrockets = 1;
	} else if (sufficentrocketsteam3) {
		resource_rockets_team3 = resource_rockets_team3 - r_amnt;
		sufficentrockets = 1;
	} else if (sufficentrocketsteam4) {
		resource_rockets_team4 = resource_rockets_team4 - r_amnt;
		sufficentrockets = 1;
	} else if (sufficentrocketsworld) {
		resource_rockets_world = resource_rockets_world - r_amnt;
		sufficentrockets = 1;
	}
	
	
	//How about now?
	if (sufficentnails && sufficentrockets) {
		//Yes? Ok it must be global for rockets and local for factory
		if (mynailsfactory) {
			if (mynailsfactory != world) {
				//print("N From Factory\n");
				mynailsfactory.resource_nails_local = mynailsfactory.resource_nails_local - a_amnt;
				return 1;
			}
		}
	}
	
	//No? We must need rockets too, from a locality
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate10, so we don't have to look again
	//Becareful how you place these
	//subordinate10 is used for rockets as seen below, suborinate10 will be for rockets
	//local entity f;
	local float usedsecondlocalresource;
	if ((!sufficentrockets) && (numberoflocalchemplants)) {
	  	//print (etos(self.subordinate4.realowner), "ARBuilding Owner\n");
		//print (etos(self.subordinate10.subordinate4.realowner), "ARLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ARTEAM Building\n");
		//print (ftos(self.subordinate10.subordinate4.team), "ARTEAM LocalResource\n");
		//print (ftos(self.subordinate10.resource_rockets_local), "AREnergy LocalResource\n");
	  	
		usedsecondlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate10 && self.subordinate10 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate10.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate10.subordinate4.realowner)) )
			{
				if(self.subordinate10.resource_rockets_local >= r_amnt) {
						//print("ARUsing\n");
					myrocketsfactory = self.subordinate10; //Will take later
					usedsecondlocalresource = 1; //Don't have to go into while loop
					sufficentrockets = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedsecondlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSAMMODEPOT);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_rockets_local >= r_amnt) {
							//print("ARFound one\n");
						myrocketsfactory = f; //Will take later
						//usedsecondlocalresource = 1; //Don't need to set here, just above
						sufficentrockets = 1;
						self.subordinate10 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ARBrokeout\n\n");
		}
		//print("ARDid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	if (sufficentnails && sufficentrockets) {
		if (mynailsfactory) {
		 	if (mynailsfactory != world) {
				//print("Nails From Factory\n");
				mynailsfactory.resource_nails_local = mynailsfactory.resource_nails_local - a_amnt;
				
				if (myrocketsfactory) {
					if (myrocketsfactory != world) {
						//print("Rockets From ChemPlant\n");
						myrocketsfactory.resource_rockets_local = myrocketsfactory.resource_rockets_local - r_amnt;
						return 1; //Yay, good!
					}
				}
			}
		}
	}
	
	return 0;
}

float multitool_ammodepot_nails(float a_amnt)
{
	float sufficent;
	sufficent = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			if (resource_nails_team1 >= a_amnt)
			{
				resource_nails_team1 = resource_nails_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			if (resource_nails_team2 >= a_amnt)
			{
				resource_nails_team2 = resource_nails_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_nails_team3 >= a_amnt)
			{
				resource_nails_team3 = resource_nails_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_nails_team4 >= a_amnt)
			{
				resource_nails_team4 = resource_nails_team4 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (!sufficent) {
		if (resource_nails_world >= a_amnt)
		{
			resource_nails_world = resource_nails_world - a_amnt;
			return 1;
		}
	}
	
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate6, so we don't have to look again
	//Becareful how you place these
	local entity f;
	local float usedlocalresource;
	if ((!sufficent) && (numberoflocalmunitionsfactories)) {
	  	//print (etos(self.subordinate4.realowner), "ABuilding Owner\n");
		//print (etos(self.subordinate6.subordinate4.realowner), "ALocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ATEAM Building\n");
		//print (ftos(self.subordinate6.subordinate4.team), "ATEAM LocalResource\n");
		//print (ftos(self.subordinate6.resource_nails_local), "AEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate6 && self.subordinate6 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate6.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate6.subordinate4.realowner)) )
			{
				if(self.subordinate6.resource_nails_local >= a_amnt) {
						//print("AUsing\n");
					self.subordinate6.resource_nails_local = self.subordinate6.resource_nails_local - a_amnt;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficent = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSAMMODEPOT);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_nails_local >= a_amnt) {
							//print("AFound one\n");
						f.resource_nails_local = f.resource_nails_local - a_amnt;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficent = 1;
						self.subordinate6 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ABrokeout\n\n");
		}
		//print("ADid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	if (sufficent) {
	  	return 1;
	}
	
	
	return 0;
}

float multitool_ammodepot_shells(float a_amnt)
{
	float sufficent;
	sufficent = 0;
	if (teamplay)
	{
		if (self.subordinate4.team == COLOR_TEAM1)
		{
			if (resource_shells_team1 >= a_amnt)
			{
				resource_shells_team1 = resource_shells_team1 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM2)
		{
			if (resource_shells_team2 >= a_amnt)
			{
				resource_shells_team2 = resource_shells_team2 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM3)
		{
			if (resource_shells_team3 >= a_amnt)
			{
				resource_shells_team3 = resource_shells_team3 - a_amnt;
				return 1;
			}
			else
			{
				sufficent = 0;
			}
		} else if (self.subordinate4.team == COLOR_TEAM4)
		{
			if (resource_shells_team4 >= a_amnt)
			{
				resource_shells_team4 = resource_shells_team4 - a_amnt;
				return 4;
			}
			else
			{
				sufficent = 0;
			}
		}
	}
	
	if (!sufficent) {
		if (resource_shells_world >= a_amnt)
		{
			resource_shells_world = resource_shells_world - a_amnt;
			return 1;
		}
	}
	
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	//Can we take from a local factory?
	//If we find one we set it as .subordinate8, so we don't have to look again
	//Becareful how you place these
	local entity f;
	local float usedlocalresource;
	if ((!sufficent) && (numberoflocalmunitionsfactories)) {
	  	//print (etos(self.subordinate4.realowner), "ASBuilding Owner\n");
		//print (etos(self.subordinate8.subordinate4.realowner), "ASLocalResource Owner\n");
		//print (ftos(self.subordinate4.team), "ASTEAM Building\n");
		//print (ftos(self.subordinate8.subordinate4.team), "ASTEAM LocalResource\n");
		//print (ftos(self.subordinate8.resource_shells_local), "ASEnergy LocalResource\n");
	  	
		usedlocalresource = 0;
		//Make sure it exists
	  	if (self.subordinate8 && self.subordinate8 != world) {
			//Make sure it is on our team or owned by us
			if ( (teamplay && (self.subordinate4.team == self.subordinate8.subordinate4.team))
			|| (!teamplay && (self.subordinate4.realowner == self.subordinate8.subordinate4.realowner)) )
			{
				if(self.subordinate8.resource_shells_local >= a_amnt) {
						//print("AUsing\n");
					self.subordinate8.resource_shells_local = self.subordinate8.resource_shells_local - a_amnt;
					usedlocalresource = 1; //Don't have to go into while loop
					sufficent = 1;
				}
			}
		}
		
			//print(vtos(self.origin));
		
		if (!usedlocalresource) {
	  		//We dont have a local battery set, or it has been destroyed, or changed ownership,
			//We will search
			f = findradius(self.origin, RESOURCELOCAL_RADIUSAMMODEPOT);
  			while(f)
  			{
			    if (f.islocalresourceprovider) {
				if ( (teamplay && (self.subordinate4.team == f.subordinate4.team))
				|| (!teamplay && (self.subordinate4.realowner == f.subordinate4.realowner)) )
				{
					if(f.resource_shells_local >= a_amnt) {
							//print("ASFound one\n");
						f.resource_shells_local = f.resource_shells_local - a_amnt;
						//usedlocalresource = 1; //Don't need to set here, just above
						sufficent = 1;
						self.subordinate8 = f; //Being powered so we'll set it
						break;
					}
				}
			    }
				
			    f = f.chain;
			}
		
			//print("ASBrokeout\n\n");
		}
		//print("ASDid\n\n");
	}
	////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////
	
	if (sufficent) {
	  	return 1;
	}
	
	return 0;
}

void multitool_ammodepotthink()
{
	local entity eburn;
	eburn = findradius(self.origin, self.count);
	while(eburn)
	{
		if not(eburn == world)
		if not(eburn.deadflag != DEAD_NO)
		{
		
			if ((eburn.netname == "T27")
			|| (eburn.netname == "TankIV")
			|| (eburn.netname == "TankA7V")
			|| (eburn.netname == "Spiderbot")
			|| (eburn.netname == "LL48")
			|| (eburn.netname == "LL40")
			|| (eburn.netname == "LL37")
			|| (eburn.netname == "LL24")
			|| (eburn.netname == "LL20")
			|| (eburn.netname == "Raptor")
			|| (eburn.netname == "BlackHawk")
			|| (eburn.netname == "Challenger")
			|| (eburn.netname == "Cruizer")
			|| (eburn.netname == "PickupTruck")
			|| (eburn.netname == "Wakizashi")
			|| (eburn.netname == "Sportster")
			|| (eburn.netname == "Nieuport")
			|| (eburn.netname == "Fokker")
			|| (eburn.netname == "Sopwith")
			|| (eburn.netname == "Eindecker")
			|| (eburn.netname == "MechMAX")
			|| (eburn.netname == "LightAPC")
			|| (eburn.netname == "SiegeMortar")
			|| (eburn.netname == "CharMortar")
			)
			{
				if ((eburn.vehicle_ammo1_current >= eburn.vehicle_ammo1_max)
				&& (eburn.vehicle_ammo2_current >= eburn.vehicle_ammo2_max))
				{
					//Do nothing
				}
				else
				{
					if((eburn.netname == "MechMAX")
					&& (eburn.spawnflags & 64))
					{
						if (multitool_ammodepot_shells(10))
						{
							self.enemy = eburn;
							self.shot_dmg = 10;
							multitool_ammodepot_fire();
						}
					} else if ((eburn.netname == "SiegeMortar")
					|| (eburn.netname == "CharMortar"))
					{
						if (multitool_ammodepot_nailsrockets(0,10))
						{
							self.enemy = eburn;
							self.shot_dmg = 10;
							multitool_ammodepot_fire();
						}
					} else {
						if (multitool_ammodepot_nailsrockets(10,10))
						{
							self.enemy = eburn;
							self.shot_dmg = 10;
							multitool_ammodepot_fire();
						}
					}
				}	
			} else if(
			(eburn.netname == "R22Heli")
			|| (eburn.netname == "H125Heli")
			|| (eburn.netname == "Submersible")
			|| (eburn.netname == "SpeedBoat")
			|| (eburn.netname == "AeroCommander")
			|| (eburn.netname == "Browning50Gun")
			|| (eburn.netname == "GAU19Gun")
			|| (eburn.netname == "LewisGun")
			|| (eburn.netname == "M134Gun")
			|| (eburn.netname == "Maxim")
			|| (eburn.netname == "Gatling1877Gun")
			|| (eburn.netname == "RpkGun")
			|| (eburn.netname == "RpdGun")
			|| (eburn.netname == "PkmGun")
			|| (eburn.netname == "M249ParaGun")
			|| (eburn.netname == "HotchkissM1914Gun")
			|| (eburn.netname == "SpaduGun")
			|| (eburn.netname == "T17mmGun")
			|| (eburn.netname == "ScorpionBallista")
			)
			{
				//Nails only
				if ((eburn.vehicle_ammo1_current >= eburn.vehicle_ammo1_max)
				&& (eburn.vehicle_ammo2_current >= eburn.vehicle_ammo2_max))
				{
					//Do nothing
				}
				else
				{
					if (multitool_ammodepot_nails(1))
					{
						self.enemy = eburn;
						self.shot_dmg = 10;
						multitool_ammodepot_fire();
					}
				}
			}	
		}
	eburn = eburn.chain;
	}
	self.nextthink = time + 1;
		
}

float W_MultiTool_NeedManualReload() {
	if  (autocvar_g_manualreload && (autocvar_g_balance_multitool_reload_ammo && self.clip_load < autocvar_g_balance_multitool_ammo))
	{
		if (!self.multitool_click && (self.BUTTON_ATCK)) {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.35, ATTN_NORM); //Not 0.25: Heavier Firing Pin
			self.multitool_click = 1;
		}
		else if not(self.BUTTON_ATCK)
		{
			self.multitool_click = 0;
		}
		return 1;
	} else {
		return 0;
	}
	
}
void spawnfunc_item_food_grapes (void);
void spawnfunc_turret_machinegun();
void spawnfunc_turret_plasma();
void spawnfunc_turret_mlrs();
void spawnfunc_turret_hellion();
void spawnfunc_turret_flac();
void spawnfunc_turret_autoshlac();
void spawnfunc_turret_hk();
void spawnfunc_turret_magichk();
void spawnfunc_turret_magichellion();
void spawnfunc_turret_magicmlrs();
void spawnfunc_turret_magicmachinegun();
void spawnfunc_turret_magicflac();
void spawnfunc_turret_magicplasma();
void spawnfunc_vehicle_fokker();
void spawnfunc_vehicle_eindecker();
void spawnfunc_vehicle_sopwith();
void spawnfunc_vehicle_nieuport();
void spawnfunc_vehicle_farman();
void spawnfunc_vehicle_raptor();
void spawnfunc_vehicle_mraptor();
void spawnfunc_vehicle_bumblebee();
void spawnfunc_vehicle_tankll48();
void spawnfunc_vehicle_tankll40();
void spawnfunc_vehicle_tankll37();
void spawnfunc_vehicle_tankll24_heat();
void spawnfunc_vehicle_tankll24_raa();
void spawnfunc_vehicle_tankll24_aa();
void spawnfunc_vehicle_tankll24_ai();
void spawnfunc_vehicle_tankll24();
void spawnfunc_vehicle_tankt27();
void spawnfunc_vehicle_tankiv();
void spawnfunc_vehicle_tanka7v();
void spawnfunc_vehicle_mechmax();
void spawnfunc_vehicle_mechbst();
void spawnfunc_vehicle_turretll20();
void spawnfunc_vehicle_turretll20_aa();
void spawnfunc_vehicle_turretll20_heat();
void spawnfunc_vehicle_turretll20_ai();
void spawnfunc_vehicle_turretll20_raa();
void spawnfunc_vehicle_turretll20_cannon();
void spawnfunc_vehicle_turretll20_grail();
void spawnfunc_vehicle_turretll20_t17mm();
void spawnfunc_vehicle_sparrow();
void spawnfunc_vehicle_lightapc_deluge();
void spawnfunc_vehicle_lightapc_shlac();
void spawnfunc_vehicle_lightapc_grail();
void spawnfunc_vehicle_lightapc_autonex();
void spawnfunc_vehicle_lightapc_browning50();
void spawnfunc_vehicle_lightapc_t17mm();
void spawnfunc_vehicle_lightapc_gau19();
void spawnfunc_vehicle_lightapc_m134();
void spawnfunc_vehicle_lightapc();
void spawnfunc_vehicle_bulldozer();
void spawnfunc_mountedgun_scorpion();
void spawnfunc_mountedgun_charbelcher();
void spawnfunc_mountedgun_siegemortar();
void spawnfunc_mountedgun_batteringram();
void spawnfunc_mountedgun_hotchkissm1914();
void spawnfunc_mountedgun_lewis();
void spawnfunc_mountedgun_maxim();
void spawnfunc_mountedgun_spadu();
void spawnfunc_mountedgun_deluge();
void spawnfunc_mountedgun_shlac();
void spawnfunc_mountedgun_autonex();
void spawnfunc_mountedgun_grail();
void spawnfunc_mountedgun_bpcannon();
void spawnfunc_mountedgun_lasercannon_red();
void spawnfunc_mountedgun_browning50();
void spawnfunc_mountedgun_m134();
void spawnfunc_mountedgun_gau19();
void spawnfunc_mountedgun_t17mm();
void spawnfunc_func_ladder();
void spawnfunc_func_door();
void spawnfunc_func_door_rotating();
void vehicles_replenishAmmo(entity player, entity vehic, .float ammo_type, .float vh_ammocurrent, .float vh_ammomax, float ammo_use, float ammo_convert);
float vehicles_evaldamage(float damage, float deathtype);


//Simply adds dynamic light forced if applicable
void spawnfunc_multitool_func_door()
{
	if (autocvar_g_balance_multitoolutilitool_noforcedlight) {
		//Do nothing
	} else {
		if (!(self.effects & EF_DYNAMICMODELLIGHT)) self.effects += EF_DYNAMICMODELLIGHT;
	}
	spawnfunc_func_door();
}

//Simply adds dynamic light forced if applicable
void spawnfunc_multitool_func_door_rotating()
{
	if (autocvar_g_balance_multitoolutilitool_noforcedlight) {
		//Do nothing
	} else {
		if (!(self.effects & EF_DYNAMICMODELLIGHT)) self.effects += EF_DYNAMICMODELLIGHT;
	}
	spawnfunc_func_door_rotating();
}


void multitool_scaffold_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
	if(self.vehicle_health <= 0)
	{
		//print("no health\n");
		self.event_damage       = func_null;
   		self.takedamage         = DAMAGE_NO;
    		self.touch              = func_null;
    		self.think              = func_null;
    		self.deadflag           = DEAD_DEAD;
    		self.solid      = SOLID_NOT;
		
		if(sound_allowed(MSG_BROADCAST, attacker))
            		spamsound (self, CH_PAIN, "object/impact_stone_3.ogg", VOL_BASE, ATTN_NORM);
		
		if (self.multitool_ammocurrent) {
			if (teamplay) {
				if(attacker.team == self.subordinate.owner.team)
				{
					if (self.subordinate.owner)
					if (self.subordinate.owner != world)
					{
						sprint(self.subordinate.owner, sprintf(_("^x000%.0f Converted Nails^7 have been returned to you\n"), self.multitool_ammocurrent));
						self.subordinate.owner.multitool_ammocurrent = self.subordinate.owner.multitool_ammocurrent + self.multitool_ammocurrent;
						self.multitool_ammocurrent = 0;
					}
				}
			} else {
				if(attacker == self.subordinate.owner)
				{
					if (self.subordinate.owner)
					if (self.subordinate.owner != world)
					{
						sprint(self.subordinate.owner, sprintf(_("^x000%.0f Converted Nails^7 have been returned to you\n"), self.multitool_ammocurrent));
						self.subordinate.owner.multitool_ammocurrent = self.subordinate.owner.multitool_ammocurrent + self.multitool_ammocurrent;
						self.multitool_ammocurrent = 0;	
					}
				}
			}
		}
		
		remove_safely(self);
	}
	if(
	((self.subordinate.count >= 500 && self.subordinate.count <= 549) && (self.vehicle_health >= 1500))
	|| ((self.subordinate.count <= -600 && self.subordinate.count > -1000) && (self.vehicle_health >= 1475))
	|| ((self.subordinate.count == 1013 || self.subordinate.count == 1014 || self.subordinate.count == 1038) && (self.vehicle_health >= 1425))
	|| ((self.subordinate.count >= 1500 && self.subordinate.count <= 1560) && (self.vehicle_health >= 1400))
	|| ((self.subordinate.count >= 1520 && self.subordinate.count <= 1529) && (self.vehicle_health >= 1100))
	|| ((self.subordinate.count == 1501) && (self.vehicle_health >= 1275))
	|| ((self.subordinate.count == 501) && (self.vehicle_health >= 1075))
	|| ((self.subordinate.count == 502) && (self.vehicle_health >= 1080))
	|| ((self.subordinate.count == 503 || self.subordinate.count == 1502) && (self.vehicle_health >= 1070))
	|| ((self.subordinate.count >= 700 && self.subordinate.count <= MTB64BOUNDLAST) && (self.vehicle_health >= 1070))
	|| ((self.subordinate.count >= MTB64UBOUNDFIRST && self.subordinate.count <= MTB64UBOUNDLAST) && (self.vehicle_health >= 1065))
	|| (self.vehicle_health >= 2500)
	)
	{
		self.subordinate.think = multitool_spawner;
		self.subordinate.nextthink = time;
		remove_safely(self);
	} else {
		self.dmg_time = time;
	
		if((deathtype == WEP_FLASHLIGHT)
		|| (deathtype == WEP_WARHAMMERSPIKED)
		|| (deathtype == WEP_WARHAMMERSPIKED | HITTYPE_SECONDARY)
		|| (deathtype == WEP_CLAWHAMMER)
		|| (deathtype == WEP_CLAWHAMMER | HITTYPE_SECONDARY)
		|| (deathtype == WEP_ELVENHAMMER)
		|| (deathtype == WEP_ELVENHAMMER | HITTYPE_SECONDARY)
		|| (deathtype == WEP_KRIEGSHAMMER)
		|| (deathtype == WEP_KRIEGSHAMMER | HITTYPE_SECONDARY)
		|| (deathtype == WEP_WARMALLET)
		|| (deathtype == WEP_GREYIRONMALLET)
		|| (deathtype == WEP_KIDUCHI)
		|| (deathtype == WEP_KIDUCHI | HITTYPE_SECONDARY)
		|| (deathtype == WEP_STAFFFLAME)
		|| (deathtype == WEP_STAFFMAGI)
		|| (deathtype == WEP_ELVENSTAFF)
		|| (deathtype == WEP_TETSUBO)
		|| (deathtype == WEP_CUDGEL)
		|| (deathtype == WEP_BRONZECUDGEL)
		|| (deathtype == WEP_BAT)
		|| (deathtype == WEP_QUARTERSTAFF)
		|| (deathtype == WEP_INFANTRYSTAFF)
		|| (deathtype == WEP_SPIKEDCLUB)
		|| (deathtype == WEP_SPIKEDCUDGEL)
		|| (deathtype == WEP_TORCH)
		|| (deathtype == WEP_MULTITOOL)
		|| (deathtype == WEP_SHOTGUN | HITTYPE_SECONDARY))
		{
			if (autocvar_g_balance_multitool_nobuildtime == 1) {
				self.vehicle_health += 2500;
			} else {
				self.vehicle_health += damage;
			}
			
			float r;
			r = random() * 5;
			if (r > 4) {
				spamsound (self, CH_PAIN, "object/impact_metal_5.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 3) {
				spamsound (self, CH_PAIN, "object/impact_metal_4.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 2) {
				spamsound (self, CH_PAIN, "object/impact_metal_3.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 1) {
				spamsound (self, CH_PAIN, "object/impact_metal_2.ogg", VOL_BASE, ATTN_NORM);
			} else {
				spamsound (self, CH_PAIN, "object/impact_metal_1.ogg", VOL_BASE, ATTN_NORM);
			}
		} else {
			if (deathtype == WEP_CROWBAR) {
				damage = damage * autocvar_g_balance_crowbar_primary_scaffolddamage_multi;
			} else if (deathtype == WEP_IRONCROW) {
				damage = damage * autocvar_g_balance_ironcrow_primary_scaffolddamage_multi;
			} else {
				damage = vehicles_evaldamage(damage, deathtype);
			}
			
			self.vehicle_health -= damage;
			
			if(self.pushltime < time)  // prevent "snorring" sound lots of hits
			{
				float r;
				r = random() * 5;
				if (r > 4) {
					spamsound (self, CH_PAIN, "object/impact_wood_5.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 3) {
					spamsound (self, CH_PAIN, "object/impact_wood_4.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 2) {
					spamsound (self, CH_PAIN, "object/impact_wood_3.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 1) {
					spamsound (self, CH_PAIN, "object/impact_wood_2.ogg", VOL_BASE, ATTN_NORM);
				} else {
					spamsound (self, CH_PAIN, "object/impact_wood_1.ogg", VOL_BASE, ATTN_NORM);
				}
				self.pushltime = time + 0.1;
			}
		}
		
		//sprint(self.owner.subordinate.realowner, (sprintf("Tower Under Attack, Healt: %f\n", self.vehicle_health)));
			
		
	}
}

float multitool_scaffold_check(entity e, float checkcount)
{
	entity f;
	if ((checkcount >= 700 && checkcount <= MTB64BOUNDLAST)
	 || (checkcount >= MTB64UBOUNDFIRST && checkcount <= MTB64UBOUNDLAST)) {
		//Remove bad block scaffold
		f = findradius(e.origin, 16);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
			  if (f != e) {
			  if(
			  (((f.origin_x == e.origin_x) &&
			  (f.origin_y == e.origin_y) &&
			  (f.origin_z == e.origin_z)) && (f.multitool_flipblock == e.multitool_flipblock))
			  
			  ||
			  
			  (((f.origin_x == e.origin_x) &&
			  (f.origin_y == e.origin_y) &&
			  ((f.origin_z - 64) == e.origin_z)) && (f.multitool_flipblock == 1 && e.multitool_flipblock == 0))
			  
			  ||
			  
			  (((f.origin_x == e.origin_x) &&
			  (f.origin_y == e.origin_y) &&
			  (f.origin_z == (e.origin_z - 64))) && (f.multitool_flipblock == 0 && e.multitool_flipblock == 1))
			  
			  ){
			  	print(ftos(f.multitool_flipblock), " x ", ftos(e.multitool_flipblock), " flpblk\n");
			  
				if ((f.amnt >= 700 && f.amnt <= MTB64BOUNDLAST)
				|| (f.amnt >= MTB64UBOUNDFIRST && f.amnt <= MTB64UBOUNDLAST)) {
					//amnt is only found on scaffolds in this code
					//its just like count
					print("Removing: Can't place a bock in a block scaffold\n");
					return TRUE;
				}
				 
    				if ((f.count >= 700 && f.count <= MTB64BOUNDLAST ) 
				|| (f.count >= MTB64UBOUNDFIRST && f.count <= MTB64UBOUNDLAST )) {
					if ((checkcount == MTB64U_BWIRE || checkcount == MTB64_BWIRE)
					&& (f.count == MTB64U_BWIRE || f.count == MTB64_BWIRE)) {
						//print(ftos(e.angles_y),"\n");
						//print(ftos(f.angles_y),"\n");
						if (e.angles_y == 0 || e.angles_y == -180 || e.angles_y == 180) {
							if (f.angles_y == 0 || f.angles_y == -180 || f.angles_y == 180) {
								print("Removing: Can't place 2 non-perpendicular barbedwires\n");
								return TRUE;
							}
						} else {
							if not(f.angles_y == 0 || f.angles_y == -180 || f.angles_y == 180) {
								print("Removing: Can't place 2 non-perpendicular barbedwires\n");
								return TRUE;
							}
						}
					} else {
						print("Removing: Can't place a block in another block\n");
						return TRUE;
					}
				}
			  }
			  }
			}
    			f = f.chain;
  		}	
	}
	
	if (multitool_isdoor(checkcount)) {
		if (multitool_doorcenteredtooclose_ent(e, 32)) {
			print("Removing: Can't place door so close to centered door\n");
			return TRUE;
		}
	}
	return FALSE;	
}

float multitool_scaffold_checkwalls(entity e, float checkcount)
{
	entity f;
	if ((  (checkcount < 700 || checkcount > MTB64BOUNDLAST) || (checkcount < MTB64UBOUNDFIRST || checkcount > MTB64UBOUNDLAST)  ) &&
	   ((checkcount >= 500 && checkcount < 1000) ||
	    (checkcount >= 10000 && checkcount < 20000) ||
	    (checkcount <= -500 && checkcount > -1000) ||
	    (checkcount >= 1500 && checkcount < 2000))) {
		//Remove bad wall and bridge scaffold
		f = findradius(e.origin, 16);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
			  if (f != e) {
			  if ((f.origin_x == e.origin_x) &&
			  (f.origin_y == e.origin_y) &&
			  (f.origin_z == e.origin_z))
			  {
			    if((f.angles_y == e.angles_y)
			    || (checkcount >= 640 && checkcount < 700)
			    || (checkcount <= -600 && checkcount > -1000)
			    || (checkcount >= 1640 && checkcount < 1700)
			    || (checkcount == 566 || checkcount == 574 || checkcount == 575
				|| checkcount == 564 || checkcount == 576 || checkcount == 584 || checkcount == 1538
				|| checkcount == 583 || checkcount == 1680 || checkcount == 1681 || checkcount == 1686
				|| checkcount == 610 || checkcount == 611 || checkcount == 612 || checkcount == 616))
			    {
			    	//Aim is to trip either wall with same angles and model
				//Or bridge with same model (regardless of angles)
			    
			    	/////////Ignore
				////if ((f.amnt < 700 || f.amnt > MTB64BOUNDLAST) &&
				////   ((f.amnt >= 500 && f.amnt < 1000) || 
	    			////    (f.amnt >= 1500 && f.amnt < 2000))) {
				////	print("Removing: Can't place a wall or bridge in a wall or bridge scaffold\n");
				////	return TRUE;
				////}
				
				////if ((f.count < 700 || f.count > MTB64BOUNDLAST) &&
				////   ((f.count >= 500 && f.count < 1000) || 
	    			////    (f.count >= 1500 && f.count < 2000))) {
				////	print("Removing: Can't place a wall or bridge another wall or bridge\n");
				////	return TRUE;
				////}
				////////////////////
				
				if ((f.amnt == checkcount) && (f.angles_x == e.angles_x)) {
					//amnt is only found on scaffolds in this code
					//its just like count
					print("Removing: Can't place SAME wall (with same orientation) or bridge in SAME wall or bridge scaffold\n");
					return TRUE;
				}
				 
				if ((f.count == checkcount) && (f.angles_x == e.angles_x)) {
					print("Removing: Can't place SAME wall (with same orientation) or bridge in SAME wall or bridge\n");
					return TRUE;
				}
				
				
				
				
				if ((f.amnt == 1524 || f.amnt == 1546 || f.amnt == 10709 || f.amnt == 10710)
				 && (checkcount == 1524 || checkcount == 1546 || checkcount == 10709 || checkcount == 10710)
				 && (f.angles_x == e.angles_x)){
					print("Removing: Can't place moving gate (with same orientation) in moving gate scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 1524 || f.count == 1546 || f.count == 10709 || f.count == 10710)
				 && (checkcount == 1524 || checkcount == 1546 || checkcount == 10709 || checkcount == 10710)
				 && (f.angles_x == e.angles_x)){
					print("Removing: Can't place moving gate (with same orientation) in moving gate\n");
					return TRUE;
				}
				
				
				
				
				
				if ((f.amnt == 650 || f.amnt == 660 || f.amnt == 670
				 || f.amnt == 631 || f.amnt == 632 || f.amnt == 1631 || f.amnt == 1650 || f.amnt == 1653)
				 && (checkcount == 650 || checkcount == 660 || checkcount == 670
				 || checkcount == 631 || checkcount == 632 || checkcount == 1631 || checkcount == 1650 || checkcount == 1653)){
					print("Removing: Can't place bridge landing / tower foundation in bridge landing / tower foundation scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 650 || f.count == 660 || f.count == 670
				 || f.count == 631 || f.count == 632 || f.count == 1631 || f.count == 1650 || f.count == 1653)
				 && (checkcount == 650 || checkcount == 660 || checkcount == 670
				 || checkcount == 631 || checkcount == 632 || checkcount == 1631 || checkcount == 1650 || checkcount == 1653)){
					print("Removing: Can't place bridge landing / tower foundation in bridge landing / tower foundation\n");
					return TRUE;
				}
				
				
				
				
				if ((f.amnt == 630 || f.amnt == 633)
				 && (checkcount == 630 || checkcount == 633)){
					print("Removing: Can't place foundation wall / foundation bridge in foundation wall / foundation bridge scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 630 || f.count == 633)
				 && (checkcount == 630 || checkcount == 633)){
					print("Removing: Can't place foundation wall / foundation bridge in foundation wall / foundation bridge\n");
					return TRUE;
				}
				
				
				
				
				if ((f.amnt == 566 || f.amnt == 574 || f.amnt == 575
				 || f.amnt == 583 || f.amnt == 1680 || f.amnt == 1681 || f.amnt == 1686
				 || f.amnt == 610 || f.amnt == 611 || f.amnt == 612 || f.amnt == 616)
				 && (checkcount == 566 || checkcount == 574 || checkcount == 575
				 || checkcount == 583 || checkcount == 1680 || checkcount == 1681 || checkcount == 1686
				 || checkcount == 610 || checkcount == 611 || checkcount == 612 || checkcount == 616)){
					print("Removing: Can't place vault in vault scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 566 || f.count == 574 || f.count == 575
				 || f.count == 583 || f.count == 1680 || f.count == 1681 || f.count == 1686
				 || f.count == 610 || f.count == 611 || f.count == 612 || f.count == 616)
				 && (checkcount == 566 || checkcount == 574 || checkcount == 575
				 || checkcount == 583 || checkcount == 1680 || checkcount == 1681 || checkcount == 1686
				 || checkcount == 610 || checkcount == 611 || checkcount == 612 || checkcount == 616)){
					print("Removing: Can't place vault in vault\n");
					return TRUE;
				}
				
				
				
				
				if ((f.amnt == 567 || f.amnt == 578 || f.amnt == 586 || f.amnt == 1539)
				 && (checkcount == 567 || checkcount == 578 || checkcount == 586 || checkcount == 1539)){
					print("Removing: Can't place stairs in stairs scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 567 || f.count == 578 || f.count == 586 || f.count == 1539)
				 && (checkcount == 567 || checkcount == 578 || checkcount == 586 || checkcount == 1539)){
					print("Removing: Can't place stairs in stairs\n");
					return TRUE;
				}
				
				
				
				if ((f.amnt == 564 || f.amnt == 576 || f.amnt == 584 || f.amnt == 1538)
				 && (checkcount == 564 || checkcount == 576 || checkcount == 584 || checkcount == 1538)){
					print("Removing: Can't place fill wall in fill wall scaffold\n");
					return TRUE;
				}
				
				if ((f.count == 564 || f.count == 576 || f.count == 584 || f.count == 1538)
				 && (checkcount == 564 || checkcount == 576 || checkcount == 584 || f.count == 1538)){
					print("Removing: Can't place fill wall in fill wall\n");
					return TRUE;
				}
				
				
				
				if ((checkcount <= -600 && checkcount > -1000) && (f.amnt <= -600 && f.amnt > -1000))
				{
					//amnt is only found on scaffolds in this code
					//its just like count
					print("Removing: Can't place floor in floor scaffold\n");
					return TRUE;
				}
				 
				if ((checkcount <= -600 && checkcount > -1000) && (f.count <= -600 && f.count > -1000))
				{
					print("Removing: Can't place floor in floor\n");
					return TRUE;
				}
			    }
			  }
			  }
			}
    			f = f.chain;
  		}	
	}
	return FALSE;	
}

void multitool_scaffoldcheck_remove()
{
	entity e;
	e = self.subordinate;
	
	if (e && e != world) {
		Damage(e, e.subordinate.owner, e.subordinate.owner, 1000000, WEP_ROCKET_LAUNCHER, e.origin, '0 0 0');
	}
	
	if (e && e != world) {
		Damage(e, e.subordinate.owner, e.subordinate.owner, 1000000, WEP_ROCKET_LAUNCHER, e.origin, '0 0 0');
	}
	//Need to do it 2x to finally kill
	
	remove(self);
	print("Removing bad scaffold\n");
}

float multitool_scaffold_modelset (entity e, float scaffoldcount)
{
	float trn;
	trn = 0;

	if (scaffoldcount == 8 || scaffoldcount == 10) {
		e.model = "maps/buildables/scaffold_tower2.bsp";
	} else if (scaffoldcount == 7) {
		e.model = "maps/buildables/scaffold_smallcastle.bsp";
	} else if (scaffoldcount == 5) {
		e.model = "maps/buildables/scaffold_stronghold.bsp";
	} else if (scaffoldcount == 6) {
		e.model = "maps/buildables/scaffold_strongtower.bsp";
	} else if (scaffoldcount == 4 || scaffoldcount == 9) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
	} else if (scaffoldcount == 11) {
		e.model = "maps/buildables/scaffold_gmanse.bsp";
		trn = -90;
	} else if (scaffoldcount == 12) {
		e.model = "maps/buildables/scaffold_arsenal.bsp";
		trn = -90;
	} else if (scaffoldcount == 13) {
		e.model = "maps/buildables/scaffold_barracks.bsp";
		trn = -90;
	} else if (scaffoldcount == 14) {
		e.model = "maps/buildables/scaffold_church.bsp";
		trn = -90;
	} else if (scaffoldcount == 15) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 16) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 17) {
		e.model = "maps/buildables/scaffold_chataeu.bsp";
		trn = -90;
	} else if (scaffoldcount == 18) {
		e.model = "maps/buildables/scaffold_palladianmanor.bsp";
		trn = -90;
	} else if (scaffoldcount == 19) {
		e.model = "maps/buildables/scaffold_stonehouse.bsp";
		trn = -90;
	} else if (scaffoldcount == 20) {
		e.model = "maps/buildables/scaffold_treetopsentry.bsp";
		trn = -90;
	} else if (scaffoldcount == 21) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 22) {
		e.model = "maps/buildables/scaffold_big.bsp";
		trn = -90;
	} else if (scaffoldcount == 23) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 24) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 25) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 26) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 27) {
		e.model = "maps/buildables/scaffold_crusaderstronghold.bsp";
		trn = -90;
	} else if (scaffoldcount == 110
		|| scaffoldcount == 111
		|| scaffoldcount == 112) {
		e.model = "maps/buildables/scaffold_block_64_stake.bsp";
		trn = -90;
	} else if (scaffoldcount == 501) {
		e.model = "maps/buildables/scaffold_field.bsp";
		trn = -90;
	} else if (scaffoldcount == 502) {
		e.model = "maps/buildables/scaffold_vineyard.bsp";
		trn = -90;
	} else if (scaffoldcount == 503) {
		e.model = "maps/buildables/scaffold_block_64_stake.bsp";
		trn = -90;
	} else if (scaffoldcount == 520 || scaffoldcount == 523) {
		e.model = "maps/buildables/scaffold_wall_small.bsp";
		trn = -90;
	} else if (scaffoldcount == 521) {
		e.model = "maps/buildables/scaffold_wall_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 522) {
		e.model = "maps/buildables/scaffold_wall_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 530 || scaffoldcount == 533) {
		e.model = "maps/buildables/scaffold_wall_small.bsp";
		trn = -90;
	} else if (scaffoldcount == 531 || scaffoldcount == 532) {
		e.model = "maps/buildables/scaffold_wall_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 540 || scaffoldcount == 542 || scaffoldcount == 543 || scaffoldcount == 544 || scaffoldcount == 545) {
		e.model = "maps/buildables/scaffold_wall_curtain.bsp";
		trn = -90;
	} else if (scaffoldcount == 541 || scaffoldcount == 546) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 550 || scaffoldcount == 551) {
		e.model = "maps/buildables/scaffold_garrison.bsp";
		trn = -90;
	} else if (scaffoldcount == 560 || scaffoldcount == 563 || scaffoldcount == 569) {
		e.model = "maps/buildables/scaffold_wall_curtain.bsp";
		trn = -90;
	} else if (scaffoldcount == 561) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 562) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 564 || scaffoldcount == 576 || scaffoldcount == 584) {
		e.model = "maps/buildables/scaffold_wall_fill.bsp";
		trn = -90;
	} else if (scaffoldcount == 565 || scaffoldcount == 577 || scaffoldcount == 585
	|| scaffoldcount == 568 || scaffoldcount == 579 || scaffoldcount == 587
	|| scaffoldcount == 10700 || scaffoldcount == 10701 || scaffoldcount == 10702
	|| scaffoldcount == 10703 || scaffoldcount == 10704 || scaffoldcount == 10705) {
		e.model = "maps/buildables/scaffold_wall_interior.bsp";
		trn = -90;
	} else if (scaffoldcount == 10706 || scaffoldcount == 10707) {
		e.model = "maps/buildables/scaffold_wall_interior_alcove.bsp";
		trn = -90;	
	} else if (scaffoldcount == 570 || scaffoldcount == 573 || scaffoldcount == 10708) {
		e.model = "maps/buildables/scaffold_wall_curtain.bsp";
		trn = -90;
	} else if (scaffoldcount == 10709 || scaffoldcount == 10710) {
		e.model = "maps/buildables/scaffold_block_64_door.bsp";
		trn = -90;
	} else if (scaffoldcount == 571) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 572) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 574 || scaffoldcount == 575 || scaffoldcount == 583 || scaffoldcount == 566) {
		e.model = "maps/buildables/scaffold_wall_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 567 || scaffoldcount == 578 || scaffoldcount == 586) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 580 || scaffoldcount == 582 || scaffoldcount == 588) {
		e.model = "maps/buildables/scaffold_wall_curtain.bsp";
		trn = -90;
	} else if (scaffoldcount == 581) {
		e.model = "maps/buildables/scaffold_wall_curtain_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 610) {
		e.model = "maps/buildables/scaffold_vault_roof.bsp";
		trn = -90;
	} else if (scaffoldcount == 611) {
		e.model = "maps/buildables/scaffold_vault_roof_end.bsp";
		trn = -90;
	} else if (scaffoldcount == 612) {
		e.model = "maps/buildables/scaffold_vault_roof_one.bsp";
		trn = -90;
	} else if (scaffoldcount == 616) {
		e.model = "maps/buildables/scaffold_vault_roof_dome.bsp";
		trn = -90;
	} else if (scaffoldcount == 630) {
		e.model = "maps/buildables/scaffold_foundation_wall.bsp";
		trn = -90;
	} else if (scaffoldcount == 633) {
		e.model = "maps/buildables/scaffold_foundation_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 631) {
		e.model = "maps/buildables/scaffold_foundation_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 632) {
		e.model = "maps/buildables/scaffold_foundation_tower_round.bsp";
		trn = -90;
	} else if (scaffoldcount == 645) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 646) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 650) {
		e.model = "maps/buildables/scaffold_foundation_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 651) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 652) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 660) {
		e.model = "maps/buildables/scaffold_foundation_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 661) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 662) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 663) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 664) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 670) {
		e.model = "maps/buildables/scaffold_foundation_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 671) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	} else if (scaffoldcount == 672) {
		e.model = "maps/buildables/scaffold_bridge.bsp";
		trn = -90;
	//Below are scaffolds for 64x64 building blocks. Shingles starts at 710, these constants are used so the nums can be changed easily at once
	} else if (scaffoldcount == MTB64_MARBLEWHITE_CASING || scaffoldcount == MTB64_FILLED_CASING || scaffoldcount == MTB64_SHINGLES_CASING || scaffoldcount == MTB64_WOOD1_CASING || scaffoldcount == MTB64_WOOD2_CASING || scaffoldcount == MTB64_CURTAIN_CASING || scaffoldcount ==  MTB64_CASTLE_CASING
		 || scaffoldcount == MTB64_HEDGE_CASING || scaffoldcount == MTB64_POLISH_CASING || scaffoldcount == MTB64_GRAYSTONE_CASING || scaffoldcount == MTB64_SANDSTONE_CASING || scaffoldcount == MTB64_SHINGLES2_CASING) {
		e.model = "maps/buildables/scaffold_block_64_casing.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_SCASING || scaffoldcount == MTB64_SHINGLES_SCASING || scaffoldcount == MTB64_WOOD1_SCASING || scaffoldcount == MTB64_WOOD2_SCASING || scaffoldcount == MTB64_CURTAIN_SCASING || scaffoldcount == MTB64_CASTLE_SCASING
		 || scaffoldcount == MTB64_HEDGE_SCASING || scaffoldcount == MTB64_POLISH_SCASING || scaffoldcount == MTB64_GRAYSTONE_SCASING || scaffoldcount == MTB64_SANDSTONE_SCASING || scaffoldcount == MTB64_SHINGLES2_SCASING) {
		e.model = "maps/buildables/scaffold_block_64_casingside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_PYR || scaffoldcount == MTB64_SHINGLES_PYR || scaffoldcount == MTB64_WOOD1_PYR || scaffoldcount == MTB64_WOOD2_PYR || scaffoldcount == MTB64_CURTAIN_PYR || scaffoldcount == MTB64_CASTLE_PYR
		 || scaffoldcount == MTB64_HEDGE_PYR || scaffoldcount == MTB64_POLISH_PYR || scaffoldcount == MTB64_GRAYSTONE_PYR || scaffoldcount == MTB64_SANDSTONE_PYR || scaffoldcount == MTB64_SHINGLES2_PYR) {
		e.model = "maps/buildables/scaffold_block_64_pyramidion.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_CORNER || scaffoldcount == MTB64_FILLED_CORNER || scaffoldcount == MTB64_SHINGLES_CORNER || scaffoldcount == MTB64_WOOD1_CORNER || scaffoldcount == MTB64_WOOD2_CORNER || scaffoldcount == MTB64_CURTAIN_CORNER || scaffoldcount == MTB64_CASTLE_CORNER
		 || scaffoldcount == MTB64_HEDGE_CORNER || scaffoldcount == MTB64_POLISH_CORNER || scaffoldcount == MTB64_GRAYSTONE_CORNER || scaffoldcount == MTB64_SANDSTONE_CORNER || scaffoldcount == MTB64_SHINGLES2_CORNER) {
		e.model = "maps/buildables/scaffold_block_64_corner.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_RCORNER_P || scaffoldcount == MTB64_MARBLEWHITE_RCORNER || scaffoldcount == MTB64_MARBLEWHITE_RCORNER_FB || scaffoldcount == MTB64_MARBLEWHITE_RCORNER_FT || scaffoldcount == MTB64_MARBLEWHITE_RCORNER_F ||  scaffoldcount == MTB64_MARBLEWHITE_RCORNER_SOLID  ||  scaffoldcount == MTB64_SHINGLES_RCORNER || scaffoldcount == MTB64_WOOD1_RCORNER || scaffoldcount == MTB64_WOOD2_RCORNER || scaffoldcount == MTB64_CURTAIN_RCORNER || scaffoldcount == MTB64_CASTLE_RCORNER
		 || scaffoldcount == MTB64_HEDGE_RCORNER || scaffoldcount == MTB64_POLISH_RCORNER || scaffoldcount == MTB64_GRAYSTONE_RCORNER || scaffoldcount == MTB64_SANDSTONE_RCORNER || scaffoldcount == MTB64_SHINGLES2_RCORNER) {
		e.model = "maps/buildables/scaffold_block_64_roundcorner.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_RECCORNER
		|| scaffoldcount == MTB64_MARBLEWHITE_SCORNER_P
		|| scaffoldcount == MTB64_MARBLEWHITE_RECCORNER_F
		|| scaffoldcount == MTB64_MARBLEWHITE_RECCORNER_FT
		|| scaffoldcount == MTB64_MARBLEWHITE_RECCORNER_FB) {
		e.model = "maps/buildables/scaffold_block_64_recessedcorner.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_STAIRS || scaffoldcount == MTB64_SHINGLES_STAIRS || scaffoldcount == MTB64_WOOD1_STAIRS || scaffoldcount == MTB64_WOOD2_STAIRS || scaffoldcount == MTB64_CURTAIN_STAIRS || scaffoldcount == MTB64_CASTLE_STAIRS
		 || scaffoldcount == MTB64_HEDGE_STAIRS || scaffoldcount == MTB64_POLISH_STAIRS || scaffoldcount == MTB64_GRAYSTONE_STAIRS || scaffoldcount == MTB64_SANDSTONE_STAIRS || scaffoldcount == MTB64_SHINGLES2_STAIRS) {
		e.model = "maps/buildables/scaffold_block_64_stairs.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_SSTAIRS || scaffoldcount == MTB64_SHINGLES_SSTAIRS || scaffoldcount == MTB64_WOOD1_SSTAIRS || scaffoldcount == MTB64_WOOD2_SSTAIRS || scaffoldcount == MTB64_CURTAIN_SSTAIRS || scaffoldcount == MTB64_CASTLE_SSTAIRS
		 || scaffoldcount == MTB64_HEDGE_SSTAIRS || scaffoldcount == MTB64_POLISH_SSTAIRS || scaffoldcount == MTB64_GRAYSTONE_SSTAIRS || scaffoldcount == MTB64_SANDSTONE_SSTAIRS || scaffoldcount == MTB64_SHINGLES2_SSTAIRS) {
		e.model = "maps/buildables/scaffold_block_64_stairs_side.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_ISTAIRS || scaffoldcount == MTB64_SHINGLES_ISTAIRS || scaffoldcount == MTB64_WOOD1_ISTAIRS || scaffoldcount == MTB64_WOOD2_ISTAIRS || scaffoldcount == MTB64_CURTAIN_ISTAIRS || scaffoldcount == MTB64_CASTLE_ISTAIRS
		 || scaffoldcount == MTB64_HEDGE_ISTAIRS || scaffoldcount == MTB64_POLISH_ISTAIRS || scaffoldcount == MTB64_GRAYSTONE_ISTAIRS || scaffoldcount == MTB64_SANDSTONE_ISTAIRS || scaffoldcount == MTB64_SHINGLES2_ISTAIRS) {
		e.model = "maps/buildables/scaffold_block_64_stairs_inside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_WOOD2_STAIRSCHEAP) {
		e.model = "maps/buildables/scaffold_block_64_stairs_cheap.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_ICASING || scaffoldcount == MTB64_SHINGLES_ICASING || scaffoldcount == MTB64_WOOD1_ICASING || scaffoldcount == MTB64_WOOD2_ICASING || scaffoldcount == MTB64_CURTAIN_ICASING || scaffoldcount == MTB64_CASTLE_ICASING
		 || scaffoldcount == MTB64_HEDGE_ICASING || scaffoldcount == MTB64_POLISH_ICASING || scaffoldcount == MTB64_GRAYSTONE_ICASING || scaffoldcount == MTB64_SANDSTONE_ICASING || scaffoldcount == MTB64_SHINGLES2_ICASING) {
		e.model = "maps/buildables/scaffold_block_64_casinginside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_OS || scaffoldcount == MTB64_SHINGLES_OS || scaffoldcount == MTB64_WOOD1_OS || scaffoldcount == MTB64_WOOD2_OS || scaffoldcount == MTB64_CURTAIN_OS || scaffoldcount == MTB64_CASTLE_OS
		 || scaffoldcount == MTB64_HEDGE_OS || scaffoldcount == MTB64_POLISH_OS || scaffoldcount == MTB64_GRAYSTONE_OS || scaffoldcount == MTB64_SANDSTONE_OS || scaffoldcount == MTB64_SHINGLES2_OS) {
		e.model = "maps/buildables/scaffold_block_64_octoside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_MARBLEWHITE_OS2 || scaffoldcount == MTB64_SHINGLES_OS2 || scaffoldcount == MTB64_WOOD1_OS2 || scaffoldcount == MTB64_WOOD2_OS2 || scaffoldcount == MTB64_CURTAIN_OS2 || scaffoldcount == MTB64_CASTLE_OS2
		 || scaffoldcount == MTB64_HEDGE_OS2 || scaffoldcount == MTB64_POLISH_OS2 || scaffoldcount == MTB64_GRAYSTONE_OS2 || scaffoldcount == MTB64_SANDSTONE_OS2 || scaffoldcount == MTB64_SHINGLES2_OS2) {
		e.model = "maps/buildables/scaffold_block_64_octoside2.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_STAKES_WOOD1
		|| scaffoldcount == MTB64_FURN_IMPALEMENTPOLE) {
		e.model = "maps/buildables/scaffold_block_64_stake.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_BWIRE) {
		e.model = "maps/buildables/scaffold_block_64_window.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_WINDOW_WOODBAR || scaffoldcount == MTB64_WINDOW_IRONBAR) {
		e.model = "maps/buildables/scaffold_block_64_window.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64_DOOR_R_WOOD || scaffoldcount == MTB64_DOOR_R_JWOOD || scaffoldcount == MTB64_DOOR_R_FWOOD || scaffoldcount == MTB64_DOOR_R_IRONBAR
		|| scaffoldcount == MTB64_FITTEDWINDOW_CASTLE_ALOOP || scaffoldcount == MTB64_FITTEDWINDOW_CASTLE_SWALL || scaffoldcount == MTB64_FITTEDWINDOW_WINDOW) {
		e.model = "maps/buildables/scaffold_block_64_door.bsp";
		trn = -90;
			
	} else if (scaffoldcount == MTB64_FURN_CHAIR_WOOD
	|| scaffoldcount == MTB64_FURN_CHAIR_WOOD2
	|| scaffoldcount == MTB64_FURN_BENCH_WOOD
	|| scaffoldcount == MTB64_FURN_CHAIR_FANCY1
	|| scaffoldcount == MTB64_FURN_CHAIR_FANCY2
	|| scaffoldcount == MTB64_FURN_CHAIR_FANCY3
	|| scaffoldcount == MTB64_FURN_CHAISELOUNGE
	|| scaffoldcount == MTB64_FURN_IRONMAIDEN
	|| scaffoldcount == MTB64_FURN_SPIKEDRACK
	|| scaffoldcount == MTB64_FURN_GIBBET) {
		e.model = "maps/buildables/scaffold_block_64_stairs.bsp";
		trn = -90;
		
	} else if (scaffoldcount >= 700 && scaffoldcount <= MTB64BOUNDLAST) {
		e.model = "maps/buildables/scaffold_block_64.bsp";
		trn = -90;

		
	} else if (scaffoldcount == MTB64U_CONCRETE_CASING || scaffoldcount == MTB64U_METAL_CASING
	|| scaffoldcount == MTB64U_RCONCRETE_CASING) {
		e.model = "maps/buildables/scaffold_block_future_64_casing.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_SCASING || scaffoldcount == MTB64U_METAL_SCASING
	|| scaffoldcount == MTB64U_RCONCRETE_SCASING) {
		e.model = "maps/buildables/scaffold_block_future_64_casingside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_PYR || scaffoldcount == MTB64U_METAL_PYR
	|| scaffoldcount == MTB64U_RCONCRETE_PYR) {
		e.model = "maps/buildables/scaffold_block_future_64_pyramidion.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_CORNER || scaffoldcount == MTB64U_METAL_CORNER
	|| scaffoldcount == MTB64U_RCONCRETE_CORNER) {
		e.model = "maps/buildables/scaffold_block_future_64_corner.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_RCORNER || scaffoldcount == MTB64U_METAL_RCORNER
	|| scaffoldcount == MTB64U_RCONCRETE_RCORNER) {
		e.model = "maps/buildables/scaffold_block_future_64_roundcorner.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_STAIRS || scaffoldcount == MTB64U_METAL_STAIRS
	|| scaffoldcount == MTB64U_RCONCRETE_STAIRS) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_ICASING || scaffoldcount == MTB64U_METAL_ICASING
	|| scaffoldcount == MTB64U_RCONCRETE_ICASING) {
		e.model = "maps/buildables/scaffold_block_future_64_casinginside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_OS || scaffoldcount == MTB64U_METAL_OS
	|| scaffoldcount == MTB64U_RCONCRETE_OS) {
		e.model = "maps/buildables/scaffold_block_future_64_octoside.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_OS2 || scaffoldcount == MTB64U_METAL_OS2
	|| scaffoldcount == MTB64U_RCONCRETE_OS2) {
		e.model = "maps/buildables/scaffold_block_future_64_octoside2.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_SSTAIRS || scaffoldcount == MTB64U_METAL_SSTAIRS
	|| scaffoldcount == MTB64U_RCONCRETE_SSTAIRS) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs_side.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_CONCRETE_ISTAIRS || scaffoldcount == MTB64U_METAL_ISTAIRS
	|| scaffoldcount == MTB64U_RCONCRETE_ISTAIRS) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs_inside.bsp";
		trn = -90;
		
	} else if (scaffoldcount == MTB64U_WINDOW_FUTURE || scaffoldcount == MTB64U_WINDOW_FUTURE_X) {
		e.model = "maps/buildables/scaffold_block_future_64_window.bsp";
		trn = -90;
	
	} else if (scaffoldcount == MTB64U_BWIRE) {
		e.model = "maps/buildables/scaffold_block_future_64_window.bsp";
		trn = -90;
		
	} else if (scaffoldcount == MTB64U_DOOR_R_STEEL
	|| scaffoldcount == MTB64U_DOOR_R_PLAIN
	|| scaffoldcount == MTB64U_DOOR_R_PLAIN2
	|| scaffoldcount == MTB64U_DOOR_R_GLASS
	|| scaffoldcount == MTB64U_FITTEDWINDOW_STEELSLIT
	|| scaffoldcount == MTB64U_FITTEDWINDOW_STEELPLATE
	|| scaffoldcount == MTB64U_FITTEDWINDOW_CWALL
	|| scaffoldcount == MTB64U_FITTEDWINDOW_UWINDOW) {
		e.model = "maps/buildables/scaffold_block_future_64_door.bsp";
		trn = -90;
		
	} else if (scaffoldcount == MTB64U_XBEAM_UP) {
		e.model = "maps/buildables/scaffold_block_future_64_xbeam.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_XBEAM_OVER) {
		e.model = "maps/buildables/scaffold_block_future_64_xbeam_over.bsp";
		trn = -90;
	
	} else if (scaffoldcount == MTB64U_FURN_CHAIR || scaffoldcount == MTB64U_FURN_CHAIR2
	|| scaffoldcount == MTB64U_FURN_CHAIR3
	|| scaffoldcount == MTB64U_FURN_CHAIR4
	|| scaffoldcount == MTB64U_FURN_CHAIR5
	|| scaffoldcount == MTB64U_FURN_RETROCHAIR
	|| scaffoldcount == MTB64U_FURN_PLSCHAIR
	|| scaffoldcount == MTB64U_FURN_SCHINTGRDESK
	|| scaffoldcount == MTB64U_FURN_SCHDESKCHAIR
	|| scaffoldcount == MTB64U_FURN_BSCKCABINET1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETTOP1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETTOPDEEP1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETTOPSHORT1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINET2
	|| scaffoldcount == MTB64U_FURN_BSCKCABINET3
	|| scaffoldcount == MTB64U_FURN_BSCKCABINET4
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETBAR1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETBARENDR
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETBARENDL
	|| scaffoldcount == MTB64U_FURN_MGSTDESK
	|| scaffoldcount == MTB64U_FURN_MGSTDESKFLAT
	|| scaffoldcount == MTB64U_FURN_SCHAIR
	|| scaffoldcount == MTB64U_FURN_OMLCHAIR
	|| scaffoldcount == MTB64U_FURN_OMLCHAIR2
	|| scaffoldcount == MTB64U_FURN_MLHSKCHAIR
	|| scaffoldcount == MTB64U_FURN_TRIBECACHAIR
	|| scaffoldcount == MTB64U_FURN_BARCELONACHAIR
	|| scaffoldcount == MTB64U_FURN_TOILET || scaffoldcount == MTB64U_FURN_TOILET2
	|| scaffoldcount == MTB64U_FURN_TOILET3
	|| scaffoldcount == MTB64U_FURN_SOFA1BR
	|| scaffoldcount == MTB64U_FURN_SOFA3BR
	|| scaffoldcount == MTB64U_FURN_SOFA1B
	|| scaffoldcount == MTB64U_FURN_SOFA3B
	|| scaffoldcount == MTB64U_FURN_SOFA1LW
	|| scaffoldcount == MTB64U_FURN_SOFA3LW
	|| scaffoldcount == MTB64U_FURN_SOFA1LW2
	|| scaffoldcount == MTB64U_FURN_SOFA3LW2
	|| scaffoldcount == MTB64U_FURN_SOFA_FOAM
	|| scaffoldcount == MTB64U_FURN_SOFA_TARTAN
	|| scaffoldcount == MTB64U_FURN_SOFA_POOFY
	|| scaffoldcount == MTB64U_FURN_SOFA_NORM) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs.bsp";
		trn = -90;
	} else if (scaffoldcount == MTB64U_FURN_SHOWER) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs_inside.bsp";
		trn = -90;
	
	
	} else if (scaffoldcount == MTB64U_FURN_BSCKCABINETCORNER1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETCORNER2
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETCORNERTOP1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETCORNERTOP2
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
	|| scaffoldcount == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
	|| scaffoldcount == MTB64U_FURN_MGSTDESKFULLCORNER) {
		e.model = "maps/buildables/scaffold_block_future_64_stairs_inside.bsp";
		trn = -90;
		
	} else if (scaffoldcount >= MTB64UBOUNDFIRST && scaffoldcount <= MTB64UBOUNDLAST) {
		e.model = "maps/buildables/scaffold_block_future_64.bsp";
		trn = -90;
	} else if (scaffoldcount == -1) {
		e.model = "maps/buildables/scaffold_sniperspire.bsp";
	} else if (scaffoldcount == -2) {
		e.model = "maps/buildables/scaffold_nippon_house.bsp";
		trn = -90;
	} else if (scaffoldcount == -3) {
		e.model = "maps/buildables/scaffold_nippon_shrine.bsp";
		trn = -90;
	} else if (scaffoldcount == -4) {
		e.model = "maps/buildables/scaffold_nippon_dojo.bsp";
		trn = -90;
	} else if (scaffoldcount == -5) {
		e.model = "maps/buildables/scaffold_tower1.bsp";
		trn = -90;
	} else if (scaffoldcount <= -600 && scaffoldcount > -1000) {
		e.model = "maps/buildables/scaffold_floor.bsp";
		trn = -90;
	} else if (scaffoldcount == 1001) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
	} else if (scaffoldcount == 1002) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1003) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1004) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1005) {
		e.model = "maps/buildables/scaffold_newhangar.bsp";
		trn = -90;
	} else if (scaffoldcount == 1006) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1007) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1008) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1009) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1010) {
		e.model = "maps/buildables/scaffold_oiltank.bsp";
		trn = -90;
	} else if (scaffoldcount == 1011) {
		e.model = "maps/buildables/scaffold_oiltank.bsp";
		trn = -90;
	} else if (scaffoldcount == 1012) {
		e.model = "maps/buildables/scaffold_apartments.bsp";
		trn = -90;
	} else if (scaffoldcount == 1013 || scaffoldcount == 1014) {
		e.model = "maps/buildables/scaffold_solarpanel.bsp";
		trn = -90;
	} else if (scaffoldcount == 1015) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1016) {
		e.model = "maps/buildables/scaffold_chemical1.bsp";
		trn = -90;
	} else if (scaffoldcount == 1017) {
		e.model = "maps/buildables/scaffold_chemical2.bsp";
		trn = -90;
	} else if (scaffoldcount == 1018) {
		e.model = "maps/buildables/scaffold_chemical3.bsp";
		trn = -90;
	} else if (scaffoldcount == 1019) {
		e.model = "maps/buildables/scaffold_factory1.bsp";
		trn = -90;
	} else if (scaffoldcount == 1020) {
		e.model = "maps/buildables/scaffold_solarpanel.bsp";
		trn = -90;
	} else if (scaffoldcount == 1021) {
		e.model = "maps/buildables/scaffold_furnace.bsp";
		trn = -90;
	} else if (scaffoldcount == 1022) {
		e.model = "maps/buildables/scaffold_apartments.bsp";
		trn = -90;
	} else if (scaffoldcount == 1023) {
		e.model = "maps/buildables/scaffold_apartments.bsp";
		trn = -90;
	} else if (scaffoldcount == 1024) {
		e.model = "maps/buildables/scaffold_apartments.bsp";
		trn = -90;
	} else if (scaffoldcount == 1025) {
		e.model = "maps/buildables/scaffold_tensionwiretower.bsp";
		trn = -90;
	} else if (scaffoldcount == 1026) {
		e.model = "maps/buildables/scaffold_apartments.bsp";
		trn = -90;
	} else if (scaffoldcount == 1027) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1028) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1029) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1030) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1031) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1032) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1033) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1034) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1035) {
		e.model = "maps/buildables/scaffold_shieldgen.bsp";
		trn = -90;
	} else if (scaffoldcount == 1036) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1037) {
		e.model = "maps/buildables/scaffold_observationtower.bsp";
		trn = -90;
	} else if (scaffoldcount == 1038) {
		e.model = "maps/buildables/scaffold_pylon.bsp";
		trn = -90;
	} else if (scaffoldcount == 1110
		|| scaffoldcount == 1111
		|| scaffoldcount == 1112
		|| scaffoldcount == 1113
		|| scaffoldcount == 1114
		|| scaffoldcount == 1115
		|| scaffoldcount == 1116
		|| scaffoldcount == 1117
		|| scaffoldcount == 1118) {
		e.model = "maps/buildables/scaffold_block_future_64_stake.bsp";
		trn = -90;
	} else if (scaffoldcount == 1120 || scaffoldcount == 1121 || scaffoldcount == 1122
		|| scaffoldcount == 1123 || scaffoldcount == 1124 || scaffoldcount == 1125
		|| scaffoldcount == 1126 || scaffoldcount == 1127) {
		e.model = "maps/buildables/scaffold_pylon.bsp";
		trn = -90;
	} else if (scaffoldcount == 1130 || scaffoldcount == 1131) {
		e.model = "maps/buildables/scaffold_solarpanel.bsp";
		trn = -90;
	} else if (scaffoldcount == 1501) {
		e.model = "maps/buildables/scaffold_greenhouse.bsp";
		trn = -90;
	} else if (scaffoldcount == 1502) {
		e.model = "maps/buildables/scaffold_block_future_64_stake.bsp";
		trn = -90;
	} else if (scaffoldcount == 1510) {
		e.model = "maps/buildables/scaffold_solarpanel.bsp";
		trn = -90;
	} else if (scaffoldcount == 1520 || scaffoldcount == 1522 || scaffoldcount == 1523 || scaffoldcount == 1530 || scaffoldcount == 1532
	|| scaffoldcount == 1533 || scaffoldcount == 1534 || scaffoldcount == 1535 || scaffoldcount == 1542 || scaffoldcount == 1543
	|| scaffoldcount == 1548 || scaffoldcount == 1549) {
		e.model = "maps/buildables/scaffold_wall_future_small.bsp";
		trn = -90;
	} else if (scaffoldcount == 1524 || scaffoldcount == 1546) {
		//fencemil moving gate
		e.model = "maps/buildables/scaffold_block_future_64_door.bsp";
		trn = -90;
	} else if (scaffoldcount == 1521 || scaffoldcount == 1531 || scaffoldcount == 1536 || scaffoldcount == 1537) {
		e.model = "maps/buildables/scaffold_wall_future_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 1538) {
		e.model = "maps/buildables/scaffold_wall_future_fill.bsp";
		trn = -90;
	} else if (scaffoldcount == 1539) {
		e.model = "maps/buildables/scaffold_wall_future_small_tower.bsp";
		trn = -90;
	} else if (scaffoldcount == 1540 || scaffoldcount == 1541) {
		e.model = "maps/buildables/scaffold_wall_future_interior.bsp";
		trn = -90;
	} else if (scaffoldcount == 1550) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1551) {
		e.model = "maps/buildables/scaffold_commandpost.bsp";
		trn = -90;
	} else if (scaffoldcount == 1630) {
		e.model = "maps/buildables/scaffold_foundation_wall_concrete.bsp";
		trn = -90;
	} else if (scaffoldcount == 1631) {
		e.model = "maps/buildables/scaffold_foundation_tower_concrete.bsp";
		trn = -90;
	} else if (scaffoldcount == 1650 || scaffoldcount == 1653) {
		e.model = "maps/buildables/scaffold_bridge_future_landing.bsp";
		trn = -90;
	} else if (scaffoldcount == 1651 || scaffoldcount == 1652) {
		e.model = "maps/buildables/scaffold_bridge_future.bsp";
		trn = -90;
	} else if (scaffoldcount == 1680 || scaffoldcount == 1681 || scaffoldcount == 1686) {
		e.model = "maps/buildables/scaffold_wall_future_small_tower.bsp";
		trn = -90;
	} else {
		e.model = "maps/buildables/scaffold_tower1.bsp";
	}
	
	return(trn);
}

void multitool_scaffold_spawner()
{
	//e is the thing we are spawning, self is this spawner
	entity e, oldself, myplayer;
	float trn;
	
	myplayer = self.owner; //This is the player entity, will be used below for floor rotate locking
	
	e = spawn();
	e.classname = "building";
	e.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
	e.multitool_isscaffold = 1; //KISS
	
	if(self.multitool_ammocurrent) {
		//The amount of converted nails spent on creating this, if any
		e.multitool_ammocurrent = self.multitool_ammocurrent;
	}
	
	trn = 0;
	e.amnt = self.count; //So we can radiusfind farm scaffolds etc
	
	//Here we set the model for the scaffold
	trn = multitool_scaffold_modelset(e, self.count);

	
	float checkcount;
	checkcount = self.count;

	//Floor Rotate Locking
	if (multitool_countisfloor(self.count)) {
		//We are dealing with a floor
		if (myplayer.multitool_floorlockrot) {
			self.angles_y = myplayer.multitool_floorlockrotsetting;
			self.subordinate.angles_y = myplayer.multitool_floorlockrotsetting;
		} else {
			//If not enabled set it
			myplayer.multitool_floorlockrotsetting = self.angles_y;
		}
	}
	
	//Snap angles
	if (self.angles_y < 135 && self.angles_y >= 45)
		self.angles_y = 90;
	else if (self.angles_y < 45 && self.angles_y >= -45)
		self.angles_y = 0;
	else if (self.angles_y < -45 && self.angles_y >= -135)
		self.angles_y = -90;
	else
		self.angles_y = 180;
 	
	e.solid = SOLID_BSP;
	setorigin(e, self.origin);
	
	oldself = self;
	self = e;
	
	self.nopounddown = 1;
	
	if ((oldself.count >= 570 && oldself.count <= 579)
	|| (multitool_isbuildingcurtainstone(oldself.count))
	|| (multitool_isbuildingcastlestoneextra(oldself.count))
	|| (oldself.count == 6) || (oldself.count == 8)
	|| (oldself.count == 7) || (oldself.count == 10)
	|| (oldself.count == 27)
	|| (oldself.count >= 660 && oldself.count <= 669)
	|| (oldself.count >= 10700 && oldself.count <= 10799)) {
		//print("castlecolors\n");
		if (oldself.multitool_castlecolor) {
			self.multitool_castlecolor = oldself.multitool_castlecolor;
		}
		
		if (oldself.count == 616 && oldself.multitool_woodcolor) {
			self.multitool_woodcolor = oldself.multitool_woodcolor;
		}	
	}
	
	if ((oldself.count >= 700 && oldself.count <= MTB64BOUNDLAST)
	|| (oldself.count >= MTB64UBOUNDFIRST && oldself.count <= MTB64UBOUNDLAST)) {
		if (oldself.multitool_flipblock) {
			self.angles_x = 180;
			self.origin_z = self.origin_z + 64; //Offset model (block models start at 0 z, to 64. Not centered
			setorigin(self, self.origin);
			self.multitool_flipblock = 1;
		}
		
		if (oldself.multitool_roofcolor) {
			self.multitool_roofcolor = oldself.multitool_roofcolor;
		}
		
		if (oldself.multitool_flamecolor) {
			self.multitool_flamecolor = oldself.multitool_flamecolor;
		}
		
		if (oldself.multitool_woodcolor) {
			self.multitool_woodcolor = oldself.multitool_woodcolor;
		}
		
		if (oldself.multitool_marblecolor) {
			self.multitool_marblecolor = oldself.multitool_marblecolor;
		}
		
		if (oldself.multitool_castlecolor) {
			self.multitool_castlecolor = oldself.multitool_castlecolor;
		}
		
		if (oldself.multitool_sstonecolor) {
			self.multitool_sstonecolor = oldself.multitool_sstonecolor;
		}
		
		self.multitool_doorcenter = oldself.multitool_doorcenter; //So we will set proper door frame
	}
	//gamemodel doesn't work for this, just clientmodel
        if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        self.solid = SOLID_BSP;
        self.movetype = MOVETYPE_PUSH;
	self.angles_y = oldself.angles_y + trn; //the door is at the back of what you are looking for defensive structures
	self.subordinate = oldself.subordinate;
	
    	self.touch              = func_null;
    	self.event_damage       = multitool_scaffold_damage;
    	//self.bot_attack         = TRUE;
    	self.takedamage         = DAMAGE_AIM;
    	self.deadflag           = DEAD_NO;
    	self.think              = func_null;
    	self.vehicle_health = 1000;

    	self.damageforcescale = 0.03;    	
	
	self = oldself;
	
	remove_safely(self);
	
	if (multitool_scaffold_check(e, checkcount)) {
		entity j;
		j = spawn();
		j.think = multitool_scaffoldcheck_remove;
		j.nextthink = time;
		j.subordinate = e;
	} else if (multitool_scaffold_checkwalls(e, checkcount)) {
		entity j;
		j = spawn();
		j.think = multitool_scaffoldcheck_remove;
		j.nextthink = time;
		j.subordinate = e;
	} 
}

void multitool_oilexplosion()
{
		local entity eburn;
		local float exprad;
		exprad = 4096;
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.95, 0.05, 0.25);
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 0.1, 0.5);
	
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.35, 0.13, 0.6);

		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.25, 0.16, 0.7);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 1, 4.0);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.3, 2, 8.0);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.2, 3, 12.0);
		
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "weapons/rocket_impact.wav", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 6000, 150, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		eburn = findradius(self.origin, exprad);
		while(eburn)
		{
		if ((eburn.classname == "player" && eburn.health > 0) || eburn.classname == "tree" || eburn.classname == "bush"
		|| (eburn.abdbldcanburn && (autocvar_g_spawnmiscitemsaround_abdbld_extendeddamage >= 3))
		|| (eburn.classname == "bldhitbx" && multitool_iswooden(eburn.count)) )
			Fire_AddDamage(eburn, self.realowner, autocvar_g_balance_nukelayer_fire2_damage *
			20, 20, 
			WEP_FIREBALL);
		
			if (eburn.classname == "tree"
			|| eburn.classname == "bush") {
				eburn.fire_intensity = 5;
			}
		
			eburn = eburn.chain;
		}
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_oilexplosionsmall()
{
		local entity eburn;
		local float exprad;
		exprad = 1024;
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.95, 0.05, 0.25);
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 0.1, 0.5);
	
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.35, 0.13, 0.6);

		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.25, 0.16, 0.7);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 1, 4.0);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.3, 2, 8.0);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.2, 3, 12.0);
		
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "weapons/rocket_impact.wav", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 6000, 150, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		eburn = findradius(self.origin, exprad);
		while(eburn)
		{
		if ((eburn.classname == "player" && eburn.health > 0) || eburn.classname == "tree" || eburn.classname == "bush"
		|| (eburn.abdbldcanburn && (autocvar_g_spawnmiscitemsaround_abdbld_extendeddamage >= 3))
		|| (eburn.classname == "bldhitbx" && multitool_iswooden(eburn.count)) )
			Fire_AddDamage(eburn, self.realowner, autocvar_g_balance_nukelayer_fire2_damage *
			20, 20, 
			WEP_FIREBALL);
		
			if (eburn.classname == "tree"
			|| eburn.classname == "bush") {
				eburn.fire_intensity = 5;
			}
		
			eburn = eburn.chain;
		}
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_oildrumexplosion()
{
		local entity eburn;
		local float exprad;
		exprad = 192;
		modeleffect_spawn("models/sphere/sphexp2.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.95, 0.05, 0.25);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 1, 4.0);
		
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.3, 2, 8.0);
	
		modeleffect_spawn("models/sphere/sphexp3.iqm", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.2, 3, 12.0);

		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "weapons/rocket_impact.wav", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 200, 100, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		eburn = findradius(self.origin, exprad);
		while(eburn)
		{
		if ((eburn.classname == "player" && eburn.health > 0) || eburn.classname == "tree" || eburn.classname == "bush"
		|| (eburn.abdbldcanburn && (autocvar_g_spawnmiscitemsaround_abdbld_extendeddamage >= 3))
		|| (eburn.classname == "bldhitbx" && multitool_iswooden(eburn.count)) )
			Fire_AddDamage(eburn, self.realowner, autocvar_g_balance_nukelayer_fire2_damage *
			20, 20, 
			WEP_FIREBALL);
		
			if (eburn.classname == "tree"
			|| eburn.classname == "bush") {
				eburn.fire_intensity = 5;
			}
		
			eburn = eburn.chain;
		}
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_expblockexplosion()
{
		local entity eburn;
		local float exprad;
		exprad = 256;
		modeleffect_spawn("models/sphere/sphexp.md3", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.95, 0.05, 0.25);
		modeleffect_spawn("models/sphere/sphexp.md3", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.4, 0.1, 0.5);
	
		modeleffect_spawn("models/sphere/sphexp.md3", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.35, 0.13, 0.6);

		modeleffect_spawn("models/sphere/sphexp.md3", 0, 0, self.origin, '0 0 0', '0 0 0', '0 0 0', 0, exprad, 0.25, 0.16, 0.7);
	
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "weapons/rocket_impact.wav", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 1000, 700, exprad, world, 500, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		eburn = findradius(self.origin, exprad);
		while(eburn)
		{
			if (eburn.classname == "tree" || eburn.classname == "bush") {
				mine_damage_tree(eburn, self, 700 * autocvar_g_balance_minelayer_damagerate_tree);
			}
		
			eburn = eburn.chain;
		}
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_expbarrelwood2m()
{
		local float exprad;
		exprad = 256;
		
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "ardentryst/flame_whoosh.ogg", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 250, 100, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_expbarrelwood2()
{
		local float exprad;
		exprad = 192;
		
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "ardentryst/flame_whoosh.ogg", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 200, 100, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		remove(self);
		//self.think              = func_null;	
}


void multitool_expbarrelwood2s()
{
		local float exprad;
		exprad = 128;
		
		pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "ardentryst/flame_whoosh.ogg", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 200, 100, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		remove(self);
		//self.think              = func_null;	
}


void multitool_expbarrelwood2sm()
{
		local float exprad;
		exprad = 64;
		
		pointparticles(particleeffectnum("rocket_explode"), self.origin, '0 0 0', 1);
		sound (self, CH_SHOTS, "ardentryst/flame_whoosh.ogg", VOL_BASE, ATTN_NORM);
		RadiusDamage (self, self.subordinate, 200, 100, exprad, world, 250, WEP_EXPLOSIVE_VEST, world);
		
		OilFire_explosion_spawnoilburnermaybe(self);
		
		remove(self);
		//self.think              = func_null;	
}

void multitool_xplodondth(entity myent, vector myorigin, entity attacker, float myprojectiletype) {
	if (myent.xplodondth) {
		//Do nothing
	} else if (myent.xplodondth > random()) {
		//Do nothing
	} else {
		return;
	}
	
	
	local entity wbexpent;
	if (myent.xplodondth_type == 1) {
		//oil
		wbexpent = spawn();
		wbexpent.think = multitool_oildrumexplosion;
		wbexpent.nextthink = time + 0.32 + random();
		wbexpent.subordinate = attacker;
		setorigin(wbexpent, myorigin);
		CSQCProjectile(wbexpent, TRUE, myprojectiletype, TRUE);
		//pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
	} else if (myent.xplodondth_type == 2) {
		//high explosives
		wbexpent = spawn();
		wbexpent.think = multitool_expblockexplosion;
		wbexpent.nextthink = time + 0.01 + (random() * 0.25);
		wbexpent.subordinate = attacker;
		setorigin(wbexpent, myorigin);
		CSQCProjectile(wbexpent, TRUE, myprojectiletype, TRUE);
		//pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
	} else if (myent.xplodondth_type == 3) {
		//Huge oil
		wbexpent = spawn();
		wbexpent.think = multitool_oilexplosion;
		wbexpent.nextthink = time + 0.32 + random();
		wbexpent.subordinate = attacker;
		setorigin(wbexpent, myorigin);
		CSQCProjectile(wbexpent, TRUE, myprojectiletype, TRUE);
		//pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
	} else if (myent.xplodondth_type == 4) {
		//Strong Flare up
		wbexpent = spawn();
		wbexpent.think = multitool_expbarrelwood2m;
		wbexpent.nextthink = time + 0.02 + (random() * 0.25);
		wbexpent.subordinate = attacker;
		setorigin(wbexpent, myorigin);
		CSQCProjectile(wbexpent, TRUE, myprojectiletype, TRUE);
		//pointparticles(particleeffectnum("rocket_explode"), self.origin, '0 0 0', 1);
	} else {
		//Flare up
		wbexpent = spawn();
		if (random() > 0.5) {
			if (random() > 0.5) {
				wbexpent.think = multitool_expbarrelwood2s;
			} else {
				wbexpent.think = multitool_expbarrelwood2sm;
			}
		} else {
			wbexpent.think = multitool_expbarrelwood2;
		}
		wbexpent.nextthink = time + 0.02 + (random() * 0.25);
		wbexpent.subordinate = attacker;
		setorigin(wbexpent, myorigin);
		CSQCProjectile(wbexpent, TRUE, myprojectiletype, TRUE);
		//pointparticles(particleeffectnum("rocket_explode"), self.origin, '0 0 0', 1);
	}
}

void multitool_random_Electro_Attack2(entity player, entity mowner)
{
	entity proj;
	vector direction;
	direction = randomvec();

	w_shotdir = v_forward; // no TrueAim for grenades please
	W_SetupShot_ProjectileSize (player, '0 0 -4', '0 0 -4', FALSE, 2, "weapons/electro_fire2.wav", CH_WEAPON_A, autocvar_g_balance_electro_secondary_damage);

	w_shotorg = player.origin;

	pointparticles(particleeffectnum("electro_muzzleflash"), w_shotorg, w_shotdir * 1000, 1);

	proj = spawn ();
	proj.classname = "plasma";
	proj.owner = proj.realowner = mowner;
	proj.use = W_Plasma_Explode;
	proj.think = adaptor_think2use_hittype_splash;
	proj.bot_dodge = TRUE;
	proj.bot_dodgerating = autocvar_g_balance_electro_secondary_damage;
	proj.nextthink = time + autocvar_g_balance_electro_secondary_lifetime + 360 + (60 * random());
	PROJECTILE_MAKETRIGGER(proj);
	proj.projectiledeathtype = WEP_ELECTRO | HITTYPE_SECONDARY;
	setorigin(proj, w_shotorg);

	//proj.glow_size = 50;
	//proj.glow_color = 45;
	proj.movetype = MOVETYPE_BOUNCE;
	W_SetupProjectileVelocityEx(proj, direction, v_up, autocvar_g_balance_electro_secondary_speed, 0, 0, 0.025, FALSE);
	proj.touch = W_Plasma_Touch;
	setsize(proj, '0 0 -4', '0 0 -4');
	proj.takedamage = DAMAGE_YES;
	proj.damageforcescale = autocvar_g_balance_electro_secondary_damageforcescale;
	proj.health = autocvar_g_balance_electro_secondary_health;
	proj.event_damage = W_Plasma_Damage;
	proj.flags = FL_PROJECTILE;
	proj.damagedbycontents = (autocvar_g_balance_electro_secondary_damagedbycontents);

	proj.bouncefactor = autocvar_g_balance_electro_secondary_bouncefactor;
	proj.bouncestop = autocvar_g_balance_electro_secondary_bouncestop;
	proj.missile_flags = MIF_SPLASH | MIF_ARC;

#if 0
	entity p2;
	p2 = spawn();
	copyentity(proj, p2);
	setmodel(p2, "models/ebomb.mdl");
	setsize(p2, proj.mins, proj.maxs);
#endif

	CSQCProjectile(proj, TRUE, PROJECTILE_ELECTRO, FALSE); // no culling, it has sound

	other = proj; MUTATOR_CALLHOOK(EditProjectile);
}

void multitool_energy_FragsOverTime (void)
{
	//print("Here\n");
	//Start Grenade Fragmentation
	float	sc;
	for (sc = 0;sc < self.count;sc = sc + 1) {
		multitool_random_Electro_Attack2(self, self.subordinate);	
	}
	self.cnt = self.cnt + self.count;
	self.nextthink = time;
	if (self.cnt >= 200)
		remove(self);
	//Finish Grenade Fragmentation
}


void multitool_energy_FragsOverTimeSpawn (entity gren, entity atkr)
{
	entity e;
	e = spawn();
	//e.owner = e.realowner = gren.realowner;
	e.subordinate = atkr;
	e.origin = gren.origin;
	setorigin(e, e.origin);
	e.think = multitool_energy_FragsOverTime;
	e.count = floor(200 / 40)+1;
	e.nextthink = time; //Start Right Away
	e.cnt = 0;
	remove(gren);
}

//For small tanks
void multitool_energysmall_FragsOverTime (void)
{
	//print("Here\n");
	//Start Grenade Fragmentation
	float	sc;
	for (sc = 0;sc < self.count;sc = sc + 1) {
		multitool_random_Electro_Attack2(self, self.subordinate);	
	}
	self.cnt = self.cnt + self.count;
	self.nextthink = time;
	if (self.cnt >= 20)
		remove(self);
	//Finish Grenade Fragmentation
}


void multitool_energysmall_FragsOverTimeSpawn (entity gren, entity atkr)
{
	entity e;
	e = spawn();
	//e.owner = e.realowner = gren.realowner;
	e.subordinate = atkr;
	e.origin = gren.origin;
	setorigin(e, e.origin);
	e.think = multitool_energysmall_FragsOverTime;
	e.count = floor(200 / 40)+1;
	e.nextthink = time; //Start Right Away
	e.cnt = 0;
	remove(gren);
}

float multitool_isdragable(float mytype)
{
	if (mytype != MTB64U_FURN_COMCRATE
	&& mytype != MTB64U_FURN_COMCRATE2
	&& mytype != MTB64U_FURN_MTLCRATE
	&& mytype != MTB64U_FURN_TOILET
	&& mytype != MTB64U_FURN_TOILET2
	&& mytype != MTB64U_FURN_TOILET3
	&& mytype != MTB64U_FURN_BSCKCABINET1
	&& mytype != MTB64U_FURN_BSCKCABINETTOP1
	&& mytype != MTB64U_FURN_BSCKCABINETTOPDEEP1
	&& mytype != MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
	&& mytype != MTB64U_FURN_BSCKCABINETTOPSHORT1
	&& mytype != MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
	&& mytype != MTB64U_FURN_BSCKCABINET2
	&& mytype != MTB64U_FURN_BSCKCABINET3
	&& mytype != MTB64U_FURN_BSCKCABINET4
	&& mytype != MTB64U_FURN_BSCKCABINETCORNER1
	&& mytype != MTB64U_FURN_BSCKCABINETCORNER2
	&& mytype != MTB64U_FURN_BSCKCABINETCORNERTOP1
	&& mytype != MTB64U_FURN_BSCKCABINETCORNERTOP2
	&& mytype != MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
	&& mytype != MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
	&& mytype != MTB64U_FURN_BSCKCABINETBAR1
	&& mytype != MTB64U_FURN_BSCKCABINETBARENDR
	&& mytype != MTB64U_FURN_BSCKCABINETBARENDL
	&& mytype != MTB64_FURN_EMPTYSHELF_WOOD
	&& mytype != MTB64_FURN_BOOKSHELF_WOOD
	&& mytype != MTB64_FURN_BLKSMHFORGE
	&& mytype != MTB64_FURN_BLKSMHANVIL
	&& mytype != MTB64_FURN_IRONMAIDEN
	&& mytype != MTB64_FURN_SPIKEDRACK
	&& mytype != MTB64_FURN_IMPALEMENTPOLE
	&& mytype != MTB64_FURN_GIBBET
	&& mytype != MTB64_FURN_GREEKPILLAR
	&& mytype != MTB64_FURN_GREEKPILLARM
	&& mytype != MTB64_FURN_ROMANCOLUMN
	&& mytype != MTB64_FURN_ROMANCOLUMNM
	&& mytype != MTB64_FURN_IRONBRAZIER
	&& mytype != MTB64U_FURN_SINK
	&& mytype != MTB64U_FURN_SINK2
	&& mytype != MTB64U_FURN_SINK_PED
	&& mytype != MTB64U_FURN_SINK_PED2
	&& mytype != MTB64U_FURN_SHOWER
	&& mytype != MTB64U_FURN_STOVE
	&& mytype != MTB64U_FURN_STOVE2
	&& mytype != MTB64U_FURN_STOVE3
	&& mytype != MTB64U_FURN_STOVE4) {
		//If we're not huge crates or massive computers, perhaps we are dragable
		if (multitool_isfurniture(mytype)) {
			return TRUE;
		} else {
			return FALSE;
		}
	} else {
		return FALSE;
	}
}

float multitool_isfurniture(float mytype)
{
	if (mytype == MTB64U_FURN_CHAIR
	|| mytype == MTB64U_FURN_CHAIR2
	|| mytype == MTB64U_FURN_CHAIR3
	|| mytype == MTB64U_FURN_CHAIR4
	|| mytype == MTB64U_FURN_CHAIR5
	|| mytype == MTB64U_FURN_SCHAIR
	|| mytype == MTB64U_FURN_OMLCHAIR
	|| mytype == MTB64U_FURN_OMLCHAIR2
	|| mytype == MTB64U_FURN_MLHSKCHAIR
	|| mytype == MTB64U_FURN_TRIBECACHAIR
	|| mytype == MTB64U_FURN_BARCELONACHAIR
	|| mytype == MTB64U_FURN_STOOL
	|| mytype == MTB64U_FURN_CSTOOL
	|| mytype == MTB64U_FURN_RETROCHAIR
	|| mytype == MTB64U_FURN_PLSCHAIR
	|| mytype == MTB64U_FURN_SCHINTGRDESK
	|| mytype == MTB64U_FURN_SCHDESKCHAIR
	|| mytype == MTB64U_FURN_RETROTABLE
	|| mytype == MTB64U_FURN_TABLESQUARE
	|| mytype == MTB64U_FURN_TABLECIRC
	|| mytype == MTB64U_FURN_TABLELONG
	|| mytype == MTB64U_FURN_CRATE
	|| mytype == MTB64U_FURN_BARRELP
	|| mytype == MTB64U_FURN_BARRELM
	|| mytype == MTB64U_FURN_TABLEGLASS
	|| mytype == MTB64U_FURN_DESK
	|| mytype == MTB64U_FURN_MGSTDESK
	|| mytype == MTB64U_FURN_MGSTDESKFLAT
	|| mytype == MTB64U_FURN_MGSTDESKFULLCORNER
	|| mytype == MTB64U_FURN_TABLE
	|| mytype == MTB64U_FURN_TABLELOW
	|| mytype == MTB64U_FURN_SHELVES
	|| mytype == MTB64U_FURN_SERVER
	|| mytype == MTB64U_FURN_LAMP_STREET
	|| mytype == MTB64U_FURN_LAMP_STREET2
	|| mytype == MTB64U_FURN_LAMP_STREET3
	|| mytype == MTB64U_FURN_LAMP_STREET4
	|| mytype == MTB64U_FURN_LAMP_STREET5
	|| mytype == MTB64U_FURN_COMCRATE
	|| mytype == MTB64U_FURN_COMCRATE2
	|| mytype == MTB64U_FURN_MTLCRATE
	|| mytype == MTB64_FURN_CHAIR_WOOD
	|| mytype == MTB64_FURN_CHAIR_WOOD2
	|| mytype == MTB64_FURN_STOOL_WOOD
	|| mytype == MTB64_FURN_TABLE_OCT_WOOD
	|| mytype == MTB64_FURN_TABLE_OCT_WOOD2
	|| mytype == MTB64_FURN_BARREL_WOOD
	|| mytype == MTB64_FURN_BARREL_WOOD2
	|| mytype == MTB64_FURN_BENCH_WOOD
	|| mytype == MTB64_FURN_TABLE_WOOD2
	|| mytype == MTB64_FURN_TABLE_WOOD3
	|| mytype == MTB64_FURN_BLKSMHBELLOWS
	|| mytype == MTB64_FURN_BLKSMHFORGE
	|| mytype == MTB64_FURN_BLKSMHANVIL
	|| mytype == MTB64_FURN_BLKSMHGRNDSTN
	|| mytype == MTB64_FURN_GREEKPILLAR
	|| mytype == MTB64_FURN_GREEKPILLARM
	|| mytype == MTB64_FURN_ROMANCOLUMN
	|| mytype == MTB64_FURN_ROMANCOLUMNM
	|| mytype == MTB64_FURN_IRONBRAZIER
	|| mytype == MTB64_FURN_WORKBENCH
	|| mytype == MTB64_FURN_BED_WOOD
	|| mytype == MTB64_FURN_TABLE_WOOD
	|| mytype == MTB64_FURN_EMPTYSHELF_WOOD
	|| mytype == MTB64_FURN_BOOKSHELF_WOOD
	|| mytype == MTB64_FURN_CHEST_WOOD
	|| mytype == MTB64_FURN_CHESTLARGE_WOOD
	|| mytype == MTB64U_FURN_TOILET
	|| mytype == MTB64U_FURN_TOILET2
	|| mytype == MTB64U_FURN_TOILET3
	|| mytype == MTB64U_FURN_SINK
	|| mytype == MTB64U_FURN_SINK2
	|| mytype == MTB64U_FURN_SINK_PED
	|| mytype == MTB64U_FURN_SINK_PED2
	|| mytype == MTB64U_FURN_SHOWER
	|| mytype == MTB64_FURN_CHAIR_FANCY1
	|| mytype == MTB64_FURN_CHAIR_FANCY2
	|| mytype == MTB64_FURN_CHAIR_FANCY3
	|| mytype == MTB64_FURN_CHAISELOUNGE
	|| mytype == MTB64_FURN_IRONMAIDEN
	|| mytype == MTB64_FURN_SPIKEDRACK
	|| mytype == MTB64_FURN_IMPALEMENTPOLE
	|| mytype == MTB64_FURN_GIBBET
	|| mytype == MTB64U_FURN_STOVE
	|| mytype == MTB64U_FURN_STOVE2
	|| mytype == MTB64U_FURN_STOVE3
	|| mytype == MTB64U_FURN_STOVE4
	|| mytype == MTB64U_FURN_FILECABINET
	|| mytype == MTB64U_FURN_FRIDGE
	|| mytype == MTB64U_FURN_FRIDGE2
	|| mytype == MTB64U_FURN_FRIDGE3
	|| mytype == MTB64U_FURN_FRIDGE4
	|| mytype == MTB64U_FURN_BSCKCABINET1
	|| mytype == MTB64U_FURN_BSCKCABINETTOP1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEP1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORT1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
	|| mytype == MTB64U_FURN_BSCKCABINET2
	|| mytype == MTB64U_FURN_BSCKCABINET3
	|| mytype == MTB64U_FURN_BSCKCABINET4
	|| mytype == MTB64U_FURN_BSCKCABINETCORNER1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNER2
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP2
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
	|| mytype == MTB64U_FURN_BSCKCABINETBAR1
	|| mytype == MTB64U_FURN_BSCKCABINETBARENDR
	|| mytype == MTB64U_FURN_BSCKCABINETBARENDL
	|| mytype == MTB64U_FURN_FUTON
	|| mytype == MTB64U_FURN_BED
	|| mytype == MTB64U_FURN_BED_FOAM
	|| mytype == MTB64U_FURN_SOFA1BR
	|| mytype == MTB64U_FURN_SOFA3BR
	|| mytype == MTB64U_FURN_SOFA1B
	|| mytype == MTB64U_FURN_SOFA3B
	|| mytype == MTB64U_FURN_SOFA1LW
	|| mytype == MTB64U_FURN_SOFA3LW
	|| mytype == MTB64U_FURN_SOFA1LW2
	|| mytype == MTB64U_FURN_SOFA3LW2
	|| mytype == MTB64U_FURN_SOFA_FOAM
	|| mytype == MTB64U_FURN_SOFA_TARTAN
	|| mytype == MTB64U_FURN_SOFA_POOFY
	|| mytype == MTB64U_FURN_SOFA_NORM
	)
	{
		return TRUE;
	} else {
		return FALSE;
	}
	
}

float multitool_isdoor(float mytype)
{
	if (mytype == MTB64U_DOOR_R_STEEL
	|| mytype == MTB64U_DOOR_R_PLAIN
	|| mytype == MTB64U_DOOR_R_PLAIN2
	|| mytype == MTB64U_DOOR_R_GLASS
	|| mytype == MTB64_DOOR_R_WOOD
	|| mytype == MTB64_DOOR_R_JWOOD
	|| mytype == MTB64_DOOR_R_FWOOD
	|| mytype == MTB64_DOOR_R_IRONBAR
	|| mytype == MTB64_FITTEDWINDOW_CASTLE_ALOOP
	|| mytype == MTB64_FITTEDWINDOW_CASTLE_SWALL
	|| mytype == MTB64_FITTEDWINDOW_WINDOW
	|| mytype == MTB64U_FITTEDWINDOW_STEELSLIT
	|| mytype == MTB64U_FITTEDWINDOW_STEELPLATE
	|| mytype == MTB64U_FITTEDWINDOW_CWALL
	|| mytype == MTB64U_FITTEDWINDOW_UWINDOW)
	////|| mytype == 1524 || mytype == 1546 || mytype == 10709 || mytype == 10710) //Fence Mil Moving Gate, //not using as this is for centering which we don't do for those gates
	{
		return TRUE;
	} else {
		return FALSE;
	}
	
}

float multitool_iswooden(float mytype)
{
	//Thought about putting the black foam computer chair here but the foam has an anti-flammable substance in it, Melts, don't think it ignites without an accelerant
	//But then thought again, foam does melt, so ill add it
	//110, 111, 112 are wooden if autocvar_g_balance_multitool_ancientonly as it is a ballista then (made of wood)
	//MTB64_FURN_BLKSMHBELLOWS was removed from here as it would too quickly burn immediately when built near forge
	if (mytype == -2 || mytype == -3 || mytype == -4 || mytype == 501 || mytype == 502 || mytype == 503
	|| mytype == 540 || mytype == 541 || mytype == 542 || mytype == 543
	|| mytype == 10709
	|| mytype == 544 || mytype == 545 || mytype == 546 || mytype == 645 || mytype == 646 || mytype == 15
	|| mytype == 16 || mytype == 20 || mytype == 21 || mytype == 24 || mytype == 26 || mytype == MTB64_WINDOW_WOODBAR
	|| mytype == MTB64_STAKES_WOOD1
	|| mytype == MTB64_PLATFORMWOOD_8
	|| mytype == MTB64_PLATFORMWOOD_24
	|| mytype == MTB64_BWIRE
	|| mytype == -601 || mytype == -602 || mytype == -603 || mytype == -604 || mytype == -605
	|| mytype == -609 || mytype == MTB64_DOOR_R_WOOD || mytype == MTB64_DOOR_R_JWOOD || mytype == MTB64_DOOR_R_FWOOD
	|| mytype == MTB64_FURN_CHAIR_WOOD || mytype == MTB64_FURN_BED_WOOD || mytype == MTB64_FURN_TABLE_WOOD
	|| mytype == MTB64_FURN_CHAIR_WOOD2 || mytype == MTB64_FURN_BENCH_WOOD || mytype == MTB64_FURN_TABLE_WOOD2
	|| mytype == MTB64_FURN_TABLE_WOOD3 || mytype == MTB64_FURN_WORKBENCH
	|| mytype == MTB64_FURN_STOOL_WOOD
	|| mytype == MTB64_FURN_TABLE_OCT_WOOD
	|| mytype == MTB64_FURN_TABLE_OCT_WOOD2
	|| mytype == MTB64_FURN_BARREL_WOOD
	|| mytype == MTB64_FURN_BARREL_WOOD2
	|| mytype == MTB64_FURN_BLKSMHGRNDSTN
	|| mytype == MTB64U_FURN_FUTON || mytype == MTB64U_FURN_BED || mytype == MTB64U_FURN_SINK2
	|| mytype == MTB64_FURN_CHAIR_FANCY1 || mytype == MTB64_FURN_CHAIR_FANCY2
	|| mytype == MTB64_FURN_CHAIR_FANCY3 || mytype == MTB64_FURN_CHEST_WOOD
	|| mytype == MTB64_FURN_IMPALEMENTPOLE
	|| mytype == MTB64_FURN_CHESTLARGE_WOOD
	|| mytype == MTB64_FURN_CHAISELOUNGE
	|| mytype == MTB64_FURN_BOOKSHELF_WOOD
	|| mytype == MTB64_FURN_EMPTYSHELF_WOOD
	|| mytype == MTB64U_FURN_SOFA1BR
	|| mytype == MTB64U_FURN_SOFA3BR
	|| mytype == MTB64U_FURN_SOFA1B
	|| mytype == MTB64U_FURN_SOFA3B
	|| mytype == MTB64U_FURN_SOFA1LW
	|| mytype == MTB64U_FURN_SOFA3LW
	|| mytype == MTB64U_FURN_SOFA1LW2
	|| mytype == MTB64U_FURN_SOFA3LW2
	|| mytype == MTB64U_FURN_CHAIR2
	|| mytype == MTB64U_FURN_SOFA_FOAM
	|| mytype == MTB64U_FURN_SOFA_TARTAN
	|| mytype == MTB64U_FURN_SOFA_POOFY
	|| mytype == MTB64U_FURN_SOFA_NORM
	|| mytype == MTB64U_FURN_BED_FOAM
	|| mytype == MTB64U_FURN_CSTOOL
	|| mytype == MTB64U_FURN_SCHAIR
	|| mytype == MTB64U_FURN_OMLCHAIR
	|| mytype == MTB64U_FURN_OMLCHAIR2
	|| mytype == MTB64U_FURN_MLHSKCHAIR
	|| mytype == MTB64U_FURN_TRIBECACHAIR
	|| mytype == MTB64U_FURN_BARCELONACHAIR
	|| mytype == MTB64U_FURN_BSCKCABINET1
	|| mytype == MTB64U_FURN_BSCKCABINETTOP1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEP1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORT1
	|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
	|| mytype == MTB64U_FURN_BSCKCABINET2
	|| mytype == MTB64U_FURN_BSCKCABINET3
	|| mytype == MTB64U_FURN_BSCKCABINET4
	|| mytype == MTB64U_FURN_BSCKCABINETCORNER1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNER2
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP2
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
	|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
	|| mytype == MTB64U_FURN_BSCKCABINETBAR1
	|| mytype == MTB64U_FURN_BSCKCABINETBARENDR
	|| mytype == MTB64U_FURN_BSCKCABINETBARENDL
	|| mytype == MTB64_CLAIMSTONE
	|| (autocvar_g_balance_multitool_ancientonly && (mytype == 110 || mytype == 111 || mytype == 112))
	|| (mytype >= MTB64_SHINGLES2 && mytype <= MTB64_SHINGLES2LAST)
	|| (mytype >= MTB64_WOOD1 && mytype <= MTB64_WOOD1LAST)
	|| (mytype >= MTB64_WOOD2 && mytype <= MTB64_WOOD2LAST)
	|| (mytype >= MTB64_FILLED && mytype <= MTB64_FILLEDLAST)
	) {
		return TRUE;
	} else {
		return FALSE;
	}
}

//This one returns the damage (or nothing)
float multitool_pickaxedamageamnt(float mytype, float mydamage)
{
		if ((mytype >= MTB64FIRST && mytype <= MTB64LAST)
		|| (mytype >= MTB64UFIRST && mytype <= MTB64ULAST)) {
			//Can attack some Blocks, funishings, etc
			//NOT better than axe at damage (Axes are damage = damage * 0.05)
			//CAN attack more (small) things than axe, however (Axe is only for wood and similar)
			//Pickaxe can attack some bricks and some stone and some metal that axe cannot
			//Don't have explosives, but have a pickaxe, you might be in luck
			//But if the material is just too hard, or it's a full building
			//You'll have to go use siege weapons or explosives
			//Weaker the material vs pickaxe, higher the multiplier
			if (mytype >= MTB64_FILLED && mytype <= MTB64_FILLEDLAST) {
				mydamage = mydamage * 0.10; //Weak
			} else if (mytype == MTB64U_DOOR_R_PLAIN2) {
				//White door
				mydamage = mydamage * 0.04;  //(pickaxe) Wooden type resillancy :P
			} else if (mytype == MTB64U_DOOR_R_PLAIN) {
				mydamage = mydamage * 0.035; //Slight More than Wooden type resillancy :P
			} else if (mytype == MTB64U_DOOR_R_GLASS
				|| mytype == MTB64U_WINDOW_FUTURE
				|| mytype == MTB64U_WINDOW_FUTURE_X
				|| mytype == MTB64U_FITTEDWINDOW_UWINDOW
				|| mytype == MTB64U_CLAIMSTONE
				|| (mytype >= MTB64_SHINGLES && mytype <= MTB64_SHINGLESLAST)) {
				//Metalish door, corrogated, etc
				mydamage = mydamage * 0.0025;
			} else if (mytype >= MTB64_HEDGE && mytype <= MTB64_HEDGELAST) {
				mydamage = mydamage * 0.045; //Slightly easier to remove than wood
			} else if ((mytype >= MTB64U_CONCRETE && mytype <= MTB64U_CONCRETELAST)
				|| (mytype == MTB64U_CONCRETESQUARE)
				|| (mytype == MTB64U_PLATFORM_8)
				|| (mytype == MTB64U_PLATFORM_16)
				|| (mytype == MTB64U_PLATFORM_24)
				|| (mytype == MTB64U_PLATFORM_32)) {
				mydamage = mydamage * 0.01;
			} else if (mytype >= MTB64_POLISH && mytype <= MTB64_POLISHLAST) {
				mydamage = mydamage * 0.01;
			} else if ((mytype >= MTB64_SANDSTONE && mytype <= MTB64_SANDSTONELAST)
				|| (mytype == MTB64_SANDSTONEDARK)
				|| (mytype == MTB64_FURN_GREEKPILLAR)
				|| (mytype == MTB64_FURN_GREEKPILLARM)
				|| (mytype == MTB64_FURN_ROMANCOLUMN)
				|| (mytype == MTB64_FURN_ROMANCOLUMNM)
				|| (mytype >= MTB64_MARBLEWHITE && mytype <= MTB64_MARBLEWHITELAST)) {
				mydamage = mydamage * 0.01;
			} else if (multitool_isbuildingcurtainstone(mytype)) {
				mydamage = mydamage * 0.02;  //Mudbrick and cobble brick
				//Less resilliant than the concrete and sandstone pieces
			} else if(multitool_iswooden(mytype)) {
				mydamage = mydamage * 0.04;   //Wooden
			} else if (multitool_isfurniture(mytype)) {
				//Not wooden, is metal(ish) funrniture
				mydamage = mydamage * 0.0025;
				//Slightly more resilliant than sandstone stuff
			} else {
				//Omitting steel things
				//Omitting granite and strong stone
				//Omitting reinforced concrete
				mydamage = 0;
			}
		} else {
			//No mydamage if cannot be axed
			mydamage = 0;
		}
		
		return mydamage;
}

//These return true if can damage
float multitool_axecandamage(float mytype)
{
	if (mytype == MTB64U_DOOR_R_PLAIN2) {
		//Weak white door (plastic?), but not the metal one
		return(TRUE);
	} else if(multitool_iswooden(mytype)) {
		//We are wooden and...
		if (multitool_isdoor(mytype)) {
			return(TRUE);
		} else if (multitool_isfurniture(mytype)) {
			return(TRUE);
		} else {
			return(FALSE);
		}
	} else {
		return(FALSE);
	}
}

float multitool_powersawcandamage(float mytype)
{
	//Superset of axe+more
	//Can take on some more things
	if (multitool_axecandamage(mytype)) {
		return(TRUE);
	} else if ((mytype == MTB64_WINDOW_WOODBAR)
	|| (mytype == MTB64_PLATFORMWOOD_8)
	|| (mytype == MTB64_PLATFORMWOOD_24)
	|| (mytype == MTB64_CLAIMSTONE)
	|| (mytype >= MTB64_SHINGLES2 && mytype <= MTB64_SHINGLES2LAST)
	|| (mytype >= MTB64_WOOD1 && mytype <= MTB64_WOOD1LAST)
	|| (mytype >= MTB64_WOOD2 && mytype <= MTB64_WOOD2LAST)) {
		//Some extra things the powersaw can damage
		//(BTW: Medieval "claimstone" block is made of wood, so yes it is right to be here)
		return(TRUE);
	} else {
		return(FALSE);
	}
}

float multitool_chainsawcandamage(float mytype)
{
	//Superset of powersaw+axe+more
	//Can take on the most things of the 3
	if (multitool_powersawcandamage(mytype)) {
		return(TRUE);
	} else if ((mytype == MTB64_STAKES_WOOD1)
	|| (mytype >= MTB64_HEDGE && mytype <= MTB64_HEDGELAST)) {
		//Some extra things the chainsaw can make mince of
		return(TRUE);
	} else {
		return(FALSE);
	}
}

float multitool_evaldamage_isexplosive(float deathtype)
{
	//Suitable explosive?
	if (deathtype != DEATH_GRENADE)
	{
		if (Damage_eval_isexplosive(deathtype))
		{
			return(TRUE);
		} else {
			return(FALSE);
		}
	} else {
		return(FALSE);
	}
}

float multitool_evaldamage(float damage, float deathtype, float mytype)
{
    
	if (multitool_evaldamage_isexplosive(deathtype))
	{
		//EXPLOSIVES
		//No Damage reduction
	} else if (deathtype == DEATH_BATTERINGRAM)
	{
		if (mytype >= 550 && mytype <= 559) {
			//Damage reduction for Berms
			damage = damage * 0.05;
		} else if (mytype >= 540 && mytype <= 549) {
			//Damage reduction for Palisade
			damage = damage * 0.75;
		}
	} else if(DEATH_ISWEAPON(deathtype, WEP_CHAINSAW)) {
		if (multitool_chainsawcandamage(mytype)) {
			//Some smaller Wooden etc stuff chainsawable
			damage = damage * 0.5;
		} else {
			//No damage if cannot be chainsawed
			damage = 0;
		}
	} else if(DEATH_ISWEAPON(deathtype, WEP_POWERSAW)) {
		if (multitool_powersawcandamage(mytype)) {
			//Some smaller Wooden etc stuff chainsawable
			damage = damage * 0.15;
		} else {
			//No damage if cannot be chainsawed
			damage = 0;
		}
	} else if(DEATH_ISWEAPON(deathtype, WEP_BROADAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_WOODAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_DOUBLEBITAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_AXE)
		|| DEATH_ISWEAPON(deathtype, WEP_BEARDEDAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_BATTLEAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_TEMPLARAXE)
		|| DEATH_ISWEAPON(deathtype, WEP_SKIRMISHERSAXE)
		|| (DEATH_ISWEAPON(deathtype, WEP_POLEAXE) && (deathtype & HITTYPE_SECONDARY))
		|| (DEATH_ISWEAPON(deathtype, WEP_BARDICHE) && (deathtype & HITTYPE_SECONDARY))
		|| DEATH_ISWEAPON(deathtype, WEP_WARAXE)) {
		//Large Axes only, not hatchets or small axes.
		if (multitool_axecandamage(mytype)) {
			//Some smaller Wooden etc stuff, axeable
			damage = damage * 0.05;
		} else {
			//No damage if cannot be axed
			damage = 0;
		}
	} else if(DEATH_ISWEAPON(deathtype, WEP_PICKAXE))
	{
		damage = multitool_pickaxedamageamnt(mytype, damage);
	} else if (deathtype == DEATH_VHCRUSH)
	{
		if (multitool_isfurniture(mytype))
		{
			if (mytype == MTB64U_FURN_SERVER
			|| mytype == MTB64U_FURN_COMCRATE
			|| mytype == MTB64U_FURN_COMCRATE2
			|| mytype == MTB64U_FURN_MTLCRATE)
			{
				damage = damage * 0.005;
			}
			else if (mytype == MTB64U_FURN_STOVE
			|| mytype == MTB64U_FURN_STOVE2
			|| mytype == MTB64U_FURN_STOVE3
			|| mytype == MTB64U_FURN_STOVE4
			)
			{
				damage = damage * 0.3;
			}
			else if (mytype == MTB64U_FURN_FRIDGE
			|| mytype == MTB64U_FURN_FRIDGE2
			|| mytype == MTB64U_FURN_FRIDGE3
			|| mytype == MTB64U_FURN_FRIDGE4
			|| mytype == MTB64U_FURN_BSCKCABINET1
			|| mytype == MTB64U_FURN_BSCKCABINETTOP1
			|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEP1
			|| mytype == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
			|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORT1
			|| mytype == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
			|| mytype == MTB64U_FURN_BSCKCABINET2
			|| mytype == MTB64U_FURN_BSCKCABINET3
			|| mytype == MTB64U_FURN_BSCKCABINET4
			|| mytype == MTB64U_FURN_BSCKCABINETCORNER1
			|| mytype == MTB64U_FURN_BSCKCABINETCORNER2
			|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP1
			|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOP2
			|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
			|| mytype == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
			|| mytype == MTB64U_FURN_BSCKCABINETBAR1
			|| mytype == MTB64U_FURN_BSCKCABINETBARENDR
			|| mytype == MTB64U_FURN_BSCKCABINETBARENDL
			|| mytype == MTB64U_FURN_DESK
			|| mytype == MTB64U_FURN_LAMP_STREET
			|| mytype == MTB64U_FURN_LAMP_STREET2
			|| mytype == MTB64U_FURN_LAMP_STREET3
			|| mytype == MTB64U_FURN_LAMP_STREET4
			|| mytype == MTB64U_FURN_LAMP_STREET5
			|| mytype == MTB64U_FURN_MGSTDESK
			|| mytype == MTB64U_FURN_MGSTDESKFLAT
			|| mytype == MTB64U_FURN_MGSTDESKFULLCORNER
			|| mytype == MTB64U_FURN_TABLE
			|| mytype == MTB64U_FURN_TABLELOW
			|| mytype == MTB64U_FURN_SHELVES
			|| mytype == MTB64U_FURN_FILECABINET
			|| mytype == MTB64U_FURN_CRATE
			|| mytype == MTB64U_FURN_BARRELM
			|| mytype == MTB64U_FURN_TABLEGLASS
			|| mytype == MTB64U_FURN_CHAIR
			|| mytype == MTB64U_FURN_CHAIR3
			|| mytype == MTB64U_FURN_CHAIR4
			|| mytype == MTB64U_FURN_CHAIR5
			|| mytype == MTB64U_FURN_STOOL
			|| mytype == MTB64U_FURN_CSTOOL
			|| mytype == MTB64U_FURN_RETROCHAIR
			|| mytype == MTB64U_FURN_PLSCHAIR
			|| mytype == MTB64U_FURN_SCHINTGRDESK
			|| mytype == MTB64U_FURN_SCHDESKCHAIR
			|| mytype == MTB64U_FURN_RETROTABLE
			|| mytype == MTB64U_FURN_SCHAIR
			|| mytype == MTB64U_FURN_OMLCHAIR
			|| mytype == MTB64U_FURN_OMLCHAIR2
			|| mytype == MTB64U_FURN_MLHSKCHAIR
			|| mytype == MTB64U_FURN_TRIBECACHAIR
			|| mytype == MTB64U_FURN_BARCELONACHAIR
			|| mytype == MTB64U_FURN_TABLESQUARE
			|| mytype == MTB64U_FURN_TABLECIRC
			|| mytype == MTB64U_FURN_TABLELONG
			)
			{
				damage = damage * 0.5;
			} else { 
				//No Reduction
			}
		} else {
			damage = 0;
		}
	} else if (DEATH_ISWEAPON(deathtype, WEP_NUKE_LAYER))
	{
		//NUKE
		//No Damage reduction
	} else if ((multitool_iswooden(mytype))
	&& (DEATH_ISWEAPON(deathtype, WEP_FIREBALL)
	|| DEATH_ISWEAPON(deathtype, WEP_FLAMETHROWER)
	|| deathtype == DEATH_MONSTER_HELLKNIGHT_FIREBALL
	|| deathtype == DEATH_FIRE
	|| deathtype == WEP_TORCH + HITTYPE_SECONDARY
	|| deathtype == DEATH_LAVA
	))
	{
		//FIRE
		//print("wooddamage\n");
		//Damage reduction only for 2 hangars
		if (mytype == 15 || mytype == 16)
		{
			damage = damage * 0.4;
		} else if (mytype == 21) //Siege workshop
		{
			damage = damage * 0.6;
		} 
	} else {
		damage = 0;
	}


    return damage;
}

void multitool_buildingfall(entity bldng)
{
	local entity e, oslf;
	e = spawn();
	e.origin = bldng.origin;
	e.angles = bldng.angles;
	e.fixangle = TRUE;
	
	e.model = bldng.model;
	e.solid = SOLID_BSP;
	e.mins = bldng.mins;
	e.maxs = bldng.maxs;
	
	e.team = bldng.team;
	e.scale = bldng.scale;
	e.skin = bldng.skin;
	e.colormod = bldng.colormod;
	e.colormap = bldng.colormap;
	
	oslf = self;
	self = e;
	setorigin(self, self.origin);
	if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
	self = oslf;
	
	e.health = (bldng.absmax_z - bldng.absmin_z) + 16;
	//print(ftos(e.health)," falling bldg healthheight\n");
	//print(ftos(bldng.absmax_z )," Max\n");
	//print(ftos(bldng.absmin_z )," Min\n");
		
	e.think = Foliage_Fall;
	e.nextthink = time;
}

void multitool_remove_rubble(entity targ)
{
	targ.alpha = -1;
			
	targ.solid = SOLID_NOT;
		
	targ.classname = "";
			
	setmodel(targ, "null");
	targ.model = string_null;
	
	targ.event_damage       = func_null;
   	targ.takedamage         = DAMAGE_NO;
    	targ.touch              = func_null;
    	targ.think              = func_null;
    	targ.deadflag           = DEAD_DEAD;
    	targ.solid      = SOLID_NOT;
	remove_safely(targ);
}

void multitool_destroyrubble (entity myself)
{
		if (myself.subordinate) {
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate.subordinate);
			
			if (myself.subordinate.subordinate)
				multitool_remove_rubble(myself.subordinate.subordinate);
				
			multitool_remove_rubble(myself.subordinate);
		}
		remove_safely(myself);
}

void multitool_rubble_damage(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
	entity previousself;
	self.subordinate4.dmg_time = time;
	
	damage = multitool_evaldamage(damage, deathtype, self.subordinate4.count);
	
	self.subordinate4.vehicle_health -= damage;
	
		if(damage && self.pushltime < time)  // prevent "snorring" sound lots of hits, also make sure there is damage
		{	
			float r;
			r = random() * 5;
			if (r > 4) {
				spamsound (self, CH_PAIN, "object/impact_stone_5.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 3) {
				spamsound (self, CH_PAIN, "object/impact_stone_4.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 2) {
				spamsound (self, CH_PAIN, "object/impact_stone_3.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 1) {
				spamsound (self, CH_PAIN, "object/impact_stone_2.ogg", VOL_BASE, ATTN_NORM);
			} else {
				spamsound (self, CH_PAIN, "object/impact_stone_1.ogg", VOL_BASE, ATTN_NORM);
			}
			self.pushltime = time + 0.2;
		}
	
	if (self.subordinate4.rubble_takedmg) {
		//We are allready set to take damage
		//No need to check start time vs time etc
		//we allready passed that
		//and tolled the variable below before
	} else {
		//We have not been set to take damage yet
		if ((self.subordinate4.rubble_starttime + 3) < time) {
			//The time has passed, we set the variable
			//We will act on the damage below
			self.subordinate4.rubble_takedmg = 1;
		} else {
			//The time has not passed
			//Don't do much yet. We DO tally the damage
			//We just don't act on it (see below)
			//Untill the time is past
		}
	}
		
	//sprint(self.owner.subordinate.realowner, (sprintf("Rubble Under Attack, Healt: %f\n", self.subordinate4.vehicle_health)));
	if(self.subordinate4.vehicle_health <= 0)
	{
		previousself = self;
		self = self.subordinate4;
		
		if (self.rubble_takedmg) {
			multitool_destroyrubble(self);
		} else {
			self.vehicle_health = 10;
		}
		
		self = previousself;
	}		
}

entity multitool_place_rubble (entity targ, vector offset, float dropdown)
{
	//Places the rubble, similar to the place scaffold code
	//e is the thing we are spawning, self is this spawner
	entity e, oldself;
	e = spawn();
	e.classname = "building";
	e.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
	e.subordinate4 = targ; //The master
	e.nopounddown = 1;
	e.rubble_is = 1; //is rubble
	
	if ((targ.count < 1000) || (targ.count >= 10000 && targ.count < 20000)) {
		if ((targ.count == -1 || targ.count == -5 || targ.count == 1 || targ.count == 2
		|| targ.count == 3 || targ.count == 4 || targ.count == 5)
		|| (targ.count >= 560 && targ.count <= 569)
		|| (targ.count >= 650 && targ.count <= 659)
		) {
			//Towers, Stronghold, curtainwall
			e.model = "maps/buildables/rubble_stone_512.bsp";
		} else if (targ.count == 10709) {
			//portcullis wood
			e.model = "maps/buildables/rubble_woodbar_block64.bsp";
		} else if (targ.count == 10710) {
			//portcullis iron
			e.model = "maps/buildables/rubble_ironbar_block64.bsp";
		} else if ((targ.count == 6 || targ.count == 7 || targ.count == 8
		|| targ.count == 10 || targ.count == 27)
		|| (targ.count >= 570 && targ.count <= 579)
		|| (targ.count >= 10700 && targ.count <= 10799)
		|| (targ.count >= 660 && targ.count <= 669)
		) {
			//Small Castle, Castle walls, round towers, Crusader Stronghold
			e.model = "maps/buildables/rubble_blackbrick_512.bsp";
		} else if ((targ.count == 11 || targ.count == 12)
		|| (targ.count >= 530 && targ.count <= 539)
		|| (targ.count >= 580 && targ.count <= 589)
		|| (targ.count >= 670 && targ.count <= 679)
		) {
			//Polish, Brickwall, Arsenal, Gmanse
			e.model = "maps/buildables/rubble_brick_512.bsp";
		} else if (targ.count >= 540 && targ.count <= 549) { //Palisade
			e.model = "maps/buildables/rubble_dirt_512.bsp";
		} else if (targ.count >= 550 && targ.count <= 559) { //Berm
			e.model = "maps/buildables/rubble_cliffstone_512.bsp";
		} else if (self.count == 17) { //Chataeu
			e.model = "maps/buildables/rubble_limestone_512.bsp";
		} else if (self.count == 18) { //PalladianManor
			e.model = "maps/buildables/rubble_wmarble_512.bsp";
		} else if (self.count == 503) {
			//Recruitment post
			e.model = "maps/buildables/rubble_woodbar_block64.bsp";
		} else if (self.count == -610) { //Iron Spikes Floor
			e.model = "maps/buildables/rubble_ironbeams_512.bsp";
		} else if ((targ.count <= -600 && targ.count > -1000) 
		|| (targ.count >= 610 && targ.count <= 619)
		|| (targ.count >= 640 && targ.count <= 649)) {
			//Floors, Wooden bridges
			e.model = "maps/buildables/rubble_woodbeams_512.bsp";
		} else if (targ.count >= 700 && targ.count <= MTB64BOUNDLAST) {
			//Blocks
			if (targ.count >= MTB64_FILLED && targ.count <= MTB64_FILLEDLAST) {
				e.model = "maps/buildables/rubble_filled_block64.bsp";
			} else if (targ.count >= MTB64_FILLED && targ.count <= MTB64_FILLEDLAST) {
				e.model = "maps/buildables/rubble_filled_block64.bsp";
			} else if (targ.count >= MTB64_SHINGLES && targ.count <= MTB64_SHINGLESLAST) {
				e.model = "maps/buildables/rubble_shingles_block64.bsp";
			} else  if (targ.count >= MTB64_SHINGLES2 && targ.count <= MTB64_SHINGLES2LAST) {
				e.model = "maps/buildables/rubble_shingles2_block64.bsp";
			} else if (targ.count >= MTB64_WOOD1 && targ.count <= MTB64_WOOD1LAST) {
				e.model = "maps/buildables/rubble_wood1_block64.bsp";
			} else if (targ.count >= MTB64_WOOD2 && targ.count <= MTB64_WOOD2LAST) {
				e.model = "maps/buildables/rubble_wood2_block64.bsp";
			} else if (targ.count >= MTB64_CURTAIN && targ.count <= MTB64_CURTAINLAST) {
				e.model = "maps/buildables/rubble_stone_block64.bsp";
			} else if ((targ.count >= MTB64_CASTLE && targ.count <= MTB64_CASTLELAST)
				|| (targ.count == MTB64_CASTLESQUARE)
				|| (targ.count == MTB64_FITTEDWINDOW_CASTLE_ALOOP)
				|| (targ.count == MTB64_FITTEDWINDOW_CASTLE_SWALL)) {
				e.model = "maps/buildables/rubble_blackbrick_block64.bsp";
			} else if (targ.count >= MTB64_POLISH && targ.count <= MTB64_POLISHLAST) {
				e.model = "maps/buildables/rubble_brick_block64.bsp";
			} else if (targ.count >= MTB64_GRAYSTONE && targ.count <= MTB64_GRAYSTONELAST) {
				e.model = "maps/buildables/rubble_graybrick_block64.bsp";
			} else if ((targ.count >= MTB64_SANDSTONE && targ.count <= MTB64_SANDSTONELAST)
				|| (targ.count == MTB64_SANDSTONEDARK)) {
				e.model = "maps/buildables/rubble_sandstonelight_block64.bsp";
			} else if (targ.count >= MTB64_MARBLEWHITE && targ.count <= MTB64_MARBLEWHITELAST) {
				e.model = "maps/buildables/rubble_wmarble_block64.bsp";
			} else if (multitool_isbuildingmarbleextra(targ.count)) {
				e.model = "maps/buildables/rubble_wmarble_block64.bsp";
			} else if (targ.count == MTB64_STAKES_WOOD1) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";
			} else if (targ.count == MTB64_PLATFORMWOOD_8
				|| targ.count == MTB64_PLATFORMWOOD_24) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";
			} else if (targ.count == MTB64_BWIRE) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";	
			} else if (targ.count == MTB64_WINDOW_WOODBAR) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";
			} else if (targ.count == MTB64_CLAIMSTONE) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";
			} else if (targ.count == MTB64_WINDOW_IRONBAR
			|| targ.count == MTB64_DOOR_R_IRONBAR
			|| targ.count == MTB64_FURN_BLKSMHANVIL
			|| targ.count == MTB64_FURN_IRONMAIDEN
			|| targ.count == MTB64_FURN_SPIKEDRACK
			|| targ.count == MTB64_FURN_IRONBRAZIER
			|| targ.count == MTB64_FURN_GIBBET) {
				e.model = "maps/buildables/rubble_ironbar_block64.bsp";
			} else if (targ.count == MTB64_DOOR_R_WOOD || targ.count == MTB64_DOOR_R_JWOOD || targ.count == MTB64_DOOR_R_FWOOD
			|| targ.count == MTB64_FURN_CHAIR_WOOD || targ.count == MTB64_FURN_CHAIR_FANCY1
			|| targ.count == MTB64_FURN_CHAIR_FANCY2 || targ.count == MTB64_FURN_CHAIR_FANCY3
			|| targ.count == MTB64_FURN_CHAISELOUNGE
			|| targ.count == MTB64_FURN_BED_WOOD || targ.count == MTB64_FURN_TABLE_WOOD
			|| targ.count == MTB64_FURN_CHAIR_WOOD2
			|| targ.count == MTB64_FURN_STOOL_WOOD
			|| targ.count == MTB64_FURN_TABLE_OCT_WOOD
			|| targ.count == MTB64_FURN_TABLE_OCT_WOOD2
			|| targ.count == MTB64_FURN_BARREL_WOOD
			|| targ.count == MTB64_FURN_BARREL_WOOD2
			|| targ.count == MTB64_FURN_BENCH_WOOD
			|| targ.count == MTB64_FURN_TABLE_WOOD2
			|| targ.count == MTB64_FURN_TABLE_WOOD3
			|| targ.count == MTB64_FURN_BLKSMHBELLOWS
			|| targ.count == MTB64_FURN_BLKSMHGRNDSTN
			|| targ.count == MTB64_FURN_WORKBENCH
			|| targ.count == MTB64_FURN_CHEST_WOOD
			|| targ.count == MTB64_FURN_CHESTLARGE_WOOD
			|| targ.count == MTB64_FURN_EMPTYSHELF_WOOD
			|| targ.count == MTB64_FURN_IMPALEMENTPOLE
			|| targ.count == MTB64_FURN_BOOKSHELF_WOOD) {
				e.model = "maps/buildables/rubble_woodbar_block64.bsp";
			} else {
				e.model = "maps/buildables/rubble_foundationstone_block64.bsp";
			}
		} else { //The rest
			e.model = "maps/buildables/rubble_foundationstone_512.bsp";
		}
	} else { //futuristic stuff
		if ((targ.count >= 1530 && targ.count <= 1539) ||
		    (targ.count >= 1630 && targ.count <= 1639) ||
		    (targ.count == 1542) ||
		    (targ.count == 1543) ||
		    (targ.count == 1548) ||
		    (targ.count == 1549)) { //Concrete wall, also concrete wall berm
			e.model = "maps/buildables/rubble_concretedark_512.bsp";
		} else if ((targ.count >= 1650 && targ.count <= 1659)
			|| (targ.count >= 1680 && targ.count <= 1685)) { //TresBridge, Metal vault celings
			e.model = "maps/buildables/rubble_steelbeams_512.bsp";
		} else if ((targ.count == 1501) || (targ.count >= 1550 && targ.count <= 1559)) { //Tanktraps
			e.model = "maps/buildables/rubble_concreteplain_512.bsp";
		} else if (self.count == 1502 || targ.count == 1546) {
			//Recruitment post, steel gate large
			e.model = "maps/buildables/rubble_metalbar_block64.bsp";
		} else if (targ.count >= MTB64UBOUNDFIRST && targ.count <= MTB64UBOUNDLAST) {
			if ((targ.count >= MTB64U_CONCRETE && targ.count <= MTB64U_CONCRETELAST)
			|| (targ.count == MTB64U_CONCRETESQUARE)
			|| (targ.count == MTB64U_PLATFORM_8)
			|| (targ.count == MTB64U_PLATFORM_16)
			|| (targ.count == MTB64U_PLATFORM_24)
			|| (targ.count == MTB64U_PLATFORM_32)
			|| (targ.count >= MTB64U_RCONCRETE && targ.count <= MTB64U_RCONCRETELAST)
			|| (targ.count == MTB64U_RCONCRETESQUARE)
			|| (targ.count == MTB64U_RCONCRETESQUARE2)
			|| (targ.count == MTB64U_FITTEDWINDOW_CWALL)) {
				e.model = "maps/buildables/rubble_concrete_block64.bsp";
			} else {
				e.model = "maps/buildables/rubble_metalbar_block64.bsp";
			}
		} else {
			e.model = "maps/buildables/rubble_concrete_512.bsp";
		}
	}
	
	if (multitool_isfurniture(targ.count))
	{
		//furniture rubble is smaller
		e.scale = 0.5;
	}
	
	e.solid = SOLID_BSP;
	e.origin_x = targ.origin_x + offset_x;
	e.origin_y = targ.origin_y + offset_y;
	e.origin_z = targ.origin_z + offset_z;
	
	if(dropdown)
	{
		entity tcr;
		tcr = spawn();
		tcr.origin = e.origin;
		traceline(tcr.origin + '0 0 256', tcr.origin - '0 0 10000', MOVE_WORLDONLY, tcr);
		e.origin = trace_endpos;
		remove(tcr);
	}
	
	setorigin(e, e.origin);
	oldself = self;
	self = e;
	
	if ((targ.count >= 570 && targ.count <= 579)
	|| (multitool_isbuildingcurtainstone(targ.count))
	|| (multitool_isbuildingcastlestoneextra(targ.count))
	|| (targ.count == 6) || (targ.count == 8)
	|| (targ.count == 7) || (targ.count == 10)
	|| (targ.count == 27)
	|| (targ.count >= 660 && targ.count <= 669)
	|| (targ.count >= 10700 && targ.count <= 10799)) {
		//print("castlecolors2\n");
		if (targ.multitool_castlecolor) {
			//print("castlecolorB\n");
			self.multitool_castlecolor = targ.multitool_castlecolor;
		}
		
		if (targ.count == 616 && targ.multitool_woodcolor) {
			//print("woodcolorB\n");
			self.multitool_woodcolor = targ.multitool_woodcolor;
			self.colormap = targ.colormap;
		}
	}
	
	if ((targ.count >= 700 && targ.count <= MTB64BOUNDLAST)
	|| (targ.count >= MTB64UBOUNDFIRST && targ.count <= MTB64UBOUNDLAST)) {
		//Passing on info
		if (targ.multitool_flipblock == 1) {
			//print("flipblockB\n");
			self.multitool_flipblock = 1;
			self.angles_x = 180;
			//In this case we need to move down from apparent origin, as blocks start at 0 and go to +64z, not centered. A flipped block... You get the idea
			//Done near flipblockC
			setorigin(self, self.origin);
		}
		if (targ.multitool_roofcolor) {
			//print("roofcolorB\n");
			self.multitool_roofcolor = targ.multitool_roofcolor;
			self.colormap = targ.colormap;
		}
		if (targ.multitool_flamecolor) {
			//print("flamecolorB\n");
			self.multitool_flamecolor = targ.multitool_flamecolor;
			self.colormap = targ.colormap;
		}
		if (targ.multitool_woodcolor) {
			//print("woodcolorB\n");
			self.multitool_woodcolor = targ.multitool_woodcolor;
			self.colormap = targ.colormap;
		}
		if (targ.multitool_marblecolor) {
			//print("marblecolorB\n");
			self.multitool_marblecolor = targ.multitool_marblecolor;
		}
		if (targ.multitool_castlecolor) {
			//print("castlecolorB\n");
			self.multitool_castlecolor = targ.multitool_castlecolor;
		}
		if (targ.multitool_sstonecolor) {
			//print("sstonecolorB\n");
			self.multitool_sstonecolor = targ.multitool_sstonecolor;
		}
		
		self.multitool_doorcenter = targ.multitool_doorcenter; //So we will set proper door frame
	}
	
	//gamemodel doesn't work for this, just clientmodel
        if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        self.solid = SOLID_BSP;
        self.movetype = MOVETYPE_PUSH;
	self.angles_y = targ.angles_y;
	
	
	
    	self.touch              = func_null;
    	self.event_damage       = multitool_rubble_damage;
    	//self.bot_attack         = TRUE;
    	self.takedamage         = DAMAGE_AIM;
    	self.deadflag           = DEAD_NO;
    	self.think              = func_null;

    	self.damageforcescale = 0.03;    	
	
	self = oldself;
	return e;
}

void multitool_create_rubble (entity targ, float maxhp)
{
	if ((targ.count == 20 || targ.count == 501 || targ.count == 502 || targ.count == 1002 || targ.count == 1007 || targ.count == 1009 || targ.count == 1013 || targ.count == 1038
	|| targ.count == 1014 || targ.count == 1015 || targ.count == 1020 || targ.count == 1025 || targ.count == 1027 || targ.count == 1029 || targ.count == 1030
	|| targ.count == 1031 || targ.count == 1032 || targ.count == 1033 || targ.count == 1034 || targ.count == 1035 || targ.count == 1510
	|| targ.count == MTB64U_ACT_OIL || targ.count == MTB64U_ACT_EXPL)
	|| (targ.count >= 520 && targ.count <= 529)
	|| (targ.count >= 1110 && targ.count <= 1119)
	|| (targ.count >= 1120 && targ.count <= 1129)
	|| (targ.count >= 1130 && targ.count <= 1139)
	|| (targ.count >= 1520 && targ.count <= 1529)
	|| (targ.count >= 110 && targ.count <= 119)
	|| (targ.count >= MTB64_HEDGE && targ.count <= MTB64_HEDGELAST)
	) {
		//No rubble for these types
		//Shield gen, Tankpad, ammodepot, Turrets, OilPump, Pylon, Solarpanel, Treesentry
		//Small energy tank
		//TensionWireTower
		//Hedge, Fence
		//Hedge Blocks
		return;
	}
	
	entity rubblemaster;
	//Main
	//self.count = targ.count;
	
	//make subordinat chain.
	rubblemaster = spawn();
	rubblemaster.vehicle_health = maxhp * 0.22;
	if (rubblemaster.vehicle_health < 2400) {
		rubblemaster.vehicle_health = 2400;
	}
	
	if ((targ.count >= 570 && targ.count <= 579)
	|| (multitool_isbuildingcurtainstone(targ.count))
	|| (multitool_isbuildingcastlestoneextra(targ.count))
	|| (targ.count == 6) || (targ.count == 8)
	|| (targ.count == 7) || (targ.count == 10)
	|| (targ.count == 27)
	|| (targ.count >= 660 && targ.count <= 669)
	|| (targ.count >= 10700 && targ.count <= 10799)) {
		//print("castlecolors3\n");
		if (targ.multitool_hitbox.multitool_castlecolor) {
			//print("castlecolorA\n");
			rubblemaster.multitool_castlecolor = targ.multitool_hitbox.multitool_castlecolor;
		}
		
		if (targ.count == 616 && targ.multitool_hitbox.multitool_woodcolor) {
			//print("woodcolorA\n");
			rubblemaster.multitool_woodcolor = targ.multitool_hitbox.multitool_woodcolor;
			rubblemaster.colormap = targ.multitool_hitbox.owner.colormap;
		}
	}
	
	if ((targ.count >= 700 && targ.count <= MTB64BOUNDLAST)
	|| (targ.count >= MTB64UBOUNDFIRST && targ.count <= MTB64UBOUNDLAST)) {
		//Passing on info
		if (targ.multitool_hitbox.multitool_flipblock == 1) {
			//print("flipblockA\n");
			rubblemaster.multitool_flipblock = 1;
		}
		if (targ.multitool_hitbox.multitool_roofcolor) {
			//print("roofcolorA\n");
			rubblemaster.multitool_roofcolor = targ.multitool_hitbox.multitool_roofcolor;
			rubblemaster.colormap = targ.multitool_hitbox.owner.colormap;
		}
		if (targ.multitool_hitbox.multitool_flamecolor) {
			//print("roofcolorA\n");
			rubblemaster.multitool_flamecolor = targ.multitool_hitbox.multitool_flamecolor;
			rubblemaster.colormap = targ.multitool_hitbox.owner.colormap;
		}
		if (targ.multitool_hitbox.multitool_woodcolor) {
			//print("woodcolorA\n");
			rubblemaster.multitool_woodcolor = targ.multitool_hitbox.multitool_woodcolor;
			rubblemaster.colormap = targ.multitool_hitbox.owner.colormap;
		}
		if (targ.multitool_hitbox.multitool_marblecolor) {
			//print("marblecolorA\n");
			rubblemaster.multitool_marblecolor = targ.multitool_hitbox.multitool_marblecolor;
		}
		if (targ.multitool_hitbox.multitool_castlecolor) {
			//print("castlecolorA\n");
			rubblemaster.multitool_castlecolor = targ.multitool_hitbox.multitool_castlecolor;
		}
		if (targ.multitool_hitbox.multitool_sstonecolor) {
			//print("sstonecolorA\n");
			rubblemaster.multitool_sstonecolor = targ.multitool_hitbox.multitool_sstonecolor;
		}
		
		rubblemaster.multitool_doorcenter = targ.multitool_hitbox.multitool_doorcenter; //So we will set proper door frame
	}
	rubblemaster.count = targ.count;
	rubblemaster.origin = targ.origin;
	
	rubblemaster.usealtorigin = 0; //Always no except..
	if ((targ.count >= 640 && targ.count <= 649) || (targ.count >= 1650 && targ.count <= 1659)) {
		//When it's Wooden bridges falling down, or the futuristic trestle
		rubblemaster.usealtorigin = 1; //Test
		rubblemaster.altorigin = targ.origin; //
			//Tracer
			local entity wbrtracer;
			wbrtracer = spawn();
			wbrtracer.origin = targ.origin;
			traceline(wbrtracer.origin + '0 0 2', wbrtracer.origin - '0 0 10000', MOVE_WORLDONLY, wbrtracer);
			rubblemaster.origin_z = trace_endpos_z; //Set origin
			//End tracer
			remove(wbrtracer);
	}
	
	rubblemaster.angles = targ.angles;
	rubblemaster.angles_y = targ.angles_y + 90; //In the scaffold code it is -90, so compensate
	rubblemaster.cnt = 0; //Will be used to track rebuilding progress
	rubblemaster.mins = '-128 -128 -32';
	rubblemaster.maxs = '128 128 128';
	rubblemaster.classname = "rubblemaster";
	
	rubblemaster.rubble_starttime = time;
	rubblemaster.rubble_takedmg = 0;
	
	rubblemaster.subordinate5 = targ.multitool_hitbox.realowner; //The owner
	//print(etos(targ.multitool_hitbox.realowner),"x hbft rowner\n");
	
	setorigin(rubblemaster, rubblemaster.origin);
	rubblemaster.subordinate = multitool_place_rubble (rubblemaster, '0 0 0', 0);
	if (targ.count == 7 || targ.count == 11 || targ.count == 17 || targ.count == 18
	|| targ.count == 27
	|| targ.count == 1005 || targ.count == 1012
	|| targ.count == 1017 || targ.count == 1018 || targ.count == 1019
	|| targ.count == 1022 || targ.count == 1023 || targ.count == 1024 || targ.count == 1026
	) {
	//Big Buildings
	rubblemaster.mins = '-512 -512 -256';
	rubblemaster.maxs = '512 512 512';
	rubblemaster.subordinate.subordinate = multitool_place_rubble (rubblemaster, '0 512 0', 1);
	rubblemaster.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '0 -512 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '512 0 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '-512 0 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '512 512 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '512 -512 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '-512 512 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '-512 -512 0', 1);	
	} else if (targ.count == 5 || targ.count == 6 || targ.count == 22 || targ.count == 1006) {
	//Medium Buildings
	rubblemaster.mins = '-256 -256 -128';
	rubblemaster.maxs = '256 256 400';
	rubblemaster.subordinate.subordinate = multitool_place_rubble (rubblemaster, '256 256 0', 1);
	rubblemaster.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '256 -256 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '-256 256 0', 1);
	rubblemaster.subordinate.subordinate.subordinate.subordinate.subordinate = multitool_place_rubble (rubblemaster, '-256 -256 0', 1);
	}
	
	return;
}

//Hitbox stuff
void multitool_damage_hitboxft(entity inflictor, entity attacker, float damage, float deathtype, vector hitloc, vector force)
{
		//print(etos(self.owner), ":entity  ",ftos(self.owner.solid)," SO: Solidtype\n");
		
		self.dmg_time = time;
	
		damage = multitool_evaldamage(damage, deathtype, self.owner.count);
		
		self.vehicle_health -= damage;
		
		//sprint(self.owner.subordinate.realowner, (sprintf("Tower Under Attack, Healt: %f\n", self.vehicle_health)));
		
		if(damage && self.pushltime < time)  // prevent "snorring" sound lots of hits, also make sure there is damage
		{	
			float r;
			r = random() * 5;
			if (r > 4) {
				spamsound (self, CH_PAIN, "object/impact_stone_5.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 3) {
				spamsound (self, CH_PAIN, "object/impact_stone_4.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 2) {
				spamsound (self, CH_PAIN, "object/impact_stone_3.ogg", VOL_BASE, ATTN_NORM);
			} else if (r > 1) {
				spamsound (self, CH_PAIN, "object/impact_stone_2.ogg", VOL_BASE, ATTN_NORM);
			} else {
				spamsound (self, CH_PAIN, "object/impact_stone_1.ogg", VOL_BASE, ATTN_NORM);
			}
			self.pushltime = time + 0.2;
		}

	if(self.vehicle_health <= 0)
	{
		self.event_damage       = func_null;
   		self.takedamage         = DAMAGE_NO;
    		self.touch              = func_null;
    		self.think              = func_null;
    		self.deadflag           = DEAD_DEAD;
    		self.solid      = SOLID_NOT;
		
		
		if (DEATH_ISWEAPON(deathtype, WEP_NUKE_LAYER) && !autocvar_g_balance_multitool_ondth_fx_survives_nuke) {
			//Do nothing
		} else {
			/////////////////////
			/////////////////////
			if (self.owner.trapondth) {
				if (allow_trapondth(self)) {
					trapspring_xyzz(self.owner.trapondth_trap, self.owner.trapondth_dirstyle, self.owner.trapondth_amnt, self, self.owner.origin+'0 0 64', attacker, 0.1);
				}
			}
			
			if(self.owner.spwnmnstrondth) {
				//
				//print("spwnmnstrondth for buildable");
				//monster_spwnmnstrondth(self.owner, 0.001, '0 0 0', 0); //Debug
				//
				monster_spwnmnstrondth(self.owner, 0.5+(frametime*5)+(random()*0.5), '0 0 0', 0);
			}
			
			if(self.owner.readscrollondth) {
				if (self.owner.readscrollondth_notdth) {
					//We must only be for onput or ontake
					//(traps)
				} else {
				//
				//print("readscrollondth for buildable");
				//monster_readscrollondth(self.owner, 0.001, '0 0 32', 0, 0); //Debug
				//
				monster_readscrollondth(self.owner, 0.01+frametime, '0 0 32', 0, -90);
				}
			}
			
			if(self.owner.xplodondth) {
				multitool_xplodondth(self.owner, self.origin+'0 0 32', attacker, PROJECTILE_BULLETSHRAPNELDARK);	
			}
			/////////////////////
			/////////////////////
		}
		
		//print(ftos(self.owner.count), " count ", self.owner.model, "\n");
		
		if(self.owner.count == 1010)
		{
			if (teamplay)
			{
				if (self.team == COLOR_TEAM1) {
					if (current_crude_team1) {
						current_crude_team1 = current_crude_team1 - (current_crude_team1*(OIL_TANK_CAPACITY/capacity_crude_team1));
					}
					capacity_crude_team1 = capacity_crude_team1 - OIL_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM2) {
					if (current_crude_team2) {
						current_crude_team2 = current_crude_team2 - (current_crude_team2*(OIL_TANK_CAPACITY/capacity_crude_team2));
					}
					capacity_crude_team2 = capacity_crude_team2 - OIL_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM3) {
					if (current_crude_team3) {
						current_crude_team3 = current_crude_team3 - (current_crude_team3*(OIL_TANK_CAPACITY/capacity_crude_team3));
					}
					capacity_crude_team3 = capacity_crude_team3 - OIL_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM4) {
					if (current_crude_team4) {
						current_crude_team4 = current_crude_team4 - (current_crude_team4*(OIL_TANK_CAPACITY/capacity_crude_team4));
					}
					capacity_crude_team4 = capacity_crude_team4 - OIL_TANK_CAPACITY;
				} else {
					if (current_crude_world) {
						current_crude_world = current_crude_world - (current_crude_world*(OIL_TANK_CAPACITY/capacity_crude_world));
					}
					capacity_crude_world = capacity_crude_world - OIL_TANK_CAPACITY;
				}
			} else {
				capacity_crude_world = capacity_crude_world - OIL_TANK_CAPACITY;
			}
			
			local entity expent;
			expent = spawn();
			expent.think = multitool_oilexplosion;
			expent.nextthink = time + 0.32 + random();
			expent.subordinate = attacker;
			setorigin(expent, self.origin+'0 0 32');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		}
		
		if(self.owner.count == MTB64U_ACT_OIL)
		{
			
			local entity expent;
			expent = spawn();
			expent.think = multitool_oildrumexplosion;
			expent.nextthink = time + 0.32 + random();
			expent.subordinate = attacker;
			setorigin(expent, self.origin+'0 0 32');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		}
		
		if(self.owner.count == MTB64U_ACT_EXPL)
		{
			
			local entity expent;
			expent = spawn();
			expent.think = multitool_expblockexplosion;
			expent.nextthink = time + 0.01 + (random() * 0.25);
			expent.subordinate = attacker;
			setorigin(expent, self.origin+'0 0 32');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		}
		
		if(self.owner.count == MTB64_FURN_IMPALEMENTPOLE
		|| self.owner.count == MTB64_FURN_IRONMAIDEN
		|| self.owner.count == MTB64_FURN_SPIKEDRACK
		|| self.owner.count == MTB64_FURN_GIBBET)
		{
			//Here we find players etc that are on or in the device
			//Then we "downgrade" them to a prisoner level 2
			//Otherwise they'll find themselves at or around the map origin
			//When the device is destroyed.
			//Good luck to them to find a prison 0 exit...
			//We locate the ent set as the ent that the prisoner level 3 is attached
			//since that is how these specific devices work
			local entity esrchfrtp3tor;
			local entity mysearchfortp3tor;
			if(self.owner.count == MTB64_FURN_IMPALEMENTPOLE) {
				//Locate the tp3tor;
				mysearchfortp3tor = self.owner.subordinate.subordinate.subordinate.subordinate.subordinate;
			} else if(self.owner.count == MTB64_FURN_IRONMAIDEN
			|| self.owner.count == MTB64_FURN_SPIKEDRACK) {
				//Locate the tp3tor;
				mysearchfortp3tor = self.owner.subordinate.subordinate.subordinate.subordinate;
			} else if (self.owner.count == MTB64_FURN_GIBBET) {
				//Locate the tp3tor;
				mysearchfortp3tor = self.owner.subordinate.subordinate.subordinate;
			}
			
			//print("fixingA\n");
			if (mysearchfortp3tor) { //Yes, I know "redundant". But we want to be careful
				//print("fixingB\n");
				
				esrchfrtp3tor = findchainfloat(prisonerlevel, 3);
				while (esrchfrtp3tor)
				{
					//print(etos(esrchfrtp3tor)," found\n");
					//print(etos(esrchfrtp3tor.prison3ent)," prison3ent\n");
					//print(etos(mysearchfortp3tor)," selectedent\n");
					
					//print(etos(self.owner.subordinate)," s_o.s\n");
					//print(etos(self.owner.subordinate.subordinate)," s_o.s.s\n");
					//print(etos(self.owner.subordinate.subordinate.subordinate)," s_o.s.s.s\n");
					//print(etos(self.owner.subordinate.subordinate.subordinate.subordinate)," s_o.s.s.s.s\n");
					//print(etos(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate)," s_o.s.s.s.s.s\n");
					//print(etos(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)," s_o.s.s.s.s.s.s\n");

					if (esrchfrtp3tor.prison3ent == mysearchfortp3tor) {
						print("fixing\n");
						if (esrchfrtp3tor != world) { //It won't be world, see the for... world is 0
							if (isPlayerOrMonsterByClassname(esrchfrtp3tor)) {
							//print("fixing2\n");
							esrchfrtp3tor.prisonerlevel = 2;
							esrchfrtp3tor.prison2spot = mysearchfortp3tor.origin;
							setorigin(esrchfrtp3tor, mysearchfortp3tor.origin);
							}
						}
					}
					esrchfrtp3tor = esrchfrtp3tor.chain;
				}
			}
		}
		
		if(self.owner.count == 1011)
		{			
			if (teamplay)
			{
				if (self.team == COLOR_TEAM1) {
					if (current_energy_team1) {
						current_energy_team1 = current_energy_team1 - (current_energy_team1*(ENERGY_TANK_CAPACITY/capacity_energy_team1));
					}
					capacity_energy_team1 = capacity_energy_team1 - ENERGY_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM2) {
					if (current_energy_team2) {
						current_energy_team2 = current_energy_team2 - (current_energy_team2*(ENERGY_TANK_CAPACITY/capacity_energy_team2));
					}
					capacity_energy_team2 = capacity_energy_team2 - ENERGY_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM3) {
					if (current_energy_team3) {
						current_energy_team3 = current_energy_team3 - (current_energy_team3*(ENERGY_TANK_CAPACITY/capacity_energy_team3));
					}
					capacity_energy_team3 = capacity_energy_team3 - ENERGY_TANK_CAPACITY;
				} else if (self.team == COLOR_TEAM4) {
					if (current_energy_team4) {
						current_energy_team4 = current_energy_team4 - (current_energy_team4*(ENERGY_TANK_CAPACITY/capacity_energy_team4));
					}
					capacity_energy_team4 = capacity_energy_team4 - ENERGY_TANK_CAPACITY;
				} else {
					if (current_energy_world) {
						current_energy_world = current_energy_world - (current_energy_world*(ENERGY_TANK_CAPACITY/capacity_energy_world));
					}
					capacity_energy_world = capacity_energy_world - ENERGY_TANK_CAPACITY;
				}
			} else {
				capacity_energy_world = capacity_energy_world - ENERGY_TANK_CAPACITY;
			}
			
			local entity expent;
			expent = spawn();
			setorigin(expent, self.origin+'0 0 512');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			//pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
			multitool_energy_FragsOverTimeSpawn(expent, attacker);
		}
		
		if (self.owner.multitoolresetgrate) {
			if (self.owner.multitoolresetgrate != world) {
				//print("Resetting grate generically\n");
				self.owner.multitoolresetgrate.pos2 = self.owner.multitoolresetgrate.pos1 - '0 0 488';
			}
		}
		
		local float myhousing;
		myhousing = multitool_getmyhousingamnt(self.owner.count);
		if(myhousing)
		{		
			if (teamplay)
			{
				if (self.team == COLOR_TEAM1) {
					//if (current_housing_team1) {
					//	current_housing_team1 = current_housing_team1 - (current_housing_team1*(myhousing/capacity_housing_team1));
					//}
					capacity_housing_team1 = capacity_housing_team1 - myhousing;
				} else if (self.team == COLOR_TEAM2) {
					//if (current_housing_team2) {
					//	current_housing_team2 = current_housing_team2 - (current_housing_team2*(myhousing/capacity_housing_team2));
					//}
					capacity_housing_team2 = capacity_housing_team2 - myhousing;
				} else if (self.team == COLOR_TEAM3) {
					//if (current_housing_team3) {
					//	current_housing_team3 = current_housing_team3 - (current_housing_team3*(myhousing/capacity_housing_team3));
					//}
					capacity_housing_team3 = capacity_housing_team3 - myhousing;
				} else if (self.team == COLOR_TEAM4) {
					//if (current_housing_team4) {
					//	current_housing_team4 = current_housing_team4 - (current_housing_team4*(myhousing/capacity_housing_team4));
					//}
					capacity_housing_team4 = capacity_housing_team4 - myhousing;
				} else {
					//if (current_housing_world) {
					//	current_housing_world = current_housing_world - (current_housing_world*(myhousing/capacity_housing_world));
					//}
					capacity_housing_world = capacity_housing_world - myhousing;
				}
			} else {
				capacity_housing_world = capacity_housing_world - myhousing;
			}
			
		}
		
		if(self.owner.count == 1016 || self.owner.count == 1017 || self.owner.count == 1018)
		{
			if (numberoflocalchemplants) {
				numberoflocalchemplants = numberoflocalchemplants - 1;
			}
		}
		
		if(self.owner.count == 1019)
		{
			if (numberoflocalmunitionsfactories) {
				numberoflocalmunitionsfactories = numberoflocalmunitionsfactories - 1;
			}
		}
		
		if(self.owner.count == 24
		|| self.owner.count == 25
		|| self.owner.count == 26
		|| self.owner.count == 1036)
		{
			if (numberoflocalforgebuildings) {
				numberoflocalforgebuildings = numberoflocalforgebuildings - 1;
			}
		}
		
		if(self.owner.count == 1021)
		{
			if (numberoffurnaces) {
				numberoffurnaces = numberoffurnaces - 1;
			}
		}
		
		if(self.owner.count == 1030)
		{
			if (numberoflocalenergybatterys) {
				numberoflocalenergybatterys = numberoflocalenergybatterys - 1;
			}
			
			local entity expent;
			expent = spawn();
			setorigin(expent, self.origin+'0 0 128');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			//pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
			multitool_energysmall_FragsOverTimeSpawn(expent, attacker);
		}
		
		if(self.owner.count == 1032)
		{
			if (numberoflocaloiltanks) {
				numberoflocaloiltanks = numberoflocaloiltanks - 1;
			}
			
			
			local entity expent;
			expent = spawn();
			expent.think = multitool_oilexplosionsmall;
			expent.nextthink = time + 0.32 + random();
			expent.subordinate = attacker;
			setorigin(expent, self.origin+'0 0 32');
			CSQCProjectile(expent, TRUE, PROJECTILE_GRENADE, TRUE);
			pointparticles(particleeffectnum("explosion_big"), self.origin, '0 0 0', 1);
		}
		
		if(sound_allowed(MSG_BROADCAST, attacker))
            		spamsound (self, CH_PAIN, "object/impact_stone_3.ogg", VOL_BASE, ATTN_NORM);
		
		if (DEATH_ISWEAPON(deathtype, WEP_NUKE_LAYER)) {
			if (self.vehicle_health > -190000) {
				multitool_create_rubble(self.owner, self.bldhitbx_max_health);
			} else {
				//Do noting
			}
		} else {
			if(self.owner.iscontainer || self.owner.multitool_forceinventory) {
				ContainerAllInventoryPinata(self.owner);
			}
			multitool_create_rubble(self.owner, self.bldhitbx_max_health);
		}
		
		if (DEATH_ISWEAPON(deathtype, WEP_NUKE_LAYER)) {
			//Do noting
		} else {
			multitool_buildingfall(self.owner);
		}
		
		if (self.owner.subordinate2) {
			self.owner.subordinate2.vehicle_norespawn = 1;
		}
		
		if (self.owner.subordinate2a) {
			self.owner.subordinate2a.vehicle_norespawn = 1;
		}
		
		if (self.owner.subordinate3) {
			self.owner.subordinate3.vehicle_norespawn = 1;
		}
		
		if (self.owner.subordinate3a) {
			self.owner.subordinate3a.vehicle_norespawn = 1;
		}
		
		if (self.owner.subordinate3b) {
			self.owner.subordinate3b.vehicle_norespawn = 1;
		}
		
		if(self.owner.count == 1110 || self.owner.count == 1111 || self.owner.count == 1112 || self.owner.count == 1113
		|| self.owner.count == 1114 || self.owner.count == 1115 || self.owner.count == 1116 || self.owner.count == 1117 || self.owner.count == 1118
		|| self.owner.count == 1120 || self.owner.count == 1121 || self.owner.count == 1122 || self.owner.count == 1123
		|| self.owner.count == 1124 || self.owner.count == 1125 || self.owner.count == 1126 || self.owner.count == 1127
		|| self.owner.count == 1130 || self.owner.count == 1131
		|| self.owner.count == 110  || self.owner.count == 111  || self.owner.count == 112)
		{
			if (self.owner.subordinate2)
			{
			local entity prevself;
			prevself = self;
			
			self = self.owner.subordinate2;
			if(self.owner)
            			if(self.vehicle_flags & VHF_DEATHEJECT)
                			vehicles_exit(VHEF_EJECT);
            		else
                		vehicles_exit(VHEF_RELESE);


        		antilag_clear(self);

        		self.vehicle_die();
	
			vehicles_remove();
			
			self = prevself;
			}
		}
		
		if(self.owner.count == 20)
		{
		//4 mountedgun turret buildings.
			if (self.owner.subordinate2)
			{
			local entity prevself;
			prevself = self;
			
			self = self.owner.subordinate2;
			if(self.owner)
            			if(self.vehicle_flags & VHF_DEATHEJECT)
                			vehicles_exit(VHEF_EJECT);
            		else
                		vehicles_exit(VHEF_RELESE);


        		antilag_clear(self);

        		self.vehicle_die();
	
			vehicles_remove();
			
			self = prevself;
			}
			
			if (self.owner.subordinate2a)
			{
			local entity prevself;
			prevself = self;
			
			self = self.owner.subordinate2a;
			if(self.owner)
            			if(self.vehicle_flags & VHF_DEATHEJECT)
                			vehicles_exit(VHEF_EJECT);
            		else
                		vehicles_exit(VHEF_RELESE);


        		antilag_clear(self);

        		self.vehicle_die();
	
			vehicles_remove();
			
			self = prevself;
			}
			//
			if (self.owner.subordinate3)
			{
			local entity prevself;
			prevself = self;
			
			self = self.owner.subordinate3;
			if(self.owner)
            			if(self.vehicle_flags & VHF_DEATHEJECT)
                			vehicles_exit(VHEF_EJECT);
            		else
                		vehicles_exit(VHEF_RELESE);


        		antilag_clear(self);

        		self.vehicle_die();
	
			vehicles_remove();
			
			self = prevself;
			}
			
			if (self.owner.subordinate3a)
			{
			local entity prevself;
			prevself = self;
			
			self = self.owner.subordinate3a;
			if(self.owner)
            			if(self.vehicle_flags & VHF_DEATHEJECT)
                			vehicles_exit(VHEF_EJECT);
            		else
                		vehicles_exit(VHEF_RELESE);


        		antilag_clear(self);

        		self.vehicle_die();
	
			vehicles_remove();
			
			self = prevself;
			}
		}
		
		if (self.owner.subordinate) {		
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
		
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
					
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
		
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
			
		
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
				
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate);
				
			if (self.owner.subordinate.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate.subordinate);
			
			if (self.owner.subordinate.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate.subordinate);
				
			if (self.owner.subordinate.subordinate)
				remove_mtextrasafely(self.owner.subordinate.subordinate);
				
		remove_mtextrasafely(self.owner.subordinate);
		}
		remove_mtextrasafely(self.owner);
		remove_mtextrasafely(self);
	}
}

void multitool_spawn_hitbox( entity tower, entity hitbox, vector min_s, vector max_s, float fwd_s, float tower_health)
{
    if (tower.multitool_flipblock == 1) {
    	//print("MTT FB 1\n");
	hitbox.multitool_flipblock = 1;
    }
    hitbox.owner              = tower;
    	hitbox.touch              = func_null;
    	hitbox.event_damage       = multitool_damage_hitboxft;
    hitbox.bot_attack         = TRUE;
    hitbox.iscreature         = FALSE; //TRUE;
    hitbox.teleportable       = FALSE; // no teleporting for towerles, too buggy
    hitbox.damagedbycontents	= TRUE;
    //hitbox.movetype           = MOVETYPE_WALK;
    hitbox.movetype           = MOVETYPE_NONE;
    hitbox.solid              = SOLID_TRIGGER;
    hitbox.takedamage         = DAMAGE_AIM;
    hitbox.deadflag           = DEAD_NO;
    hitbox.bot_attack         = TRUE;
    hitbox.flags              = FL_NOTARGET;
    hitbox.think              = func_null;
    hitbox.classname = "bldhitbx";
    hitbox.vehicle_health = tower_health;
    hitbox.bldhitbx_max_health = hitbox.vehicle_health;
    setsize(hitbox, min_s, max_s);
    makevectors(tower.angles_x * '-1 0 0' + tower.angles_y * '0 1 0' + tower.angles_z * '0 0 1'); //Inverted pitch on models
    setorigin(hitbox, (tower.origin + v_forward * fwd_s)); //Forward X qunits
    follow_sameorigin(hitbox, tower); //Follow tower
    
    hitbox.damageforcescale = 0.03;
    //hitbox.ballistics_density = autocvar_g_ballistics_density_stone;
}
//End Hitbox stuff

void multitool_spawnturret(entity e)
{
	if (e.count == 10) {
		self.multitool_reparableturret = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_turret_magicflac();
		} else {
			spawnfunc_turret_flac();
		}
	} else if (e.count == 8) {
		self.multitool_reparableturret = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_turret_magichellion();
		} else {
			spawnfunc_turret_hellion();
		}
	} else if (e.count == 2) {
		self.multitool_reparableturret = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_turret_magicplasma();
		} else {
			spawnfunc_turret_plasma();
		}
	} else if (e.count == 3) {
		self.multitool_reparableturret = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_turret_magicmlrs();
		} else {
			spawnfunc_turret_mlrs();
		}
	} else if (e.count == 1) {
		self.multitool_reparableturret = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_turret_magicmachinegun();
		} else {
			spawnfunc_turret_machinegun();
		}
	} else {
		self.multitool_reparableturret = 1;
		spawnfunc_turret_machinegun();
	}
}

void multitool_spawnflag(vector eov, entity e, entity oldself)
{
		self.model = "models/misc/penant.iqm";
		self.classname = "building";
		//not setting accptcrrdbldspltr
		self.origin = e.origin + eov;
		self.mins = ('-1.5 -1.5 0');
		self.maxs = ('1.5 1.5 128');
		self.solid = SOLID_SLIDEBOX;
        	self.movetype = MOVETYPE_PUSH;
		self.ballistics_density = autocvar_g_ballistics_density_wood;
		multitool_flag_colors(self, oldself.owner);
		setorigin(self, self.origin);
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
		//self.angles_y = e.angles_y; //Keep everything the same direction (wind)
}

void spawnfunc_info_player_team1();
void spawnfunc_info_player_team2();
void spawnfunc_info_player_team3();
void spawnfunc_info_player_team4();
void spawnfunc_item_armor_large (void);
void spawnfunc_item_armor_small (void);
void spawnfunc_item_health_large (void);
void spawnfunc_item_bullets (void);
void spawnfunc_item_rockets (void);
void spawnfunc_item_cells (void);
void spawnfunc_weapon_carbine();
void spawnfunc_weapon_lightcrossbow (void);
void spawnfunc_weapon_g98 (void);
void spawnfunc_weapon_m1903 (void);
void multitool_spawner()
{
	if (!self.count) {
		print("Multitool_Spawner: Warning No Selection Set On Spawner: ", etos(self), "\n");
		if (!self.origin_x
		&& !self.origin_y
		&& !self.origin_z)
		{
			print("Multitool_Spawner: Warning No Origin Set On Spawner Either, Removing: ", etos(self), "\n");
			self.think = func_null;
			self.nextthink = 0;
			remove_safely(self);
			return;
		}
	} else if (!self.origin_x
	&& !self.origin_y
	&& !self.origin_z)
	{
		print("Multitool_Spawner: Possible Error: (0 0 0) Origin Set On Spawner: ", etos(self), "\n However selection is set so this may be a deliberate building placement at map origin\n");
	}

	float trn, hitpoints, fbsrad;
	float nosnapangles;
	vector fbsorg, fbspot;
	entity e, oldself;
	e = spawn();
	e.classname = "building";
	e.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
	e.building_class = 0; //For at-start spawning of buildings. Medieval castles will influence class upwards(UC etc), others will be their real class, if anything, see below 
	e.count = self.count;
	float specialconsiderations;
	float ourmarblecolor;
	float ourcastlecolor;
	float oursstonecolor;
	float ourwoodcolor;
	float ourdoorcenter;
	specialconsiderations = 0;
	nosnapangles = 0;
	
	if (self.multitool_forcecolor) {
		//This is set by map spawned furnishings etc
		self.multitool_marblecolor = self.colormap;
		self.multitool_castlecolor = self.colormap;
		self.multitool_sstonecolor = self.colormap;
		self.multitool_woodcolor = self.colormap;
		self.multitool_roofcolor = self.colormap;
		self.multitool_flamecolor = self.colormap;
	}
	
	ourmarblecolor = self.multitool_marblecolor;
	ourcastlecolor = self.multitool_castlecolor;
	oursstonecolor = self.multitool_sstonecolor;
	ourwoodcolor = self.multitool_woodcolor;
	ourdoorcenter = self.multitool_doorcenter; //So we will set proper door frame
	
	if (self.multitool_forceangle) {
		//This is set by map spawned furnishings etc
		nosnapangles = 1;
	}
	
	if (self.count == MTB64_BWIRE) {
		if(autocvar_g_balance_multitool_ancientonly) {
			self.count = MTB64_STAKES_WOOD1;
		}
	}
	
	
	if (self.count == 1) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_turrettower_mg_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_turrettower_mg.bsp";
		}
		trn = -90;
		hitpoints = 25000;
	} else if (self.count == 2) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_turrettower_plasma_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_turrettower_plasma.bsp";
		}
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 3) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_turrettower_mlrs_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_turrettower_mlrs.bsp";
		}
		trn = -90;
		hitpoints = 40000;
	} else if (self.count == 4) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_garrison_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_garrison.bsp";
		}
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 5) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_stronghold_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_stronghold.bsp";
		}
		trn = -90;
		hitpoints = 200000;
	} else if (self.count == 6) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/building_strongtowertan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/building_strongtowerwhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/building_strongtowergreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/building_strongtowerbrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/building_strongtowerlighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/building_strongtowerblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/building_strongtowermauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/building_strongtowerpink.bsp";
		} else {
			e.model = "maps/buildables/building_strongtower.bsp";
		}
		trn = 0;
		hitpoints = 100000;
	} else if (self.count == 7) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/building_smallcastletan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/building_smallcastlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/building_smallcastlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/building_smallcastlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/building_smallcastlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/building_smallcastleblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/building_smallcastlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/building_smallcastlepink.bsp";
		} else {
			e.model = "maps/buildables/building_smallcastle.bsp";
		}
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 250000;
	} else if (self.count == 8) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/building_turrettower_helliontan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/building_turrettower_hellionwhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/building_turrettower_helliongreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/building_turrettower_hellionbrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/building_turrettower_hellionlighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/building_turrettower_hellionblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/building_turrettower_hellionmauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/building_turrettower_hellionpink.bsp";
		} else {
			e.model = "maps/buildables/building_turrettower_hellion.bsp";
		}
		trn = -90;
		hitpoints = 28500;
	} else if (self.count == 9) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_townhall_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_townhall.bsp";
		}
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 8000;
	} else if (self.count == 10) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/building_turrettower_hktan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/building_turrettower_hkwhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/building_turrettower_hkgreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/building_turrettower_hkbrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/building_turrettower_hklighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/building_turrettower_hkblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/building_turrettower_hkmauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/building_turrettower_hkpink.bsp";
		} else {
			e.model = "maps/buildables/building_turrettower_hk.bsp";
		}
		trn = -90;
		hitpoints = 29500;
	} else if (self.count == 11) {
		e.model = "maps/buildables/building_gmanse.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 100000;
	} else if (self.count == 12) {
		e.model = "maps/buildables/building_arsenal.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 40000;
	} else if (self.count == 13) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_barracks_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_barracks.bsp";
		}
		trn = -90;
		hitpoints = 15000;
	} else if (self.count == 14) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_church_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_church.bsp";
		}
		trn = -90;
		hitpoints = 23000;
	} else if (self.count == 15) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_oldhangar_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_oldhangar.bsp";
		}
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 16) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_oldtankhangar_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_oldtankhangar.bsp";
		}
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 17) {
		e.model = "maps/buildables/building_chataeu.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 100000;
	} else if (self.count == 18) {
		e.model = "maps/buildables/building_palladianmanor.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 100000;
	} else if (self.count == 19) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_stonehouse_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_stonehouse.bsp";
		}
		trn = -90;
		hitpoints = 7500;
	} else if (self.count == 20) {
		e.model = "maps/buildables/building_treetopsentry.bsp";
		trn = -90;
		hitpoints = 1000;
		e.requiresexist = self.requiresexist;
	} else if (self.count == 21) {
		e.model = "maps/buildables/building_siegeworkshop.bsp";
		trn = -90;
		hitpoints = 6500;
	} else if (self.count == 22) {
		e.model = "maps/buildables/building_gaol.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 200000;
	} else if (self.count == 23) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_smalljail_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_smalljail.bsp";
		}
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 24) {
		e.model = "maps/buildables/building_forge1.bsp";
		trn = -90;
		hitpoints = 6500;
	} else if (self.count == 25) {
		e.model = "maps/buildables/building_forge2.bsp";
		trn = -90;
		hitpoints = 20000;
	} else if (self.count == 26) {
		e.model = "maps/buildables/building_forge3.bsp";
		trn = -90;
		hitpoints = 6500;
	
	} else if (self.count == 27) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/building_crusaderstrongholdtan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/building_crusaderstrongholdwhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/building_crusaderstrongholdgreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/building_crusaderstrongholdbrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/building_crusaderstrongholdlighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/building_crusaderstrongholdblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/building_crusaderstrongholdmauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/building_crusaderstrongholdpink.bsp";
		} else {
			e.model = "maps/buildables/building_crusaderstronghold.bsp";
		}
		trn = -90;
		hitpoints = 250000;
	} else if (self.count == 110
		|| self.count == 111
		|| self.count == 112) {
		nosnapangles = 1;
		e.model = "null";
		trn = -90;
		hitpoints = 2060;
		//Point defense guns
	} else if (self.count == 501) {
		local float pc;
		local vector pv;
		pv = self.origin;
		pv_z = pv_z + 128; //16 worked
		pc = pointcontents(pv);
		if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
			//print("wasser\n");
			e.model = "maps/buildables/building_kelp.bsp";
			specialconsiderations = 1;
			hitpoints = 30000; //Supported by the water
		} else {
			e.model = "maps/buildables/building_barley.bsp";
			e.building_class = BUILDINGCLASS_RURALFARM;
			hitpoints = 3400;
		}
		trn = -90;
	} else if (self.count == 502) {
		e.model = "maps/buildables/building_vineyard.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_UC;
		trn = -90;
		hitpoints = 3400;
	} else if (self.count == 503) {
		e.model = "maps/buildables/recruitment_post.bsp";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == 520) {
		e.model = "maps/buildables/wall_hedge.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == 521) {
		e.model = "maps/buildables/wall_hedge_tower.bsp";
		trn = -90;
		hitpoints = 1600;
	} else if (self.count == 522) {
		e.model = "maps/buildables/wall_hedge_tower_round.bsp";
		trn = -90;
		hitpoints = 1600;
	} else if (self.count == 523) {
		e.model = "maps/buildables/wall_hedge_door.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == 530) {
		e.model = "maps/buildables/wall_brick.bsp";
		trn = -90;
		hitpoints = 5000;
	} else if (self.count == 531) {
		e.model = "maps/buildables/wall_brick_tower.bsp";
		trn = -90;
		hitpoints = 5200;
	} else if (self.count == 532) {
		e.model = "maps/buildables/wall_brick_tower_round.bsp";
		trn = -90;
		hitpoints = 5350;
	} else if (self.count == 533) {
		e.model = "maps/buildables/wall_brick_door.bsp";
		trn = -90;
		hitpoints = 5000;
	} else if (self.count == 540) {
		e.model = "maps/buildables/wall_palisade.bsp";
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 541) {
		e.model = "maps/buildables/wall_palisade_tower.bsp";
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 542) {
		e.model = "maps/buildables/wall_palisade_gate.bsp";
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 543) {
		e.model = "maps/buildables/wall_palisade_gate_large.bsp";
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 544) {
		e.model = "maps/buildables/wall_palisade_woodwall.bsp";
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 545) {
		e.model = "maps/buildables/wall_palisade_woodwall_gate.bsp";
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 546) {
		e.model = "maps/buildables/wall_palisade_woodwall_tower.bsp";
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 550) {
		e.model = "maps/buildables/wall_berm.bsp";
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 551) {
		e.model = "maps/buildables/wall_berm_tower.bsp";
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 560) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain.bsp";
		}
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 561) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_tower_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_tower.bsp";
		}
		trn = -90;
		hitpoints = 35000;
	} else if (self.count == 562) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_tower_round_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_tower_round.bsp";
		}
		trn = -90;
		hitpoints = 35000;
	} else if (self.count == 563) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_door_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_door.bsp";
		}
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 564) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_fill_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_fill.bsp";
		}
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 565) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_interior_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_interior.bsp";
		}
		trn = -90;
		hitpoints = 15000;
	} else if (self.count == 566) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/vault_curtain_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/vault_curtain.bsp";
		}
		trn = -90;
		hitpoints = 18000;
	} else if (self.count == 567) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_fill_stairs_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_fill_stairs.bsp";
		}
		trn = -90;
		hitpoints = 28000;
	} else if (self.count == 568) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_interior_door_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_interior_door.bsp";
		}
		trn = -90;
		hitpoints = 15000;
	} else if (self.count == 569) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/wall_curtain_gate_large_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/wall_curtain_gate_large.bsp";
		}
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 570) {
		if (ourcastlecolor == 1) {
			//print("castlecolors4\n");
			//Tan
			e.model = "maps/buildables/wall_castletan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink.bsp";
		} else {
			e.model = "maps/buildables/wall_castle.bsp";
		}
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 571) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_tower.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_tower.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_tower.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_tower.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_tower.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_tower.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_tower.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_tower.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_tower.bsp";
		}
		trn = -90;
		hitpoints = 37000;
	} else if (self.count == 572) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_tower_round.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_tower_round.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_tower_round.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_tower_round.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_tower_round.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_tower_round.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_tower_round.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_tower_round.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_tower_round.bsp";
		}
		trn = -90;
		hitpoints = 37000;
	} else if (self.count == 573) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_door.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_door.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_door.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_door.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_door.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_door.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_door.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_door.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_door.bsp";
		}
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 574) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/vault_castletan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/vault_castlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/vault_castlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/vault_castlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/vault_castlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/vault_castleblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/vault_castlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/vault_castlepink.bsp";
		} else {
			e.model = "maps/buildables/vault_castle.bsp";
		}
		trn = -90;
		hitpoints = 20000;
	} else if (self.count == 575) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/vault_castletan_starchamber.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/vault_castlewhite_starchamber.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/vault_castlegreen_starchamber.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/vault_castlebrown_starchamber.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/vault_castlelighttan_starchamber.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/vault_castleblack_starchamber.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/vault_castlemauve_starchamber.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/vault_castlepink_starchamber.bsp";
		} else {
			e.model = "maps/buildables/vault_castle_starchamber.bsp";
		}
		trn = -90;
		hitpoints = 20000;
	} else if (self.count == 576) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_fill.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_fill.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_fill.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_fill.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_fill.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_fill.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_fill.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_fill.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_fill.bsp";
		}
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 577) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 578) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_fill_stairs.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_fill_stairs.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_fill_stairs.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_fill_stairs.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_fill_stairs.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_fill_stairs.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_fill_stairs.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_fill_stairs.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_fill_stairs.bsp";
		}
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 579) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_door.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_door.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_door.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_door.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_door.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_door.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_door.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior_door.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_door.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10700) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_door_two.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_door_two.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_door_two.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_door_two.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_door_two.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_door_two.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_door_two.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_interior_door_two.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_door_two.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10701) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_door_side.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_door_side.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_door_side.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_door_side.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_door_side.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_door_side.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_door_side.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior_door_side.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_door_side.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10702) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_window.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_window.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_window.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_window.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_window.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_window.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_window.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior_window.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_window.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10703) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_arrowloop.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior_arrowloop.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_arrowloop.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10704) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_arch.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_arch.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_arch.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_arch.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_arch.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_arch.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_arch.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/wall_castlepink_interior_arch.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_arch.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10705) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_archironbar.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_archironbar.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_archironbar.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_archironbar.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_archironbar.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_archironbar.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_archironbar.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_interior_archironbar.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_archironbar.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10706) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_alcove.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_alcove.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_alcove.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_alcove.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_alcove.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_alcove.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_alcove.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_interior_alcove.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_alcove.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10707) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_interior_alcovetop_copper.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_interior_alcovetop_copper.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_interior_alcovetop_copper.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 10708) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/wall_castletan_gate_large.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/wall_castlewhite_gate_large.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/wall_castlegreen_gate_large.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/wall_castlebrown_gate_large.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/wall_castlelighttan_gate_large.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/wall_castleblack_gate_large.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/wall_castlemauve_gate_large.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/wall_castlepink_gate_large.bsp";
		} else {
			e.model = "maps/buildables/wall_castle_gate_large.bsp";
		}
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 10709) {
		e.model = "maps/buildables/wall_castle_gate_large_doorframe_stone.bsp";
		trn = -90;
		hitpoints = 1150; //about double of small reenforced wood door (more stuff)
	} else if (self.count == 10710) {
		e.model = "maps/buildables/wall_castle_gate_large_doorframe_stone.bsp";
		trn = -90;
		hitpoints = 12000; //about double of small iron door (more stuff)
	} else if (self.count == 580) {
		e.model = "maps/buildables/wall_polish.bsp";
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 581) {
		e.model = "maps/buildables/wall_polish_tower.bsp";
		trn = -90;
		hitpoints = 37000;
	} else if (self.count == 582) {
		e.model = "maps/buildables/wall_polish_door.bsp";
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 583) {
		e.model = "maps/buildables/vault_polish.bsp";
		trn = -90;
		hitpoints = 20000;
	} else if (self.count == 584) {
		e.model = "maps/buildables/wall_polish_fill.bsp";
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 585) {
		e.model = "maps/buildables/wall_polish_interior.bsp";
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 586) {
		e.model = "maps/buildables/wall_polish_fill_stairs.bsp";
		trn = -90;
		hitpoints = 30000;
	} else if (self.count == 587) {
		e.model = "maps/buildables/wall_polish_interior_door.bsp";
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 588) {
		e.model = "maps/buildables/wall_polish_gate_large.bsp";
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 610) {
		e.model = "maps/buildables/vault_roof_copper.bsp";
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 611) {
		e.model = "maps/buildables/vault_roof_copper_end.bsp";
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 612) {
		e.model = "maps/buildables/vault_roof_copper_one.bsp";
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 616) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/vault_roof_dome_base_castletan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/vault_roof_dome_base_castlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/vault_roof_dome_base_castlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/vault_roof_dome_base_castlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/vault_roof_dome_base_castlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/vault_roof_dome_base_castleblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/vault_roof_dome_base_castlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			//pink
			e.model = "maps/buildables/vault_roof_dome_base_castlepink.bsp";
		} else {
			e.model = "maps/buildables/vault_roof_dome_base_castle.bsp";
		}
		trn = -90;
		hitpoints = 28000;
	} else if (self.count == 630) {
		e.model = "maps/buildables/foundation_wall.bsp";
		trn = -90;
		hitpoints = 36000;
	} else if (self.count == 631) {
		e.model = "maps/buildables/foundation_tower.bsp";
		trn = -90;
		hitpoints = 37000;
	} else if (self.count == 632) {
		e.model = "maps/buildables/foundation_tower_round.bsp";
		trn = -90;
		hitpoints = 37000;
	} else if (self.count == 633) {
		e.model = "maps/buildables/foundation_bridge.bsp";
		trn = -90;
		hitpoints = 16000;
	
	} else if (self.count == 645) {
		e.model = "maps/buildables/bridge_wood_wide.bsp";
		trn = -90;
		hitpoints = 2130;
	} else if (self.count == 646) {
		e.model = "maps/buildables/bridge_wood.bsp";
		trn = -90;
		hitpoints = 2130;
	} else if (self.count == 650) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/bridge_curtain_landing_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/bridge_curtain_landing.bsp";
		}
		trn = -90;
		hitpoints = 32000;
	} else if (self.count == 651) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/bridge_curtain_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/bridge_curtain.bsp";
		}
		trn = -90;
		hitpoints = 16000;
	} else if (self.count == 652) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/bridge_curtain_c_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/bridge_curtain_c.bsp";
		}
		trn = -90;
		hitpoints = 16000;
		
	} else if (self.count == 660) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/bridge_castletan_landing.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/bridge_castlewhite_landing.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/bridge_castlegreen_landing.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/bridge_castlebrown_landing.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/bridge_castlelighttan_landing.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/bridge_castleblack_landing.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/bridge_castlemauve_landing.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/bridge_castlepink_landing.bsp";
		} else {
			e.model = "maps/buildables/bridge_castle_landing.bsp";
		}
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 661) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/bridge_castletan.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/bridge_castlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/bridge_castlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/bridge_castlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/bridge_castlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/bridge_castleblack.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/bridge_castlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/bridge_castlepink.bsp";
		} else {
			e.model = "maps/buildables/bridge_castle.bsp";
		}
		trn = -90;
		hitpoints = 16900;
	} else if (self.count == 662) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/bridge_castletan_c.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/bridge_castlewhite_c.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/bridge_castlegreen_c.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/bridge_castlebrown_c.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/bridge_castlelighttan_c.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/bridge_castleblack_c.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/bridge_castlemauve_c.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/bridge_castlepink_c.bsp";
		} else {
			e.model = "maps/buildables/bridge_castle_c.bsp";
		}
		trn = -90;
		hitpoints = 16900;
	} else if (self.count == 663) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/bridge_castletan_fort.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/bridge_castlewhite_fort.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/bridge_castlegreen_fort.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/bridge_castlebrown_fort.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/bridge_castlelighttan_fort.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/bridge_castleblack_fort.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/bridge_castlemauve_fort.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/bridge_castlepink_fort.bsp";
		} else {
			e.model = "maps/buildables/bridge_castle_fort.bsp";
		}
		trn = -90;
		hitpoints = 16900;
	} else if (self.count == 664) {
		if (ourcastlecolor == 1) {
			//Tan
			e.model = "maps/buildables/bridge_castletan_fortc.bsp";
		} else if (ourcastlecolor == 2) {
			//White
			e.model = "maps/buildables/bridge_castlewhite_fortc.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			e.model = "maps/buildables/bridge_castlegreen_fortc.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			e.model = "maps/buildables/bridge_castlebrown_fortc.bsp";
		} else if (ourcastlecolor == 5) {
			//LightTan
			e.model = "maps/buildables/bridge_castlelighttan_fortc.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			e.model = "maps/buildables/bridge_castleblack_fortc.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			e.model = "maps/buildables/bridge_castlemauve_fortc.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			e.model = "maps/buildables/bridge_castlepink_fortc.bsp";
		} else {
			e.model = "maps/buildables/bridge_castle_fortc.bsp";
		}
		trn = -90;
		hitpoints = 16900;
	
	} else if (self.count == 670) {
		e.model = "maps/buildables/bridge_polish_landing.bsp";
		trn = -90;
		hitpoints = 33800;
	} else if (self.count == 671) {
		e.model = "maps/buildables/bridge_polish.bsp";
		trn = -90;
		hitpoints = 16900;
	} else if (self.count == 672) {
		e.model = "maps/buildables/bridge_polish_c.bsp";
		trn = -90;
		hitpoints = 16900;
	
	//Unlike the buildings (which detect surface materials fine with arrows)	
	//Some of the blocks, when shot with an arrow, aren't detected properly for material
	//So we set it explicitly, for the arrows/crossbows
	//Bullets do detect and work fine with the blocks etc
	//Thus the .objcthitmaterial settings
	//These tell the crossbow/arrow code explicitly, rather than detecting surface collided with
	//A few things we don't set (barbed wire, some furniture) and just let things be
	} else if (self.count == MTB64_FILLED) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == MTB64_FILLED_D) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled_d.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == MTB64_FILLED_X) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled_x.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == MTB64_FILLED_I) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled_i.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == MTB64_FILLED_CASING) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled_casing.bsp";
		trn = -90;
		hitpoints = 400;
	} else if (self.count == MTB64_FILLED_CORNER) {
		e.objcthitmaterial = 9; //Sheetrock
		e.model = "maps/buildables/block_64_filled_corner.bsp";
		trn = -90;
		hitpoints = 400;
			
	} else if (self.count == MTB64_SHINGLES) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_CASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_casing.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_SCASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_casingside.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_PYR) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_pyramidion.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_CORNER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_corner.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_RCORNER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_roundcorner.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_STAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_stairs.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_ICASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_casinginside.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_OS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_octoside.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_OS2) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_octoside2.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_SSTAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_stairs_side.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_SHINGLES_ISTAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_shingles_stairs_inside.bsp";
		trn = -90;
		hitpoints = 1200;
			
	} else if (self.count == MTB64_WOOD1) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_CASING) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_casing.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_casing.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_SCASING) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_casingside.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_casingside.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_PYR) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_pyramidion.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_pyramidion.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_CORNER) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_corner.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_corner.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_RCORNER) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_roundcorner.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_roundcorner.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_STAIRS) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_stairs.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_stairs.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_ICASING) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_casinginside.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_casinginside.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_OS) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_octoside.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_octoside.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_OS2) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_octoside2.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_octoside2.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_SSTAIRS) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_stairs_side.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_stairs_side.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == MTB64_WOOD1_ISTAIRS) {
		e.objcthitmaterial = 8; //Wood
		if (ourwoodcolor) {
			e.model = "maps/buildables/block_64_woodcolor_stairs_inside.bsp";
		} else {
			e.model = "maps/buildables/block_64_wood1_stairs_inside.bsp";
		}
		trn = -90;
		hitpoints = 1200;
	
		
	} else if (self.count == MTB64_WOOD2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_CASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_casing.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_SCASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_casingside.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_PYR) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_pyramidion.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_CORNER) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_corner.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_RCORNER) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_roundcorner.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_STAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_stairs.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_ICASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_casinginside.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_OS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_octoside.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_OS2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_octoside2.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_SSTAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_stairs_side.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_ISTAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_stairs_inside.bsp";
		trn = -90;
		hitpoints = 900;
	} else if (self.count == MTB64_WOOD2_STAIRSCHEAP) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_wood2_stairs_cheap.bsp";
		trn = -90;
		hitpoints = 400;
		
	} else if (self.count == MTB64_CURTAIN) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_CASING) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_casing_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_casing.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_SCASING) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_casingside_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_casingside.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_PYR) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_pyramidion_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_pyramidion.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_CORNER) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_corner_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_corner.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_RCORNER) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_roundcorner_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_roundcorner.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_STAIRS) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_stairs_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_stairs.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_ICASING) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_casinginside_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_casinginside.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_OS) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_octoside_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_octoside.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_OS2) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_octoside2_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_octoside2.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_SSTAIRS) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_stairs_side_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_stairs_side.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	} else if (self.count == MTB64_CURTAIN_ISTAIRS) {
		e.objcthitmaterial = 4; //Brick
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/block_64_curtain_stairs_inside_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/block_64_curtain_stairs_inside.bsp";
		}
		trn = -90;
		hitpoints = 3840;
	
		
	} else if (self.count == MTB64_CASTLE) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle.bsp";
		}
		trn = -90;
		hitpoints = 4060;
		//; 192*448*512 (above ground)
        	//44040192 
		//Hitpoints: = 33800;
		//; 64*64*64
        	//262144 == 1/168th, ~= 0.006 mutiplyer.
		//; 33800*.006
		//202.8
		//*2 as is too weak otherwise. (406)
		//then *10, solid as anything made from it
	} else if (self.count == MTB64_CASTLE_CASING) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_casing.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_casing.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_casing.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_casing.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_casing.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_casing.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_casing.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_casing.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_casing.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_casing.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_SCASING) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_casingside.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_casingside.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_casingside.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_casingside.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_casingside.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_casingside.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_casingside.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_casingside.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_casingside.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_casingside.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_PYR) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_pyramidion.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_pyramidion.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_pyramidion.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_pyramidion.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_pyramidion.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_pyramidion.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_pyramidion.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_pyramidion.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_pyramidion.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_pyramidion.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_CORNER) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_corner.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_corner.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_corner.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_corner.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_corner.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_corner.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_corner.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_corner.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_corner.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_corner.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_RCORNER) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_roundcorner.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_roundcorner.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_roundcorner.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_roundcorner.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_roundcorner.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_roundcorner.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_roundcorner.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_roundcorner.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_roundcorner.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_roundcorner.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_STAIRS) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_stairs.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_stairs.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_stairs.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_stairs.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_stairs.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_stairs.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_stairs.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_stairs.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_stairs.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_stairs.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_ICASING) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_casinginside.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_casinginside.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_casinginside.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_casinginside.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_casinginside.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_casinginside.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_casinginside.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_casinginside.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_casinginside.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_casinginside.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_OS) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_octoside.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_octoside.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_octoside.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_octoside.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_octoside.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_octoside.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_octoside.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_octoside.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_octoside.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_octoside.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_OS2) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_octoside2.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_octoside2.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_octoside2.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_octoside2.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_octoside2.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_octoside2.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_octoside2.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_octoside2.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_octoside2.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_octoside2.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_SSTAIRS) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_stairs_side.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_stairs_side.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_stairs_side.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_stairs_side.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_stairs_side.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_stairs_side.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_stairs_side.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_stairs_side.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_stairs_side.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_stairs_side.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CASTLE_ISTAIRS) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castle_stairs_inside.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletan_stairs_inside.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhite_stairs_inside.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreen_stairs_inside.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrown_stairs_inside.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttan_stairs_inside.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblack_stairs_inside.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauve_stairs_inside.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepink_stairs_inside.bsp";
		} else {
			e.model = "maps/buildables/block_64_castle_stairs_inside.bsp";
		}
		trn = -90;
		hitpoints = 4060;	
		
	} else if (self.count == MTB64_CASTLESQUARE) {
		e.objcthitmaterial = 4; //Brick
		//e.model = "maps/buildables/block_64_castlesquare.bsp";
		if (ourcastlecolor == 1) {
			e.model = "maps/buildables/block_64_castletansquare.bsp";
		} else if (ourcastlecolor == 2) {
			e.model = "maps/buildables/block_64_castlewhitesquare.bsp";
		} else if (ourcastlecolor == 3) {
			e.model = "maps/buildables/block_64_castlegreensquare.bsp";
		} else if (ourcastlecolor == 4) {
			e.model = "maps/buildables/block_64_castlebrownsquare.bsp";
		} else if (ourcastlecolor == 5) {
			e.model = "maps/buildables/block_64_castlelighttansquare.bsp";
		} else if (ourcastlecolor == 6) {
			e.model = "maps/buildables/block_64_castleblacksquare.bsp";
		} else if (ourcastlecolor == 7) {
			e.model = "maps/buildables/block_64_castlemauvesquare.bsp";
		} else if (ourcastlecolor == 8) {
			e.model = "maps/buildables/block_64_castlepinksquare.bsp";
		} else {
			e.model = "maps/buildables/block_64_castlesquare.bsp";
		}
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_CLAIMSTONE) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_claimstone.bsp";
		trn = -90;
		hitpoints = 400; //Like fill
		
	} else if (self.count == MTB64U_CONCRETE) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete.bsp";
		trn = -90;
		hitpoints = 3123;
		//Concrete wall / Castle wall
		//26000/33800
        	//~0.76923076923076923077
		//Thus Castle block to concrete block:
		//4060*0.76923076923076923077
        	//3123.0769230769230769262
	} else if (self.count == MTB64U_CONCRETE_CASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_casing.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_SCASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_casingside.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_PYR) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_pyramidion.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_CORNER) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_corner.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_RCORNER) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_roundcorner.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_STAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_stairs.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_ICASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_casinginside.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_OS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_octoside.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_OS2) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_octoside2.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_SSTAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_stairs_side.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_CONCRETE_ISTAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concrete_stairs_inside.bsp";
		trn = -90;
		hitpoints = 3123;
			
	} else if (self.count == MTB64U_CONCRETESQUARE) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_concretesquare.bsp";
		trn = -90;
		hitpoints = 3123;
		
	} else if (self.count == MTB64U_PLATFORM_8) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_platform_8.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_PLATFORM_16) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_platform_16.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_PLATFORM_24) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_platform_24.bsp";
		trn = -90;
		hitpoints = 3123;
	} else if (self.count == MTB64U_PLATFORM_32) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_platform_32.bsp";
		trn = -90;
		hitpoints = 3123;
		
	
	} else if (self.count == MTB64U_RCONCRETE) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_CASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_casing.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_SCASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_casingside.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_PYR) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_pyramidion.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_CORNER) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_corner.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_RCORNER) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_roundcorner.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_STAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_stairs.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_ICASING) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_casinginside.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_OS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_octoside.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_OS2) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_octoside2.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_SSTAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_stairs_side.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETE_ISTAIRS) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcrete_stairs_inside.bsp";
		trn = -90;
		hitpoints = 4000;
			
	} else if (self.count == MTB64U_RCONCRETESQUARE) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcretesquare.bsp";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64U_RCONCRETESQUARE2) {
		e.objcthitmaterial = 5; //Concrete
		e.model = "maps/buildables/block_64_rconcretesquare2.bsp";
		trn = -90;
		hitpoints = 4015; //Thin strips, not much more protection
	
	} else if (self.count == MTB64U_ARCHIVEBOX) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_archivebox.bsp";
		trn = -90;
		hitpoints = 1000; //Similar to corrugated metal roof.	
	} else if (self.count == MTB64U_INACT_OIL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_inactive_oil.bsp";
		trn = -90;
		hitpoints = 1000; //Similar to corrugated metal roof.
	} else if (self.count == MTB64U_ACT_OIL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_active_oil.bsp";
		trn = -90;
		hitpoints = 300; //Boom
	} else if (self.count == MTB64U_ACT_EXPL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_active_explode.bsp";
		trn = -90;
		hitpoints = 40; //Easy Boom, wants to
	
	} else if (self.count == MTB64U_FURN_CHAIR) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_chair.bsp";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_CHAIR2) {
		e.model = "maps/buildables/furn_chair2.bsp";
		trn = -90;
		hitpoints = 400; //Plastic and foam and some metal computer desk chair
	} else if (self.count == MTB64U_FURN_CHAIR3) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/chairs/minimalist_chair.iqm";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_CHAIR4) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/chairs/lowpolyfurni_chair.iqm";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_CHAIR5) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/chairs/sirren_chair.iqm";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_STOOL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/chairs/sirren_stool.iqm";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_CSTOOL) {
		//e.objcthitmaterial = 2; //Metal
		e.model = "models/chairs/sirren_cstool.iqm";
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_RETROCHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/retro_chair.iqm";
		e.lodmodel1 = "models/chairs/retro_chair_lod1.iqm";
		e.lodmodel2 = "models/chairs/retro_chair_lod2.iqm";
		
		e.lodmodel0substitute = "models/chairs/retro_chair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 950; //Metal chair
	} else if (self.count == MTB64U_FURN_PLSCHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/plasticswivelofficechair.iqm";
		e.lodmodel1 = "models/chairs/plasticswivelofficechair_lod1.iqm";
		e.lodmodel2 = "models/chairs/plasticswivelofficechair_lod2.iqm";
		
		e.lodmodel0substitute = "models/chairs/plasticswivelofficechair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 800; //Metal chair
	} else if (self.count == MTB64U_FURN_SCHINTGRDESK) {
		e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/integratedschooldesk.iqm";
		e.lodmodel1 = "models/chairs/integratedschooldesk_lod1.iqm";
		
		e.lodmodel0substitute = "models/chairs/integratedschooldesk.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel1; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 800; //Metal chair
	} else if (self.count == MTB64U_FURN_SCHDESKCHAIR) {
		e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/schooldeskandchair.iqm";
		e.lodmodel1 = "models/chairs/schooldeskandchair_lod1.iqm";
		
		e.lodmodel0substitute = "models/chairs/schooldeskandchair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel1; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 800; //Metal chair
	} else if (self.count == MTB64U_FURN_RETROTABLE) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/tables/retro_table.iqm";
		e.lodmodel1 = "models/tables/retro_table_lod1.iqm";
		e.lodmodel2 = "models/tables/retro_table_lod2.iqm";
		
		
		e.lodmodel0substitute = "models/tables/retro_table.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 950; //Metal table
	} else if (self.count == MTB64U_FURN_SCHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/infrared_schair.iqm";
		e.lodmodel1 = "models/chairs/infrared_schair_lod1.iqm";
		e.lodmodel2 = "models/chairs/infrared_schair_lod2.iqm";
		
		e.lodmodel0substitute = "models/chairs/infrared_schair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 950; //Metal chair	
	} else if (self.count == MTB64U_FURN_OMLCHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/officechairmodleather.iqm";
		
		e.lodmodel1 = "models/chairs/officechairmodleather_lod1.iqm";
		e.lodmodel2 = "models/chairs/officechairmodleather_lod2.iqm";
		
		e.lodmodel0substitute = "models/chairs/officechairmodleather.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 900; //Metal chair		
	} else if (self.count == MTB64U_FURN_OMLCHAIR2) {
		//e.objcthitmaterial = 2; //Metal
		
		//e.model = "models/chairs/officechairmodleather.iqm";
		e.lodmodel1 = "models/chairs/officechairmodleather_lod1.iqm";
		e.lodmodel2 = "models/chairs/officechairmodleather_lod2.iqm";		
		
		//Use a substitute lod0 model, so we don't run so many collision calcs on
		//complex mesh
		e.lodmodel0substitute = "models/chairs/officechairmodleather.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		//Must be set to something so we don't collide with complex mesh
		e.model = e.lodmodel2; //Now being used as Collision model
		//Another option, but didn't look good, even for the moment of building
		//e.model = "models/chairs/officechairmodleather_hull.iqm";
		
		trn = -90;
		hitpoints = 900; //Metal chair		
	} else if (self.count == MTB64U_FURN_MLHSKCHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/modernleatherhuskchair.iqm";
		e.lodmodel1 = "models/chairs/modernleatherhuskchair_lod1.iqm";
		
		e.lodmodel0substitute = "models/chairs/modernleatherhuskchair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel1; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 900; //Metal chair			
	} else if (self.count == MTB64U_FURN_TRIBECACHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/tribecachair.iqm";
		e.lodmodel1 = "models/chairs/tribecachair_lod1.iqm";
		
		e.lodmodel0substitute = "models/chairs/tribecachair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel1; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 700; //Metal chair			
	} else if (self.count == MTB64U_FURN_BARCELONACHAIR) {
		//e.objcthitmaterial = 2; //Metal
		//e.model = "models/chairs/barcelonachair.iqm";
		e.lodmodel1 = "models/chairs/barcelonachair_lod1.iqm";
		e.lodmodel2 = "models/chairs/barcelonachair_lod2.iqm";
		
		e.lodmodel0substitute = "models/chairs/barcelonachair.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel2; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 600; //Metal frame chair	
	} else if (self.count == MTB64U_FURN_CRATE) {
		e.model = "maps/buildables/furn_crate.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_BARRELP) {
		e.model = "models/barrels/plasticbarrel.iqm";
		trn = -90;
		hitpoints = 300; //Plastic
	} else if (self.count == MTB64U_FURN_BARRELM) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/barrels/gaztank.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLEGLASS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/glassTable.iqm";
		trn = -90;
		hitpoints = 900; //Metal sides
	} else if (self.count == MTB64U_FURN_DESK) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_desk.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_MGSTDESK) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/modglasssquaretubedesk.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_MGSTDESKFLAT) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/modglasssquaretubedesk-flat.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_MGSTDESKFULLCORNER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/modglasssquaretubedesk-fullcorner.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLE) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/lowpolyfurni_table.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLELOW) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/lowpolyfurni_lowtable.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLESQUARE) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/sirren_squaretable.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLECIRC) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/sirren_circtable.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_TABLELONG) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/tables/sirren_longtable.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_SHELVES) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/shelves/lowpolyfurni_shelves.iqm";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_FUTON) {
		e.model = "maps/buildables/furn_futon.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_BED) {
		e.model = "maps/buildables/furn_bed_mod.bsp";
		trn = -90;
		hitpoints = 300; //Wood
	} else if (self.count == MTB64U_FURN_BED_FOAM) {
		e.model = "maps/buildables/furn_bed_foam.bsp";
		trn = -90;
		hitpoints = 300;
		
	} else if (self.count == MTB64U_FURN_SOFA1BR) {
		e.model = "maps/buildables/furn_sofaone_leatherdb.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA3BR) {
		e.model = "maps/buildables/furn_sofa_leatherdb.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA1B) {
		e.model = "maps/buildables/furn_sofaone_leatherb.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA3B) {
		e.model = "maps/buildables/furn_sofa_leatherb.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA1LW) {
		e.model = "maps/buildables/furn_sofaone_leatherw.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA3LW) {
		e.model = "maps/buildables/furn_sofa_leatherw.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA1LW2) {
		e.model = "maps/buildables/furn_sofaone_leatherw2.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA3LW2) {
		e.model = "maps/buildables/furn_sofa_leatherw2.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA_FOAM) {
		e.model = "maps/buildables/furn_sofa_foam.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA_TARTAN) {
		e.model = "maps/buildables/furn_sofa_tartan.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA_POOFY) {
		e.model = "maps/buildables/furn_sofa_poofy.bsp";
		trn = -90;
		hitpoints = 300;
	} else if (self.count == MTB64U_FURN_SOFA_NORM) {
		e.model = "maps/buildables/furn_sofa_norm.bsp";
		trn = -90;
		hitpoints = 300;
		
	} else if (self.count == MTB64U_FURN_SERVER) {
		e.model = "maps/buildables/furn_server.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_LAMP_STREET) {
		e.model = "models/lights/xonlightpost01.md3";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_LAMP_STREET2) {
		e.model = "models/lights/xonlightpost02.md3";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_LAMP_STREET3) {
		e.model = "models/lights/xonlightpost03.md3";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_LAMP_STREET4) {
		e.model = "models/lights/xonlightpost04.md3";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_LAMP_STREET5) {
		e.model = "models/lights/xonlightpost05.md3";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_COMCRATE) {
		e.model = "maps/buildables/furn_comcrate.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_COMCRATE2) {
		e.model = "maps/buildables/furn_comcrate2.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINET1) {
		e.model = "models/cabinets/basick/basickcabinet1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETTOP1) {
		e.model = "models/cabinets/basick/basickcabinettop1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETTOPDEEP1) {
		e.model = "models/cabinets/basick/basickcabinettopdeep1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1) {
		e.model = "models/cabinets/basick/basickcabinettopdeepshort1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETTOPSHORT1) {
		e.model = "models/cabinets/basick/basickcabinettopshort1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1) {
		e.model = "models/cabinets/basick/basickcabinettopshortshelves1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINET2) {
		e.model = "models/cabinets/basick/basickcabinet2.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINET3) {
		e.model = "models/cabinets/basick/basickcabinet3.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINET4) {
		e.model = "models/cabinets/basick/basickcabinet4.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNER1) {
		e.model = "models/cabinets/basick/basickcabinetcorner1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNER2) {
		e.model = "models/cabinets/basick/basickcabinetcorner2.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNERTOP1) {
		e.model = "models/cabinets/basick/basickcabinetcornertop1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNERTOP2) {
		e.model = "models/cabinets/basick/basickcabinetcornertop2.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1) {
		e.model = "models/cabinets/basick/basickcabinetcornertopdeep1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2) {
		e.model = "models/cabinets/basick/basickcabinetcornertopdeep2.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETBAR1) {
		e.model = "models/cabinets/basick/basickcabinetbar1.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETBARENDR) {
		e.model = "models/cabinets/basick/basickcabinetbarendr.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_BSCKCABINETBARENDL) {
		e.model = "models/cabinets/basick/basickcabinetbarendl.iqm";
		trn = -90;
		hitpoints = 950; //Metal
	} else if (self.count == MTB64U_FURN_MTLCRATE) {
		e.model = "maps/buildables/furn_mtlcrate.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_SHOWER) {
		e.model = "maps/buildables/furn_shower.bsp";
		trn = -90;
		hitpoints = 290; //glass and plastic and some metal
	} else if (self.count == MTB64U_FURN_TOILET) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/furn_toilet.bsp";
		trn = -90;
		hitpoints = 390; //Porcelin
	} else if (self.count == MTB64U_FURN_SINK_PED ) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/furn_sink_ped.bsp";
		trn = -90;
		hitpoints = 380; //Porcelin
	} else if (self.count == MTB64U_FURN_SINK_PED2 ) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/furn_sink_ped2.bsp";
		trn = -90;
		hitpoints = 380; //Porcelin
	} else if (self.count == MTB64U_FURN_SINK) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/furn_sink.bsp";
		trn = -90;
		hitpoints = 290; //Grey MDF something
	} else if (self.count == MTB64U_FURN_SINK2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/furn_sink2.bsp";
		trn = -90;
		hitpoints = 300; //Wood
	} else if (self.count == MTB64U_FURN_TOILET2) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/furn_toilet2.bsp";
		trn = -90;
		hitpoints = 390; //Porcelin
	} else if (self.count == MTB64U_FURN_TOILET3) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/furn_toilet3.bsp";
		trn = -90;
		hitpoints = 390; //Porcelin
	} else if (self.count == MTB64U_FURN_STOVE) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_stove.bsp";
		trn = -90;
		hitpoints = 1200; //Metal
	} else if (self.count == MTB64U_FURN_STOVE2) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_stove2.bsp";
		trn = -90;
		hitpoints = 1000; //Metal
	} else if (self.count == MTB64U_FURN_STOVE3) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_stove3.bsp";
		trn = -90;
		hitpoints = 1100; //Metal
	} else if (self.count == MTB64U_FURN_STOVE4) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_stove4.bsp";
		trn = -90;
		hitpoints = 1300; //Metal
	} else if (self.count == MTB64U_FURN_FILECABINET) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/containers/file_cabinet_metal.iqm";
		trn = -90;
		hitpoints = 1000; //Metal	
	} else if (self.count == MTB64U_FURN_FRIDGE) {
		e.model = "maps/buildables/furn_fridge.bsp";
		trn = -90;
		hitpoints = 900; //Mostly Metal
	} else if (self.count == MTB64U_FURN_FRIDGE2) {
		e.model = "maps/buildables/furn_fridge2.bsp";
		trn = -90;
		hitpoints = 850; //Mostly Metal
	} else if (self.count == MTB64U_FURN_FRIDGE3) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/furn_fridge3.bsp";
		trn = -90;
		hitpoints = 1000; //All Metal
	} else if (self.count == MTB64U_FURN_FRIDGE4) {
		e.model = "maps/buildables/furn_fridge4.bsp";
		trn = -90;
		hitpoints = 800; //Mostly Metal
	
	} else if (self.count == MTB64U_METAL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal.bsp";
		trn = -90;
		hitpoints = 2060;
		//Metal Truss. Half as strong as the concrete
	} else if (self.count == MTB64U_METAL_CASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_casing.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_SCASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_casingside.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_PYR) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_pyramidion.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_CORNER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_corner.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_RCORNER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_roundcorner.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_STAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_stairs.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_ICASING) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_casinginside.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_OS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_octoside.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_OS2) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_octoside2.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_SSTAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_stairs_side.bsp";
		trn = -90;
		hitpoints = 2060;
	} else if (self.count == MTB64U_METAL_ISTAIRS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_rmetal_stairs_inside.bsp";
		trn = -90;
		hitpoints = 2060;
	
	} else if (self.count == MTB64U_WINDOW_FUTURE) {
		e.objcthitmaterial = 6; //Glass
		e.model = "maps/buildables/block_64_window_future.bsp";
		trn = -90;
		hitpoints = 2000; //More than stone
	} else if (self.count == MTB64U_WINDOW_FUTURE_X) {
		e.objcthitmaterial = 6; //Glass
		e.model = "maps/buildables/block_64_window_future_x.bsp";
		trn = -90;
		hitpoints = 2000; //More than stone
	
	} else if (self.count == MTB64U_XBEAM_UP) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_xbeam_up.bsp";
		trn = -90;
		hitpoints = 6000; //Like Iron bars
	} else if (self.count == MTB64U_XBEAM_OVER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_xbeam_over.bsp";
		trn = -90;
		hitpoints = 6000; //Like Iron bars
		
	} else if (self.count == MTB64U_FLOOR_MTRUSS) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_floor_mtruss.bsp";
		trn = -90;
		hitpoints = 2010;
		
	} else if (self.count == MTB64U_BWIRE) {
		e.model = "maps/buildables/block_64_barbedwire_i.bsp";
		trn = -90;
		hitpoints = 2000;
	} else if (self.count == MTB64U_BWIRE_X) {
		e.model = "maps/buildables/block_64_barbedwire_x.bsp";
		trn = -90;
		hitpoints = 2000;
	} else if (self.count == MTB64U_BWIRE_O) {
		e.model = "maps/buildables/block_64_barbedwire_o.bsp";
		trn = -90;
		hitpoints = 2000;	
		
	} else if (self.count == MTB64U_DOOR_R_STEEL) {
		e.objcthitmaterial = 2; //Metal doorframe
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_steel_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_steel_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_steel_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_steel.bsp";
		trn = -90;
		hitpoints = 2060; //Like Truss
	} else if (self.count == MTB64U_DOOR_R_PLAIN) {
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_plain_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_plain_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_plain_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_plain.bsp";
		trn = -90;
		hitpoints = 300; //Flimsy
	} else if (self.count == MTB64U_DOOR_R_PLAIN2) {
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_plain_white_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_plain_white_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_plain_white_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_plain_white.bsp";
		trn = -90;
		hitpoints = 300; //Flimsy
	} else if (self.count == MTB64U_DOOR_R_GLASS) {
		e.objcthitmaterial = 2; //Metal doorframe
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_steel_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_steel_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_steel_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_steel.bsp";
		trn = -90;
		hitpoints = 600; //Not very strong, but has metal outer frame
	} else if (self.count == MTB64U_FITTEDWINDOW_STEELSLIT) {
		e.objcthitmaterial = 2; //Metal
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_fittedwindow_steelslit_wings.bsp";
		else
			e.model = "maps/buildables/block_64_fittedwindow_steelslit.bsp";
		trn = -90;
		hitpoints = 2060; //Like Truss
	} else if (self.count == MTB64U_FITTEDWINDOW_STEELPLATE) {
		e.objcthitmaterial = 2; //Metal
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_fittedwindow_steelplate_wings.bsp";
		else
			e.model = "maps/buildables/block_64_fittedwindow_steelplate.bsp";
		trn = -90;
		hitpoints = 2060; //Like Truss
	} else if (self.count == MTB64U_FITTEDWINDOW_CWALL) {
		e.objcthitmaterial = 5; //Concrete
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_fittedwindow_solidwall_concrete_wings.bsp";
		else
			e.model = "maps/buildables/block_64_fittedwindow_solidwall_concrete.bsp";
		trn = -90;
		hitpoints = 3123; //Concrete
	} else if (self.count == MTB64U_FITTEDWINDOW_UWINDOW) {
		e.objcthitmaterial = 6; //Glass
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_fittedwindow_uwindow_wings.bsp";
		else
			e.model = "maps/buildables/block_64_fittedwindow_uwindow.bsp";
		trn = -90;
		hitpoints = 600; //Not very strong, but has metal outer frame
	} else if (self.count == MTB64U_CLAIMSTONE) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_claimstone_future.bsp";
		trn = -90;
		hitpoints = 600; //Not very strong, but has metal outer frame	
	
					
	} else if (self.count == MTB64_HEDGE) {
		e.model = "maps/buildables/block_64_hedge.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_CASING) {
		e.model = "maps/buildables/block_64_hedge_casing.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_SCASING) {
		e.model = "maps/buildables/block_64_hedge_casingside.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_PYR) {
		e.model = "maps/buildables/block_64_hedge_pyramidion.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_CORNER) {
		e.model = "maps/buildables/block_64_hedge_corner.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_RCORNER) {
		e.model = "maps/buildables/block_64_hedge_roundcorner.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_STAIRS) {
		e.model = "maps/buildables/block_64_hedge_stairs.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_ICASING) {
		e.model = "maps/buildables/block_64_hedge_casinginside.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_OS) {
		e.model = "maps/buildables/block_64_hedge_octoside.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_OS2) {
		e.model = "maps/buildables/block_64_hedge_octoside2.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_SSTAIRS) {
		e.model = "maps/buildables/block_64_hedge_stairs_side.bsp";
		trn = -90;
		hitpoints = 60;
	} else if (self.count == MTB64_HEDGE_ISTAIRS) {
		e.model = "maps/buildables/block_64_hedge_stairs_inside.bsp";
		trn = -90;
		hitpoints = 60;
	
			
	} else if (self.count == MTB64_POLISH) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_CASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_casing.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_SCASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_casingside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_PYR) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_pyramidion.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_CORNER) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_corner.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_RCORNER) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_roundcorner.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_STAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_stairs.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_ICASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_casinginside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_OS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_octoside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_OS2) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_octoside2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_SSTAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_stairs_side.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_POLISH_ISTAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_polish_stairs_inside.bsp";
		trn = -90;
		hitpoints = 4060;
		
	} else if (self.count == MTB64_GRAYSTONE) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_CASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_casing.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_SCASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_casingside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_PYR) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_pyramidion.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_CORNER) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_corner.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_RCORNER) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_roundcorner.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_STAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_stairs.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_ICASING) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_casinginside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_OS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_octoside.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_OS2) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_octoside2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_SSTAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_stairs_side.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == MTB64_GRAYSTONE_ISTAIRS) {
		e.objcthitmaterial = 4; //Brick
		e.model = "maps/buildables/block_64_graycastle_stairs_inside.bsp";
		trn = -90;
		hitpoints = 4060;
		
	} else if (self.count == MTB64_SANDSTONEDARK) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/block_64_sandstonedark.bsp";
		trn = -90;
		hitpoints = 4120;
		
	} else if (self.count == MTB64_SANDSTONE) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_CASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_casing.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_casing.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_casing.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_casing.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_casing.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_casing.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_casing.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_SCASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_casingside.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_casingside.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_casingside.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_casingside.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_casingside.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_casingside.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_casingside.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_PYR) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_pyramidion.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_pyramidion.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_pyramidion.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_pyramidion.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_pyramidion.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_pyramidion.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_pyramidion.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_CORNER) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_corner.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_corner.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_corner.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_corner.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_corner.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_corner.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_corner.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_RCORNER) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_roundcorner.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_roundcorner.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_roundcorner.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_roundcorner.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_roundcorner.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_roundcorner.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_roundcorner.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_STAIRS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_stairs.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_stairs.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_stairs.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_stairs.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_stairs.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_stairs.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_stairs.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_ICASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_casinginside.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_casinginside.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_casinginside.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_casinginside.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_casinginside.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_casinginside.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_casinginside.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_OS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_octoside.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_octoside.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_octoside.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_octoside.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_octoside.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_octoside.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_octoside.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_OS2) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_octoside2.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_octoside2.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_octoside2.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_octoside2.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_octoside2.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_octoside2.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_octoside2.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_SSTAIRS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_stairs_side.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_stairs_side.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_stairs_side.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_stairs_side.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_stairs_side.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_stairs_side.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_stairs_side.bsp";
		}
		trn = -90;
		hitpoints = 4120;
	} else if (self.count == MTB64_SANDSTONE_ISTAIRS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_sandstonelight_stairs_inside.bsp";
		if (oursstonecolor == 1) {
			e.model = "maps/buildables/block_64_limestone_stairs_inside.bsp";
		} else if (oursstonecolor == 2) {
			e.model = "maps/buildables/block_64_limestoneg_stairs_inside.bsp";
		} else if (oursstonecolor == 3) {
			e.model = "maps/buildables/block_64_limestoney_stairs_inside.bsp";
		} else if (oursstonecolor == 4) {
			e.model = "maps/buildables/block_64_limestoneb_stairs_inside.bsp";
		} else if (oursstonecolor == 5) {
			e.model = "maps/buildables/block_64_bluestone_stairs_inside.bsp";
		} else {
			e.model = "maps/buildables/block_64_sandstonelight_stairs_inside.bsp";
		}
		trn = -90;
		hitpoints = 4120;
		
		
		
	} else if (self.count == MTB64_MARBLEWHITE) {
		e.objcthitmaterial = 3; //Stone
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_CASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_casing.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_casing.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_casing.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_casing.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_casing.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_casing.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_casing.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_casing.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_casing.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_casing.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_casing.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_casing.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_casing.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_casing.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_casing.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_casing.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_casing.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_casing.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_casing.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_casing.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_casing.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_casing.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_casing.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_casing.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_SCASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_casingside.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_casingside.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_casingside.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_casingside.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_casingside.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_casingside.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_casingside.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_casingside.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_casingside.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_casingside.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_casingside.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_casingside.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_casingside.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_casingside.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_casingside.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_casingside.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_casingside.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_casingside.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_casingside.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_casingside.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_casingside.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_casingside.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_casingside.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_casingside.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_PYR) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_pyramidion.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_pyramidion.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_pyramidion.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_pyramidion.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_pyramidion.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_pyramidion.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_pyramidion.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_pyramidion.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_pyramidion.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_pyramidion.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_pyramidion.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_pyramidion.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_pyramidion.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_pyramidion.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_pyramidion.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_pyramidion.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_pyramidion.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_pyramidion.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_pyramidion.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_pyramidion.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_pyramidion.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_pyramidion.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_pyramidion.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_pyramidion.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_CORNER) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_corner.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_corner.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_corner.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_corner.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_corner.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_corner.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_corner.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_corner.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_corner.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_corner.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_corner.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_corner.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_corner.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_corner.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_corner.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_corner.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_corner.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_corner.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_corner.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_corner.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_corner.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_corner.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_corner.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_corner.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER_SOLID) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_solid.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner_f_solid.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner_f_solid.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_solid.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RECCORNER_F) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_recessedcorner_f.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_recessedcorner_f.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_SCORNER_P) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_squarecorner_p.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_squarecorner_p.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_squarecorner_p.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_squarecorner_p.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_squarecorner_p.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_squarecorner_p.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_squarecorner_p.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_squarecorner_p.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_squarecorner_p.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_squarecorner_p.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_squarecorner_p.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_squarecorner_p.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_squarecorner_p.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_squarecorner_p.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_squarecorner_p.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_squarecorner_p.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_squarecorner_p.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_squarecorner_p.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_squarecorner_p.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_squarecorner_p.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_squarecorner_p.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_squarecorner_p.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_squarecorner_p.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_squarecorner_p.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RECCORNER_FB) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f_bottom.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_recessedcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_recessedcorner_f_bottom.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f_bottom.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RECCORNER_FT) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f_top.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_recessedcorner_f_top.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_recessedcorner_f_top.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_recessedcorner_f_top.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RECCORNER) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_recessedcorner.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_recessedcorner.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_recessedcorner.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_recessedcorner.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_recessedcorner.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_recessedcorner.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_recessedcorner.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_recessedcorner.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_recessedcorner.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_recessedcorner.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_recessedcorner.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_recessedcorner.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_recessedcorner.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_recessedcorner.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_recessedcorner.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_recessedcorner.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_recessedcorner.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_recessedcorner.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_recessedcorner.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_recessedcorner.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_recessedcorner.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_recessedcorner.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_recessedcorner.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_recessedcorner.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER_FB) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_bottom.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner_f_bottom.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner_f_bottom.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_bottom.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER_FT) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_top.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner_f_top.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner_f_top.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner_f_top.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER_F) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner_f.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner_f.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner_f.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner_f.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner_f.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner_f.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner_f.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner_f.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner_f.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner_f.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner_f.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner_f.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner_f.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner_f.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner_f.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner_f.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner_f.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner_f.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner_f.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner_f.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner_f.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner_f.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner_f.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner_f.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_RCORNER_P) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_roundcorner_p.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_roundcorner_p.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_roundcorner_p.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_roundcorner_p.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_roundcorner_p.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_roundcorner_p.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_roundcorner_p.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_roundcorner_p.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_roundcorner_p.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_roundcorner_p.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_roundcorner_p.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_roundcorner_p.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_roundcorner_p.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_roundcorner_p.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_roundcorner_p.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_roundcorner_p.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_roundcorner_p.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_roundcorner_p.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_roundcorner_p.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_roundcorner_p.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_roundcorner_p.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_roundcorner_p.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_roundcorner_p.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_roundcorner_p.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_STAIRS) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/block_64_marblewhite_stairs.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_stairs.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_stairs.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_stairs.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_stairs.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_stairs.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_stairs.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_stairs.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_stairs.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_stairs.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_stairs.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_stairs.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_stairs.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_stairs.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_stairs.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_stairs.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_stairs.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_stairs.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_stairs.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_stairs.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_stairs.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_stairs.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_stairs.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_stairs.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_ICASING) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_casinginside.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_casinginside.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_casinginside.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_casinginside.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_casinginside.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_casinginside.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_casinginside.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_casinginside.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_casinginside.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_casinginside.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_casinginside.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_casinginside.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_casinginside.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_casinginside.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_casinginside.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_casinginside.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_casinginside.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_casinginside.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_casinginside.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_casinginside.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_casinginside.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_casinginside.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_casinginside.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_casinginside.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_OS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_octoside.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_octoside.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_octoside.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_octoside.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_octoside.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_octoside.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_octoside.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_octoside.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_octoside.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_octoside.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_octoside.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_octoside.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_octoside.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_octoside.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_octoside.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_octoside.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_octoside.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_octoside.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_octoside.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_octoside.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_octoside.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_octoside.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_octoside.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_octoside.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_OS2) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_octoside2.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_octoside2.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_octoside2.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_octoside2.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_octoside2.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_octoside2.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_octoside2.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_octoside2.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_octoside2.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_octoside2.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_octoside2.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_octoside2.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_octoside2.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_octoside2.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_octoside2.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_octoside2.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_octoside2.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_octoside2.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_octoside2.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_octoside2.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_octoside2.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_octoside2.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_octoside2.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_octoside2.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_SSTAIRS) {
		e.objcthitmaterial = 3; //Stone
		//e.model = "maps/buildables/block_64_marblewhite_stairs_side.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_stairs_side.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_stairs_side.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_stairs_side.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_stairs_side.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_stairs_side.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_stairs_side.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_stairs_side.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_stairs_side.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_stairs_side.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_stairs_side.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_stairs_side.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_stairs_side.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_stairs_side.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_stairs_side.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_stairs_side.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_stairs_side.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_stairs_side.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_stairs_side.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_stairs_side.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_stairs_side.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_stairs_side.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_stairs_side.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_stairs_side.bsp";
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_MARBLEWHITE_ISTAIRS) {
		e.objcthitmaterial = 3; //Stone
		e.model = "maps/buildables/block_64_marblewhite_stairs_inside.bsp";
		if (ourmarblecolor == 1) {
			e.model = "maps/buildables/block_64_marblenero_stairs_inside.bsp";
		} else if (ourmarblecolor == 2) {
			e.model = "maps/buildables/block_64_marblegreen_stairs_inside.bsp";
		} else if (ourmarblecolor == 3) {
			e.model = "maps/buildables/block_64_marblered_stairs_inside.bsp";
		} else if (ourmarblecolor == 4) {
			e.model = "maps/buildables/block_64_marbleveiny_stairs_inside.bsp";
		} else if (ourmarblecolor == 5) {
			e.model = "maps/buildables/block_64_marblecyan_stairs_inside.bsp";
		} else if (ourmarblecolor == 6) {
			e.model = "maps/buildables/block_64_marblegray_stairs_inside.bsp";
		} else if (ourmarblecolor == 7) {
			e.model = "maps/buildables/block_64_marblebrown_stairs_inside.bsp";
		} else if (ourmarblecolor == 8) {
			e.model = "maps/buildables/block_64_marblelightblue_stairs_inside.bsp";
		} else if (ourmarblecolor == 9) {
			e.model = "maps/buildables/block_64_marblejade_stairs_inside.bsp";
		} else if (ourmarblecolor == 10) {
			e.model = "maps/buildables/block_64_marbleolive_stairs_inside.bsp";
		} else if (ourmarblecolor == 11) {
			e.model = "maps/buildables/block_64_marbleyellow_stairs_inside.bsp";
		} else if (ourmarblecolor == 12) {
			e.model = "maps/buildables/block_64_marblepink_stairs_inside.bsp";
		} else if (ourmarblecolor == 13) {
			e.model = "maps/buildables/block_64_marblesoftwhite_stairs_inside.bsp";
		} else if (ourmarblecolor == 14) {
			e.model = "maps/buildables/block_64_marblesoftgray_stairs_inside.bsp";
		} else if (ourmarblecolor == 15) {
			e.model = "maps/buildables/block_64_marbleygreen_stairs_inside.bsp";
		} else if (ourmarblecolor == 16) {
			e.model = "maps/buildables/block_64_marblecream_stairs_inside.bsp";
		} else if (ourmarblecolor == 17) {
			e.model = "maps/buildables/block_64_marblelightpink_stairs_inside.bsp";
		} else if (ourmarblecolor == 18) {
			e.model = "maps/buildables/block_64_marbletan_stairs_inside.bsp";
		} else if (ourmarblecolor == 19) {
			e.model = "maps/buildables/block_64_marblepacific_stairs_inside.bsp";
		} else if (ourmarblecolor == 20) {
			e.model = "maps/buildables/block_64_marblepeach_stairs_inside.bsp";
		} else if (ourmarblecolor == 21) {
			e.model = "maps/buildables/block_64_marblemystic_stairs_inside.bsp";
		} else if (ourmarblecolor == 22) {
			e.model = "maps/buildables/block_64_marblepwood_stairs_inside.bsp";
		} else {
			e.model = "maps/buildables/block_64_marblewhite_stairs_inside.bsp";
		}
		trn = -90;
		hitpoints = 4000;
		
	
	} else if (self.count == MTB64_SHINGLES2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_CASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_casing.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_SCASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_casingside.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_PYR) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_pyramidion.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_CORNER) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_corner.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_RCORNER) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_roundcorner.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_STAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_stairs.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_ICASING) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_casinginside.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_OS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_octoside.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_OS2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_octoside2.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_SSTAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_stairs_side.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == MTB64_SHINGLES2_ISTAIRS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_shingles2_stairs_inside.bsp";
		trn = -90;
		hitpoints = 800;
	
	} else if (self.count == MTB64_STAKES_WOOD1) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_stakes_wood1.bsp";
		trn = -90;
		hitpoints = 400; //More than wooden bar window
	} else if (self.count == MTB64_PLATFORMWOOD_8) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_platformwood_8.bsp";
		trn = -90;
		hitpoints = 350; //Same as wooden bar window
	} else if (self.count == MTB64_PLATFORMWOOD_24) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_platformwood_24.bsp";
		trn = -90;
		hitpoints = 350; //Same as wooden bar window
	} else if (self.count == MTB64_BWIRE) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_barbedwireold_i.bsp";
		trn = -90;
		hitpoints = 800; //Wood stakes, But has metal strands
	} else if (self.count == MTB64_WINDOW_WOODBAR) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/block_64_window_woodbar.bsp";
		trn = -90;
		hitpoints = 350; //Less than filled
	} else if (self.count == MTB64_WINDOW_IRONBAR) {
		e.objcthitmaterial = 2; //Metal
		e.model = "maps/buildables/block_64_window_ironbar.bsp";
		trn = -90;
		hitpoints = 6000; //More than stone
	
	} else if (self.count == MTB64_DOOR_R_WOOD) {
		e.objcthitmaterial = 8; //Wood
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_wood1_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_wood1_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_wood1_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_wood1.bsp";
		trn = -90;
		hitpoints = 385; //Like woodbar window, but more slightly
	} else if (self.count == MTB64_DOOR_R_JWOOD) {
		e.objcthitmaterial = 8; //Wood
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_wood1_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_wood1_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_wood1_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_wood1.bsp";
		trn = -90;
		hitpoints = 575; //Somewhat stronger, wood with iron reenforced
	} else if (self.count == MTB64_DOOR_R_FWOOD) {
		e.objcthitmaterial = 8; //Wood
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_fwood1_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_fwood1_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_fwood1_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_fwood1.bsp";
		trn = -90;
		hitpoints = 365; //like woodbar window, but more slightly, more delecate fancy door though
	} else if (self.count == MTB64_DOOR_R_IRONBAR) {
		e.objcthitmaterial = 2; //Metal
		if (ourdoorcenter == 1)
			e.model = "maps/buildables/block_64_doorframe_ironbar_wings.bsp";
		else if (ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_doorframe_ironbar_wings_short.bsp";
		else if (ourdoorcenter == 2.5)
			e.model = "maps/buildables/block_64_doorframe_ironbar_short.bsp";
		else
			e.model = "maps/buildables/block_64_doorframe_ironbar.bsp";
		trn = -90;
		hitpoints = 5800; //like ironbar window, thinner though
	
	} else if (self.count == MTB64_FITTEDWINDOW_CASTLE_ALOOP) {
		e.objcthitmaterial = 4; //Brick
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5) {
			if (ourcastlecolor == 1) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castletan_wings.bsp";
			} else if (ourcastlecolor == 2) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlewhite_wings.bsp";
			} else if (ourcastlecolor == 3) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlegreen_wings.bsp";
			} else if (ourcastlecolor == 4) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlebrown_wings.bsp";
			} else if (ourcastlecolor == 5) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlelighttan_wings.bsp";
			} else if (ourcastlecolor == 6) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castleblack_wings.bsp";
			} else if (ourcastlecolor == 7) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlemauve_wings.bsp";
			} else if (ourcastlecolor == 8) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlepink_wings.bsp";
			} else {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castle_wings.bsp";
			}
		} else {
			if (ourcastlecolor == 1) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castletan.bsp";
			} else if (ourcastlecolor == 2) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlewhite.bsp";
			} else if (ourcastlecolor == 3) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlegreen.bsp";
			} else if (ourcastlecolor == 4) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlebrown.bsp";
			} else if (ourcastlecolor == 5) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlelighttan.bsp";
			} else if (ourcastlecolor == 6) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castleblack.bsp";
			} else if (ourcastlecolor == 7) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlemauve.bsp";
			} else if (ourcastlecolor == 8) {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castlepink.bsp";
			} else {
				e.model = "maps/buildables/block_64_fittedwindow_arrowloop_castle.bsp";
			}
		}
		trn = -90;
		hitpoints = 4060; //like castleblock
		
	} else if (self.count == MTB64_FITTEDWINDOW_CASTLE_SWALL) {
		e.objcthitmaterial = 4; //Brick
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5) {
			if (ourcastlecolor == 1) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castletan_wings.bsp";
			} else if (ourcastlecolor == 2) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlewhite_wings.bsp";
			} else if (ourcastlecolor == 3) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlegreen_wings.bsp";
			} else if (ourcastlecolor == 4) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlebrown_wings.bsp";
			} else if (ourcastlecolor == 5) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlelighttan_wings.bsp";
			} else if (ourcastlecolor == 6) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castleblack_wings.bsp";
			} else if (ourcastlecolor == 7) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlemauve_wings.bsp";
			} else if (ourcastlecolor == 8) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlepink_wings.bsp";
			} else {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castle_wings.bsp";
			}
		} else {
			if (ourcastlecolor == 1) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castletan.bsp";
			} else if (ourcastlecolor == 2) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlewhite.bsp";
			} else if (ourcastlecolor == 3) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlegreen.bsp";
			} else if (ourcastlecolor == 4) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlebrown.bsp";
			} else if (ourcastlecolor == 5) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlelighttan.bsp";
			} else if (ourcastlecolor == 6) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castleblack.bsp";
			} else if (ourcastlecolor == 7) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlemauve.bsp";
			} else if (ourcastlecolor == 8) {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castlepink.bsp";
			} else {
				e.model = "maps/buildables/block_64_fittedwindow_solidwall_castle.bsp";
			}
		}
		trn = -90;
		hitpoints = 4060; //like castleblock
	} else if (self.count == MTB64_FITTEDWINDOW_WINDOW) {
		e.objcthitmaterial = 6; //Glass
		if (ourdoorcenter == 1 || ourdoorcenter == 1.5)
			e.model = "maps/buildables/block_64_fittedwindow_window_wings.bsp";
		else
			e.model = "maps/buildables/block_64_fittedwindow_window.bsp";
		trn = -90;
		hitpoints = 300; //Glass mostly...
	
	
	} else if (self.count == MTB64_FURN_CHEST_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/containers/cassapanca.iqm";
		trn = -90;
		hitpoints = 300; //Wooden chest
	} else if (self.count == MTB64_FURN_CHESTLARGE_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/containers/largechest1.iqm";
		trn = -90;
		hitpoints = 300; //Wooden chest
	} else if (self.count == MTB64_FURN_CHAIR_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/furn_chair_wood.bsp";
		trn = -90;
		hitpoints = 200; //Wooden chair
	} else if (self.count == MTB64_FURN_CHAIR_WOOD2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/chairs/enetheru_chair.iqm";
		trn = -90;
		hitpoints = 200; //Wooden chair
	} else if (self.count == MTB64_FURN_STOOL_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/chairs/DwarfBeerStool.iqm";
		trn = -90;
		hitpoints = 300; //Wooden stool
	} else if (self.count == MTB64_FURN_BENCH_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/chairs/enetheru_bench.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_TABLE_WOOD2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/tables/enetheru_table.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_TABLE_WOOD3) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/tables/enetheru_table0.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_TABLE_OCT_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/tables/lowpolyfurni_octtablewood.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_TABLE_OCT_WOOD2) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/tables/lowpolyfurni_octtablewood.iqm";
		e.skin = 1;
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_BARREL_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/barrels/DwarfBeerBarrel.iqm";
		trn = -90;
		hitpoints = 200; //Wooden barrel
	} else if (self.count == MTB64_FURN_BARREL_WOOD2) {
		e.objcthitmaterial = 8; //Wood
		local float barrelrand;
		barrelrand =  9 * random();
		e.model = "models/barrels/barrel_wooden.iqm";
		trn = -90;
		hitpoints = 200; //Wooden barrel
		if (barrelrand > 8) {
			e.skin = 8;
		} else if (barrelrand > 7) {
			e.skin = 7;
		} else if (barrelrand > 6) {
			e.skin = 6;
		} else if (barrelrand > 5) {
			e.skin = 5;
		} else if (barrelrand > 4) {
			e.skin = 4;
		} else if (barrelrand > 3) {
			e.skin = 3;
		} else if (barrelrand > 2) {
			e.skin = 2;
		} else if (barrelrand > 1) {
			e.skin = 1;
		} else {
			e.skin = 0;
		}
	} else if (self.count == MTB64_FURN_BLKSMHBELLOWS) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/blacksmith/blacksmithbellows.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_BLKSMHGRNDSTN) {
		e.objcthitmaterial = 3; //Stone
		e.model = "models/blacksmith/blacksmithgrindstone.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_BLKSMHANVIL) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/blacksmith/blacksmithanvil.iqm";
		trn = -90;
		hitpoints = 5800; //like ironbar window
	} else if (self.count == MTB64_FURN_IRONMAIDEN) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/dungeon/ironmaiden.iqm";
		trn = -90;
		hitpoints = 5500; //like ironbar window
	} else if (self.count == MTB64_FURN_SPIKEDRACK) {
		e.objcthitmaterial = 2; //Metal
		
		//e.model = "models/dungeon/orc_grilling_rack.iqm";
		//e.lodmodel1 = "models/dungeon/orc_grilling_rack_lod1.iqm";
		//e.lodmodel2 = "models/dungeon/orc_grilling_rack_lod2.iqm";
		//e.lodmodel3 = "models/dungeon/orc_grilling_rack_lod3.iqm";
		
		e.lodmodel1 = "models/dungeon/orc_grilling_rack_lod1.iqm";
		e.lodmodel2 = "models/dungeon/orc_grilling_rack_lod2.iqm";
		e.lodmodel3 = "models/dungeon/orc_grilling_rack_lod3.iqm";
		e.lodmodel0substitute = "models/dungeon/orc_grilling_rack.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel3; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 5600; //like ironbar window
		InitializeEntity(e, LODmodel_attach, INITPRIO_FINDTARGET);
	} else if (self.count == MTB64_FURN_IMPALEMENTPOLE) {
		e.objcthitmaterial = 8; //Wooden
		
		//e.model = "models/dungeon/orc_grilling_rack.iqm";
		//e.lodmodel1 = "models/dungeon/implmntspklod1.iqm";
		//e.lodmodel2 = "models/dungeon/implmntspklod2.iqm";
		//e.lodmodel3 = "models/dungeon/implmntspklod3.iqm";
		//e.lodmodel4 = "models/dungeon/implmntspklod4.iqm";
		//e.lodmodel5 = "models/dungeon/implmntspklod5.iqm";
		//e.lodmodel6 = "models/dungeon/implmntspklod6.iqm";
		
		e.lodmodel1 = "models/dungeon/implmntspk_lod1.iqm";
		e.lodmodel2 = "models/dungeon/implmntspk_lod2.iqm";
		e.lodmodel3 = "models/dungeon/implmntspk_lod3.iqm";
		e.lodmodel4 = "models/dungeon/implmntspk_lod4.iqm";
		e.lodmodel5 = "models/dungeon/implmntspk_lod5.iqm";
		e.lodmodel6 = "models/dungeon/implmntspk_lod6.iqm";
		e.lodmodel0substitute = "models/dungeon/implmntspk.iqm";
		e.lodmodel0substitute_use = 1;
		e.loddistance0substitute = 32; //origin to origin
		e.model = e.lodmodel4; //Now being used as Collision model
		
		trn = -90;
		hitpoints = 400; //wooden, more than wooden bar window
		InitializeEntity(e, LODmodel_attach, INITPRIO_FINDTARGET);

	} else if (self.count == MTB64_FURN_IRONBRAZIER) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/flamecontainers/ironbrazier.iqm";
		e.lodmodel1 = "models/flamecontainers/ironbrazier_lod1.iqm";
		e.lodmodel2 = "models/flamecontainers/ironbrazier_lod2.iqm";
		e.lodmodel3 = "models/flamecontainers/ironbrazier_lod3.iqm";
		trn = -90;
		hitpoints = 5600; //like ironbar window
	} else if (self.count == MTB64_FURN_GIBBET) {
		e.objcthitmaterial = 2; //Metal
		e.model = "models/dungeon/gibbet.iqm";
		trn = -90;
		hitpoints = 5700; //like ironbar window
	} else if (self.count == MTB64_FURN_BLKSMHFORGE) {
		e.objcthitmaterial = 4; //Brick
		e.model = "models/blacksmith/blacksmithforge.iqm";
		trn = -90;
		hitpoints = 3840; //Like curtainwall stone
		e.canigniteflame = 1;
	} else if (self.count == MTB64_FURN_WORKBENCH) {
		e.objcthitmaterial = 8; //Wood
		e.model = "models/tables/workbench.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_CHAIR_FANCY1) {
		//Not setting objcthitmaterial, these are poofy
		e.model = "maps/buildables/furn_chair_fancy1.bsp";
		trn = -90;
		hitpoints = 200; //Wooden
	} else if (self.count == MTB64_FURN_CHAIR_FANCY2) {
		e.model = "maps/buildables/furn_chair_fancy2.bsp";
		trn = -90;
		hitpoints = 200; //Wooden
	} else if (self.count == MTB64_FURN_CHAIR_FANCY3) {
		e.model = "models/chairs/poltroncina.iqm";
		trn = -90;
		hitpoints = 300; //Wooden chest
	} else if (self.count == MTB64_FURN_CHAISELOUNGE) {
		e.model = "models/chairs/chaiselounge.iqm";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_BED_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/furn_bed_wood.bsp";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_TABLE_WOOD) {
		e.objcthitmaterial = 8; //Wood
		e.model = "maps/buildables/furn_table_wood.bsp";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_EMPTYSHELF_WOOD) {
		e.objcthitmaterial = 8; //Wood //These are set and can't be moved so the detection often works
		//Setting anyway as sometimes the arrow hits a no-texture fact 
		e.model = "maps/buildables/furn_bookshelf_w_empty.bsp";
		trn = -90;
		hitpoints = 300; //Wooden
	} else if (self.count == MTB64_FURN_BOOKSHELF_WOOD) {
		e.objcthitmaterial = 8; //Wood //Same as above
		e.model = "maps/buildables/furn_bookshelf_w.bsp";
		trn = -90;
		hitpoints = 300; //Wooden
		
	} else if (self.count == MTB64_FURN_GREEKPILLAR) {
		e.objcthitmaterial = 3; //Stone
		e.model = "models/pillars/greekpillar.iqm";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_FURN_GREEKPILLARM) {
		e.objcthitmaterial = 3; //Stone
		e.model = "models/pillars/greekpillar.iqm";
		if (ourmarblecolor == 1) {
			e.skin = 2; //Off by one as for this model marbles start at 1
		} else if (ourmarblecolor == 2) {
			e.skin = 3; 
		} else if (ourmarblecolor == 3) {
			e.skin = 4; 
		} else if (ourmarblecolor == 4) {
			e.skin = 5; 
		} else if (ourmarblecolor == 5) {
			e.skin = 6; 
		} else if (ourmarblecolor == 6) {
			e.skin = 7; 
		} else if (ourmarblecolor == 7) {
			e.skin = 8; 
		} else if (ourmarblecolor == 8) {
			e.skin = 9; 
		} else if (ourmarblecolor == 9) {
			e.skin = 10; 
		} else if (ourmarblecolor == 10) {
			e.skin = 11; 
		} else if (ourmarblecolor == 11) {
			e.skin = 12; 
		} else if (ourmarblecolor == 12) {
			e.skin = 13; 
		} else if (ourmarblecolor == 13) {
			e.skin = 14; 
		} else if (ourmarblecolor == 14) {
			e.skin = 15; 
		} else if (ourmarblecolor == 15) {
			e.skin = 16; 
		} else if (ourmarblecolor == 16) {
			e.skin = 17; 
		} else if (ourmarblecolor == 17) {
			e.skin = 18; 
		} else if (ourmarblecolor == 18) {
			e.skin = 19; 
		} else if (ourmarblecolor == 19) {
			e.skin = 20; 
		} else if (ourmarblecolor == 20) {
			e.skin = 21; 
		} else if (ourmarblecolor == 21) {
			e.skin = 22; 
		} else if (ourmarblecolor == 22) {
			e.skin = 23; 
		} else {
			e.skin = 1;
		}
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_FURN_ROMANCOLUMN) {
		e.objcthitmaterial = 3; //Stone
		e.model = "models/pillars/romancolumn.iqm";
		trn = -90;
		hitpoints = 4000;
	} else if (self.count == MTB64_FURN_ROMANCOLUMNM) {
		e.objcthitmaterial = 3; //Stone
		e.model = "models/pillars/romancolumn.iqm";
		if (ourmarblecolor == 1) {
			e.skin = 2; //Off by one as for this model marbles start at 1
		} else if (ourmarblecolor == 2) {
			e.skin = 3; 
		} else if (ourmarblecolor == 3) {
			e.skin = 4; 
		} else if (ourmarblecolor == 4) {
			e.skin = 5; 
		} else if (ourmarblecolor == 5) {
			e.skin = 6; 
		} else if (ourmarblecolor == 6) {
			e.skin = 7; 
		} else if (ourmarblecolor == 7) {
			e.skin = 8; 
		} else if (ourmarblecolor == 8) {
			e.skin = 9; 
		} else if (ourmarblecolor == 9) {
			e.skin = 10; 
		} else if (ourmarblecolor == 10) {
			e.skin = 11; 
		} else if (ourmarblecolor == 11) {
			e.skin = 12; 
		} else if (ourmarblecolor == 12) {
			e.skin = 13; 
		} else if (ourmarblecolor == 13) {
			e.skin = 14; 
		} else if (ourmarblecolor == 14) {
			e.skin = 15; 
		} else if (ourmarblecolor == 15) {
			e.skin = 16; 
		} else if (ourmarblecolor == 16) {
			e.skin = 17; 
		} else if (ourmarblecolor == 17) {
			e.skin = 18; 
		} else if (ourmarblecolor == 18) {
			e.skin = 19; 
		} else if (ourmarblecolor == 19) {
			e.skin = 20; 
		} else if (ourmarblecolor == 20) {
			e.skin = 21; 
		} else if (ourmarblecolor == 21) {
			e.skin = 22; 
		} else if (ourmarblecolor == 22) {
			e.skin = 23; 
		} else {
			e.skin = 1;
		}
		trn = -90;
		hitpoints = 4000;
	
	} else if (self.count == -601) {
		e.model = "maps/buildables/floor_wood_sepplanks2.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == -602) {
		e.model = "maps/buildables/floor_wood_sepplanks3.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == -603) {
		e.model = "maps/buildables/floor_wood_sepplanks.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == -604) {
		e.model = "maps/buildables/floor_wood_planks.bsp";
		trn = -90;
		hitpoints = 1200;
	} else if (self.count == -605) {
		e.model = "maps/buildables/floor_wood_check.bsp";
		trn = -90;
		hitpoints = 1200;
	
	} else if (self.count == -609) {
		e.model = "maps/buildables/floor_wood_stakes.bsp";
		trn = -90;
		hitpoints = 1125;
	} else if (self.count == -610) {
		e.model = "maps/buildables/floor_iron_spikes.bsp";
		trn = -90;
		hitpoints = 6000;
	
	} else if (self.count == -615) {
		e.model = "maps/buildables/floor_brick_trapdoor.bsp";
		trn = -90;
		hitpoints = 1200; //Less wood but has some iron supports
		
	} else if (self.count == -618) {
		e.model = "maps/buildables/floor_iron_trapgrate.bsp";
		trn = -90;
		hitpoints = 6000;
		
	} else if (self.count == -620) {
		e.model = "maps/buildables/floor_stone_tan.bsp";
		trn = -90;
		hitpoints = 2400;
		
	} else if (self.count == -640) {
		e.model = "maps/buildables/floor_tiles_blackwhite.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -641) {
		e.model = "maps/buildables/floor_tiles_bluegray.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -642) {
		e.model = "maps/buildables/floor_tiles_browncheck.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -643) {
		e.model = "maps/buildables/floor_tiles_e7brick.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -644) {
		e.model = "maps/buildables/floor_tiles_e7brickr.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -645) {
		e.model = "maps/buildables/floor_tiles_e7bricky.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -646) {
		e.model = "maps/buildables/floor_tiles_gray.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == -647) {
		e.model = "maps/buildables/floor_tiles_green.bsp";
		trn = -90;
		hitpoints = 2400;	
		
	} else if (self.count == -670) {
		e.model = "maps/buildables/floor_granite_black.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -671) {
		e.model = "maps/buildables/floor_granite_dark.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -672) {
		e.model = "maps/buildables/floor_granite_light2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -673) {
		e.model = "maps/buildables/floor_granite_mix.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -674) {
		e.model = "maps/buildables/floor_granite_olive.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -675) {
		e.model = "maps/buildables/floor_granite_tan.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -676) {
		e.model = "maps/buildables/floor_granite_trav1.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -677) {
		e.model = "maps/buildables/floor_granite_trav2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -678) {
		e.model = "maps/buildables/floor_granite_light.bsp";
		trn = -90;
		hitpoints = 4060;
	
	} else if (self.count == -700) {
		e.model = "maps/buildables/floor_marble_blackbrown.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -701) {
		e.model = "maps/buildables/floor_marble_blackwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -702) {
		e.model = "maps/buildables/floor_marble_chessgreenwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -703) {
		e.model = "maps/buildables/floor_marble_cyanwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -704) {
		e.model = "maps/buildables/floor_marble_dbluewhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -705) {
		e.model = "maps/buildables/floor_marble_gray.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -706) {
		e.model = "maps/buildables/floor_marble_grecwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -707) {
		e.model = "maps/buildables/floor_marble_greengreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -708) {
		e.model = "maps/buildables/floor_marble_greenwhite2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -709) {
		e.model = "maps/buildables/floor_marble_greenwhite3.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -710) {
		e.model = "maps/buildables/floor_marble_greenwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -711) {
		e.model = "maps/buildables/floor_marble_lbluewhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -712) {
		e.model = "maps/buildables/floor_marble_nero.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -713) {
		e.model = "maps/buildables/floor_marble_pinkred.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -714) {
		e.model = "maps/buildables/floor_marble_pinktan.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -715) {
		e.model = "maps/buildables/floor_marble_pinkwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -716) {
		e.model = "maps/buildables/floor_marble_purplewhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -717) {
		e.model = "maps/buildables/floor_marble_redpink.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -718) {
		e.model = "maps/buildables/floor_marble_redwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -719) {
		e.model = "maps/buildables/floor_marble_tanbrown.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -720) {
		e.model = "maps/buildables/floor_marble_tantan.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -721) {
		e.model = "maps/buildables/floor_marble_white2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -722) {
		e.model = "maps/buildables/floor_marble_white.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -723) {
		e.model = "maps/buildables/floor_marble_whitewhite2.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -724) {
		e.model = "maps/buildables/floor_marble_whitewhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -725) {
		e.model = "maps/buildables/floor_marble_woodliketan.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -726) {
		e.model = "maps/buildables/floor_marble_yellowbrown.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -727) {
		e.model = "maps/buildables/floor_marble_ygreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -728) {
		e.model = "maps/buildables/floor_marble_ygreengreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -729) {
		e.model = "maps/buildables/floor_marble_ygreenwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -730) {
		e.model = "maps/buildables/floor_marble_ygreenygreen.bsp";
		trn = -90;
		hitpoints = 4060;
		
	} else if (self.count == -760) {
		e.model = "maps/buildables/floor_marble_romanredwhitegreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -761) {
		e.model = "maps/buildables/floor_marble_romancredwhiteblack.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -762) {
		e.model = "maps/buildables/floor_marble_romanxredwhite.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -763) {
		e.model = "maps/buildables/floor_marble_romancyanlgreengreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -764) {
		e.model = "maps/buildables/floor_marble_romanccyanlgreenblack.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -765) {
		e.model = "maps/buildables/floor_marble_romanxcyanlgreen.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -766) {
		e.model = "maps/buildables/floor_marble_romanbrownblackgray.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -767) {
		e.model = "maps/buildables/floor_marble_romancbrownblackgray.bsp";
		trn = -90;
		hitpoints = 4060;
	} else if (self.count == -768) {
		e.model = "maps/buildables/floor_marble_romanxbrownblack.bsp";
		trn = -90;
		hitpoints = 4060;
		
		
	} else if (self.count == -2) {
		e.model = "maps/buildables/building_nippon_house.bsp";
		trn = -90;
		hitpoints = 1000;
	} else if (self.count == -3) {
		e.model = "maps/buildables/building_nippon_shrine.bsp";
		trn = -90;
		hitpoints = 2000;
	} else if (self.count == -4) {
		e.model = "maps/buildables/building_nippon_dojo.bsp";
		trn = -90;
		hitpoints = 1500;
	} else if (self.count == 1001) {
		e.model = "maps/buildables/building_commandpost.bsp";
		//This one not tagged as military as you need to build them to build anything often
		trn = -90;
		hitpoints = 29000;
	} else if (self.count == 1002) {
		e.model = "maps/buildables/building_shieldgen.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == 1003) {
		e.model = "maps/buildables/building_shelter.bsp";
		//This one is not tagged as residential so as not to influence rand placed buildings 
		trn = -90;
		hitpoints = 6000;
	} else if (self.count == 1004) {
		e.model = "maps/buildables/building_glassbase.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 14000;
	} else if (self.count == 1005) {
		e.model = "maps/buildables/building_newhangar.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1006) {
		e.model = "maps/buildables/building_securitybuilding.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 82000;
	} else if (self.count == 1007) {
		e.model = "maps/buildables/building_tankpad.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 100000; //Simple concrete pad, hard to destroy
	} else if (self.count == 1008) {
		e.model = "maps/buildables/building_stockpile.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 15000; //Stockpile
	} else if (self.count == 1009) {
		e.model = "maps/buildables/building_ammodepot.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 10000;
	} else if (self.count == 1010) {
		e.model = "maps/buildables/building_oiltank.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1011) {
		e.model = "maps/buildables/building_energytank.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1012) {
		e.model = "maps/buildables/building_apartments.bsp";
		e.building_class = BUILDINGCLASS_RESIDENTIAL_DENSE;
		trn = -90;
		hitpoints = 14000;
	} else if (self.count == 1013) {
		e.model = "maps/buildables/building_tur_raised.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1014) {
		e.model = "maps/buildables/building_tur_medium.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1015) {
		e.model = "models/pomp/pomp.zym";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 2000;
	} else if (self.count == 1016) {
		e.model = "maps/buildables/building_chemical1.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1017) {
		e.model = "maps/buildables/building_chemical2.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1018) {
		e.model = "maps/buildables/building_chemical3.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1019) {
		e.model = "maps/buildables/building_factory1.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 18000;
	} else if (self.count == 1020) {
		e.model = "maps/buildables/building_sentry_raised.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3200;
	} else if (self.count == 1021) {
		e.model = "maps/buildables/building_furnace.bsp";
		e.building_class = BUILDINGCLASS_INDUSTRIAL;
		trn = -90;
		hitpoints = 5200;
	} else if (self.count == 1022) {
		e.model = "maps/buildables/building_officetower1.bsp";
		e.building_class = BUILDINGCLASS_COMMERCIAL;
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1023) {
		e.model = "maps/buildables/building_firesuppression.bsp";
		e.building_class = BUILDINGCLASS_COMMERCIAL;
		trn = -90;
		hitpoints = 15000;
	} else if (self.count == 1024) {
		e.model = "maps/buildables/building_officetower2.bsp";
		e.building_class = BUILDINGCLASS_COMMERCIAL;
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1025) {
		e.model = "maps/buildables/building_tensionwiretower.bsp";
		trn = -90;
		hitpoints = 3200;
	} else if (self.count == 1026) {
		e.model = "maps/buildables/building_officetower3.bsp";
		e.building_class = BUILDINGCLASS_COMMERCIAL;
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1027) {
		e.model = "maps/buildables/building_apcpad.bsp";
		//No, might not be military , depends on what is around and spawned //e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 100000; //Simple concrete pad, hard to destroy
	} else if (self.count == 1028) {
		e.model = "maps/buildables/building_coveredgarage.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 14000;
	} else if (self.count == 1029) {
		//Bulldozer pad, uses same model as apcpad
		e.model = "maps/buildables/building_apcpad.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 100000; //Simple concrete pad, hard to destroy
	} else if (self.count == 1030) {
		e.model = "maps/buildables/building_energytank_small.bsp";
		//e.building_class = BUILDINGCLASS_INDUSTRIAL; //Small might be anywhere
		trn = -90;
		hitpoints = 800; //Like shieldgen
	} else if (self.count == 1031) {
		e.model = "maps/buildables/building_shieldgen_canopy.bsp";
		trn = -90;
		hitpoints = 800;
	} else if (self.count == 1032) {
		e.model = "maps/buildables/building_oiltank_small.bsp";
		//e.building_class = BUILDINGCLASS_INDUSTRIAL; //Small might be anywhere
		trn = -90;
		hitpoints = 800; //Like shieldgen
	} else if (self.count == 1033) {
		e.model = "maps/buildables/building_oildistributionswitch.bsp";
		//e.building_class = BUILDINGCLASS_INDUSTRIAL; //Small might be anywhere
		trn = -90;
		hitpoints = 800; //Like shieldgen
	} else if (self.count == 1034) {
		e.model = "maps/buildables/building_chemicaldistributionswitch.bsp";
		//e.building_class = BUILDINGCLASS_INDUSTRIAL; //Small might be anywhere
		trn = -90;
		hitpoints = 800; //Like shieldgen
	} else if (self.count == 1035) {
		e.model = "maps/buildables/building_suitpad.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 100000; //Simple concrete pad, hard to destroy
	} else if (self.count == 1036) {
		e.model = "maps/buildables/building_hammerforge.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 18000;
	} else if (self.count == 1037) {
		e.model = "maps/buildables/building_observationtower1.bsp";
		//e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 14000;
	} else if (self.count == 1038) {
		e.model = "maps/buildables/building_pylon.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1110
		|| self.count == 1111
		|| self.count == 1112
		|| self.count == 1113
		|| self.count == 1114
		|| self.count == 1115
		|| self.count == 1116
		|| self.count == 1117
		|| self.count == 1118) {
		nosnapangles = 1;
		e.model = "null";
		trn = -90;
		hitpoints = 2060;
		//Point defense guns
	} else if (self.count == 1120 || self.count == 1121 || self.count == 1122
		|| self.count == 1123 || self.count == 1124 || self.count == 1125
		|| self.count == 1126 || self.count == 1127) {
		e.model = "maps/buildables/building_pylon.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1130 || self.count == 1131) {
		e.model = "maps/buildables/building_mantur_raised.bsp";
		e.building_class = BUILDINGCLASS_MILITARY;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1501) {
		e.model = "maps/buildables/building_greenhouse.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 5000;
	} else if (self.count == 1502) {
		e.model = "maps/buildables/recruitment_upost.bsp";
		trn = -90;
		hitpoints = 2060; //Metal
	} else if (self.count == 1510) {
		e.model = "maps/buildables/building_solarpanel.bsp";
		e.building_class = BUILDINGCLASS_LIGHTINDUSTRIAL;
		trn = -90;
		hitpoints = 3000;
	} else if (self.count == 1520) {
		e.model = "maps/buildables/wall_fencemil.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == 1521) {
		e.model = "maps/buildables/wall_fencemil_tower.bsp";
		trn = -90;
		hitpoints = 2700;
	} else if (self.count == 1522) {
		e.model = "maps/buildables/wall_fencemil_gate.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == 1523) {
		e.model = "maps/buildables/wall_fencemil_gate_large.bsp";
		trn = -90;
		hitpoints = 2400;
	} else if (self.count == 1524) {
		e.model = "maps/buildables/wall_fencemil_gate_large_doorframe.bsp";
		trn = -90;
		hitpoints = 1200; //Half of fence
	} else if (self.count == 1530) {
		e.model = "maps/buildables/wall_concrete.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1531) {
		e.model = "maps/buildables/wall_concrete_tower.bsp";
		trn = -90;
		hitpoints = 26500;
	} else if (self.count == 1532) {
		e.model = "maps/buildables/wall_concrete_gate.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1533) {
		e.model = "maps/buildables/wall_concrete_gate_large.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1534) {
		e.model = "maps/buildables/wall_concrete_tall.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1535) {
		e.model = "maps/buildables/wall_concrete_tall_stairs.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1536) {
		e.model = "maps/buildables/wall_concrete_tall_tower.bsp";
		trn = -90;
		hitpoints = 26500;
	} else if (self.count == 1537) {
		e.model = "maps/buildables/wall_concrete_taller_tower.bsp";
		trn = -90;
		hitpoints = 26500;
	} else if (self.count == 1538) {
		e.model = "maps/buildables/wall_concrete_fill.bsp";
		trn = -90;
		hitpoints = 24000;
	} else if (self.count == 1539) {
		e.model = "maps/buildables/wall_concrete_fill_stairs.bsp";
		trn = -90;
		hitpoints = 22000;
	} else if (self.count == 1540) {
		e.model = "maps/buildables/wall_concrete_interior.bsp";
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1541) {
		e.model = "maps/buildables/wall_concrete_interior_door.bsp";
		trn = -90;
		hitpoints = 12000;
	} else if (self.count == 1542) {
		e.model = "maps/buildables/wall_concrete_tall_gate.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1543) {
		e.model = "maps/buildables/wall_concrete_tall_gate_large.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1546) {
		e.model = "maps/buildables/wall_concrete_gate_large_doorframe_steel.bsp";
		trn = -90;
		hitpoints = 4000; //Half of steel "vaults", about double of small steel door (more stuff)
	} else if (self.count == 1548) {
		e.model = "maps/buildables/wall_concrete_tall_berm.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1549) {
		e.model = "maps/buildables/wall_concrete_berm.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1550) {
		e.model = "models/misc/tanktraps_pyramid.bsp";
		trn = -90;
		hitpoints = 100000;
	} else if (self.count == 1551) {
		e.model = "maps/buildables/building_tankpier.bsp";
		trn = -90;
		hitpoints = 100000;
	} else if (self.count == 1630) {
		e.model = "maps/buildables/foundation_wall_concrete.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == 1631) {
		e.model = "maps/buildables/foundation_tower_concrete.bsp";
		trn = -90;
		hitpoints = 27000;
	} else if (self.count == 1650) {
		e.model = "maps/buildables/bridge_future_landing.bsp";
		trn = -90;
		hitpoints = 8000;
	} else if (self.count == 1651) {
		e.model = "maps/buildables/bridge_future.bsp";
		trn = -90;
		hitpoints = 7500;
	} else if (self.count == 1652) {
		e.model = "maps/buildables/bridge_future_light.bsp";
		trn = -90;
		hitpoints = 6000;
	} else if (self.count == 1653) {
		e.model = "maps/buildables/bridge_future_light_control.bsp";
		trn = -90;
		hitpoints = 8000;
	} else if (self.count == 1680) {
		e.model = "maps/buildables/vault_future_mfloor.bsp";
		trn = -90;
		hitpoints = 8000;
	} else if (self.count == 1681) {
		e.model = "maps/buildables/vault_future_vent.bsp";
		trn = -90;
		hitpoints = 8000;
	} else if (self.count == 1686) {
		e.model = "maps/buildables/vault_concrete.bsp";
		trn = -90;
		hitpoints = 26000;
	} else if (self.count == -1) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_sniperspire_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_sniperspire.bsp";
		}
		trn = 0;
		hitpoints = 60000;
	} else if (self.count == -5) {
		if (ourcastlecolor == 1 || ourcastlecolor == 5) {
			//Tan or Light tan gets mudbrick
			e.model = "maps/buildables/building_belltower_mudbrick.bsp";
		} else {
			e.model = "maps/buildables/building_belltower.bsp";
		}
		trn = -90;
		hitpoints = 60000;
	} else {
		print("Multitool_Spawner: No Building Exists For Selection, Removing: ", etos(self), "\n");
		self.think = func_null;
		self.nextthink = 0;
		remove_safely(e);
		remove_safely(self);
		return;
	}
	
	
	e.nopounddown = 1;
	if (multitool_isfurniture(self.count)) {
		e.isfurniture = 1;
	} else {
		e.isbldablbld = 1; //Currently used only in w_common to check if bullet holes in glass are hitting a built building
	}
	
	
	if (self.isweak || self.isveryweak) {
		if (self.isveryweak &&
			(self.isveryweak >= 1
			|| self.isveryweak > random())) {
				//print("IsVeryWeak\n");
				hitpoints = hitpoints * 0.01;
		} else if (self.isweak &&
			(self.isweak >= 1
			|| self.isweak > random())) {
				//print("IsWeak\n");
				hitpoints = hitpoints * 0.1;
		}
	}
	
	
	//Precaching all these causes an error in client connect
	//So do it just in time.
	if ((self.count >= MTB64_CASTLE && self.count <= MTB64_CASTLELAST)
	|| (self.count == MTB64_CASTLESQUARE)
	|| (self.count >= 570 && self.count <= 579)
	|| (multitool_isbuildingcurtainstone(self.count))
	|| (multitool_isbuildingcastlestoneextra(self.count))
	|| (self.count == 6) || (self.count == 8)
	|| (self.count == 7) || (self.count == 10)
	|| (self.count >= 660 && self.count <= 669)
	|| (self.count >= 10700 && self.count <= 10799)) {
		//print("castlecolorsprecache\n");
		if (ourcastlecolor) {
			precache_model (e.model);
			if(self.count == 7) {
				if (ourcastlecolor == 1 ||
				ourcastlecolor == 2 || ourcastlecolor == 5) {
					//Tan //White //LightTan
					precache_model ("maps/buildables/door_up_small_metal1_rstcopper.bsp");
				} else if (ourcastlecolor == 3) {
					//Green
					precache_model ("maps/buildables/door_up_small_metal1_whiterust.bsp");
				} else if (ourcastlecolor == 4) {
					//Brown
					precache_model ("maps/buildables/door_up_small_metal1_dullgrey.bsp");
				} else if (ourcastlecolor == 6) {
					//Black
					precache_model ("maps/buildables/door_up_small_metal1_redrust.bsp");
				} else if (ourcastlecolor == 7) {
					//Mauve
					precache_model ("maps/buildables/door_up_small_metal1_dark.bsp");
				} else if (ourcastlecolor == 8) {
					//Pink
					precache_model ("maps/buildables/door_up_small_metal1_dark.bsp");	
				}
			}
		} else if (self.count == 616) {
			precache_model (e.model);
		}
	} else if (self.count == 27) {
		//Crusader Stronghold
		precache_model ("maps/buildables/door_up_med2_x_metal1.bsp");
		precache_model ("maps/buildables/building_crusaderstronghold_firepots.bsp");
		precache_model ("maps/buildables/building_crusaderstronghold_duengonchain.bsp");
		
		if (ourcastlecolor) {
			precache_model (e.model);
			if(self.count == 7) {
				if (ourcastlecolor == 1 ||
				ourcastlecolor == 2 || ourcastlecolor == 5) {
					//Tan //White //LightTan
					precache_model ("maps/buildables/door_up_small_metal1_rstcopper.bsp");
				} else if (ourcastlecolor == 3) {
					//Green
					precache_model ("maps/buildables/door_up_small_metal1_whiterust.bsp");
				} else if (ourcastlecolor == 4) {
					//Brown
					precache_model ("maps/buildables/door_up_small_metal1_dullgrey.bsp");
				} else if (ourcastlecolor == 6) {
					//Black
					precache_model ("maps/buildables/door_up_small_metal1_redrust.bsp");
				} else if (ourcastlecolor == 7) {
					//Mauve
					precache_model ("maps/buildables/door_up_small_metal1_dark.bsp");
				} else if (ourcastlecolor == 8) {
					//Pink
					precache_model ("maps/buildables/door_up_small_metal1_dark.bsp");	
				}
			}
		} else if (self.count == 616) {
			precache_model (e.model);
		}
		
	} else if (self.count >= MTB64_MARBLEWHITE && self.count <= MTB64_MARBLEWHITELAST) {
		if (ourmarblecolor) {
			precache_model (e.model);
		}
	} else if (self.count >= MTB64_WOOD1 && self.count <= MTB64_WOOD1LAST) {
		if (ourwoodcolor) {
			precache_model (e.model);
		}
	} else if (self.count >= MTB64_SANDSTONE && self.count <= MTB64_SANDSTONE) {
		if (oursstonecolor) {
			precache_model (e.model);
		}
	} else if (self.count == MTB64_STAKES_WOOD1 || self.count == MTB64_BWIRE
		|| self.count == MTB64_PLATFORMWOOD_8 || self.count == MTB64_PLATFORMWOOD_24) {
		precache_model (e.model);
	} else if (self.count == 10709 || self.count == 10710) {
		//Portcullis (Moving) Gate
		precache_model (e.model);
		if (self.count == 10709) {
			precache_model ("maps/buildables/door_up_portcullis_wood_gate_large.bsp");
		} else {
			precache_model ("maps/buildables/door_up_portcullis_iron_gate_large.bsp");
		}
	} else if (self.count >= 10000 && self.count < 20000) {
		//Extra things//
		precache_model (e.model);
	} else if (self.count == MTB64_DOOR_R_WOOD) {
		precache_model (e.model);
		
		if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
			precache_model ("maps/buildables/door_rot_small_64_wood1_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1a_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1b_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1c_short.bsp");
		} else {
			precache_model ("maps/buildables/door_rot_small_64_wood1.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1a.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1b.bsp");
			precache_model ("maps/buildables/door_rot_small_64_wood1c.bsp");
		}
		
		precache_sound ("sound/plats/medplat2.ogg");
	} else if (self.count == MTB64_DOOR_R_JWOOD) {
		precache_model (e.model);
		
		if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
			precache_model ("maps/buildables/door_rot_small_64_jwood1_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1a_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1b_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1c_short.bsp");
		} else {
			precache_model ("maps/buildables/door_rot_small_64_jwood1.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1a.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1b.bsp");
			precache_model ("maps/buildables/door_rot_small_64_jwood1c.bsp");
		}
		
		precache_sound ("sound/plats/medplat2.ogg");
	} else if (self.count == MTB64_DOOR_R_FWOOD) {
		precache_model (e.model);
		
		if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
			precache_model ("maps/buildables/door_rot_small_64_fwood1_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1a_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1b_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1c_short.bsp");
		} else {
			precache_model ("maps/buildables/door_rot_small_64_fwood1.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1a.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1b.bsp");
			precache_model ("maps/buildables/door_rot_small_64_fwood1c.bsp");
		}
		
		precache_sound ("sound/plats/medplat2.ogg");
	} else if (self.count == MTB64_DOOR_R_IRONBAR) {
		precache_model (e.model);
		
		if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
			precache_model ("maps/buildables/door_rot_small_64_ironbar_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbara_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbarb_short.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbarc_short.bsp");
		} else {
			precache_model ("maps/buildables/door_rot_small_64_ironbar.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbara.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbarb.bsp");
			precache_model ("maps/buildables/door_rot_small_64_ironbarc.bsp");
		}
		
		precache_sound ("sound/plats/medplat2.ogg");
	} else if (self.count == MTB64_FITTEDWINDOW_CASTLE_ALOOP
	|| self.count == MTB64_FITTEDWINDOW_CASTLE_SWALL
	|| self.count == MTB64_FITTEDWINDOW_WINDOW
	|| self.count == MTB64U_FITTEDWINDOW_STEELSLIT
	|| self.count == MTB64U_FITTEDWINDOW_STEELPLATE
	|| self.count == MTB64U_FITTEDWINDOW_CWALL
	|| self.count == MTB64U_FITTEDWINDOW_UWINDOW) {
		precache_model (e.model);
	} else if (self.count <= -600 && self.count >= -800) {
		//Floors, lots of them so we didn't precache at map start
		//Too many precaches (often needless) = SZ overflow on server
		precache_model (e.model);
		if (self.count == -610) {
			precache_model ("maps/buildables/floor_iron_spikes-top.bsp");
			precache_model ("maps/buildables/rubble_ironbeams_512.bsp");
		} else if (self.count == -609) {
			precache_model ("maps/buildables/floor_wood_stakes-top.bsp");
		} else if (self.count == -615) {
			precache_model ("maps/buildables/door_rotdown_trap_wood1.bsp");
			precache_model ("maps/buildables/door_rotdown_trap_wood1a.bsp");
			precache_model ("maps/buildables/door_rotdown_trap_wood1b.bsp");
			precache_model ("maps/buildables/door_rotdown_trap_wood1c.bsp");
		} else if (self.count == -618) {
			precache_model ("maps/buildables/door_down_trap_iron1.bsp");
		}
	} else if (self.count == 1524 || self.count == 1546) {
		//Fence Mil Moving Gate
		precache_model (e.model);
		if (self.count == 1524) {
			precache_model ("maps/buildables/door_side_fencemil_gate_large.bsp");
		} else {
			precache_model ("maps/buildables/door_side_steel_gate_large.bsp");
		}
	} else if (self.count >= MTB64UFIRST && self.count <= MTB64ULAST) {
		//Same for utilitool blocks, we really can't precache
		//everything at map start, that overloads the space available
		//to send the client the info of what models to precache
		//when he (yes I assume it's a he, this is a video game) connects
		precache_model (e.model);
		if (self.count == MTB64U_DOOR_R_STEEL) {
			//Doors have 2 parts, frame and actual door
			if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
				precache_model ("maps/buildables/door_rot_small_64_steel1_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1a_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1b_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1c_short.bsp");
			} else {
				precache_model ("maps/buildables/door_rot_small_64_steel1.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1a.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1b.bsp");
				precache_model ("maps/buildables/door_rot_small_64_steel1c.bsp");
			}
		} else if (self.count == MTB64U_DOOR_R_GLASS) {
			//Doors have 2 parts, frame and actual door
			if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
				precache_model ("maps/buildables/door_rot_small_64_glass1_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1a_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1b_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1c_short.bsp");
			} else {
				precache_model ("maps/buildables/door_rot_small_64_glass1.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1a.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1b.bsp");
				precache_model ("maps/buildables/door_rot_small_64_glass1c.bsp");
			}
		} else if (self.count == MTB64U_DOOR_R_PLAIN) {
			//Doors have 2 parts, frame and actual door
			if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
				precache_model ("maps/buildables/door_rot_small_64_plain1_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1a_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1b_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1c_short.bsp");
			} else {
				precache_model ("maps/buildables/door_rot_small_64_plain1.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1a.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1b.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain1c.bsp");
			}
		} else if (self.count == MTB64U_DOOR_R_PLAIN2) {
			//Doors have 2 parts, frame and actual door
			if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5) {
				precache_model ("maps/buildables/door_rot_small_64_plain2_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2a_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2b_short.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2c_short.bsp");
			} else {
				precache_model ("maps/buildables/door_rot_small_64_plain2.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2a.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2b.bsp");
				precache_model ("maps/buildables/door_rot_small_64_plain2c.bsp");
			}
		}
	}
	
	if (nosnapangles == 1) {
		//
	} else {
		//Snap angles
		if (self.angles_y < 135 && self.angles_y >= 45)
			self.angles_y = 90;
		else if (self.angles_y < 45 && self.angles_y >= -45)
			self.angles_y = 0;
		else if (self.angles_y < -45 && self.angles_y >= -135)
			self.angles_y = -90;
		else
			self.angles_y = 180;
	}
	
	e.solid = SOLID_BSP;
	setorigin(e, self.origin);
	
	oldself = self;
	self = e;
	if (oldself.multitool_flipblock) {
			e.angles_x = 180;
			e.multitool_flipblock = 1;
			self.origin_z = self.origin_z + 64; //Offset model (block models start at 0 z, to 64. Not centered
			setorigin(self, self.origin);
	}
	
	if (oldself.multitool_roofcolor) {
		self.multitool_roofcolor = oldself.multitool_roofcolor;
	}
	
	if (oldself.multitool_flamecolor) {
		self.multitool_flamecolor = oldself.multitool_flamecolor;
	}
	
	if (oldself.multitool_woodcolor) {
		self.multitool_woodcolor = oldself.multitool_woodcolor;
	}
	
	if (oldself.multitool_marblecolor) {
		self.multitool_marblecolor = oldself.multitool_marblecolor;
	}
	
	if (oldself.multitool_castlecolor) {
		self.multitool_castlecolor = oldself.multitool_castlecolor;
	}
	
	if (oldself.multitool_sstonecolor) {
		self.multitool_sstonecolor = oldself.multitool_sstonecolor;
	}
	
	self.multitool_doorcenter = oldself.multitool_doorcenter; //So we will set proper door frame
	
	if (multitool_isdragable(oldself.count) && !oldself.multitool_forcenotdragable) {
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
		self.grab = 3;
		self.multitool_dragable = 1; //tests later
		self.movetype = MOVETYPE_NONE;
		if (oldself.count == MTB64U_FURN_FRIDGE2
		|| oldself.count == MTB64U_FURN_FRIDGE3)
		{
			setsize (self, '-20 -20 0', '20 20 112');
		}
	} else {
		if (oldself.count == MTB64_FURN_GREEKPILLARM
		|| oldself.count == MTB64_FURN_ROMANCOLUMNM
		|| oldself.count == MTB64_FURN_SPIKEDRACK
		|| oldself.count == MTB64_FURN_IMPALEMENTPOLE
		|| oldself.count == MTB64_FURN_IRONBRAZIER) {
			//These must use gamemodel as they use .skins, would like to use client model tho ohwell...
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
		} else {
			//gamemodel doesn't work for this, just clientmodel
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
		}
		self.movetype = MOVETYPE_PUSH;
		if (oldself.count == MTB64U_FURN_SHOWER)
		{
			setsize (self, '-40 -40 0', '40 40 152');
		} else if (oldself.count == MTB64_FURN_IRONBRAZIER)
		{
			oldself.multitool_forcesolidtype = SOLID_SLIDEBOX;
			setsize (self, '-32 -32 0', '32 32 64');
		}
	}
	
	if (oldself.count == MTB64_FURN_CHEST_WOOD)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 400;
		self.netname = "^x995Wooden Chest";
	} else if (oldself.count == MTB64_FURN_CHESTLARGE_WOOD)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 800;
		self.netname = "^x995Large Wooden Chest";
	} else if (oldself.count == MTB64_FURN_EMPTYSHELF_WOOD)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 600;
		self.netname = "^x995EmptyShelves";
	} else if (oldself.count == MTB64_FURN_BOOKSHELF_WOOD)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 40;
		self.netname = "^x995BookShelf";
	} else if (oldself.count == MTB64U_FURN_CRATE)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 200;
		self.netname = "^x999Crate";
	} else if (oldself.count == MTB64U_FURN_MTLCRATE)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 4000; //Big
		self.netname = "^x555Metal Crate";
	} else if (oldself.count == 1008)
	{	//Stockpile
		self.iscontainer = 1;
		self.iscontainer_storage = 32000; //Huge, 500*64 (many crates)
		self.netname = "Stockpile"; //Building doesn't get a color
	} else if (oldself.count == MTB64U_FURN_FRIDGE)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 700;
		self.netname = "^xDDCRefrigerator";
	} else if (oldself.count == MTB64U_FURN_FRIDGE2
	|| oldself.count == MTB64U_FURN_FRIDGE3)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 500;
		self.netname = "^x555Refrigerator";
	} else if (oldself.count == MTB64U_FURN_FRIDGE4)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 300;
		self.netname = "^xBB9Refrigerator";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINET1
	|| oldself.count == MTB64U_FURN_BSCKCABINET2
	|| oldself.count == MTB64U_FURN_BSCKCABINET3
	|| oldself.count == MTB64U_FURN_BSCKCABINET4)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 350;
		self.netname = "^x555Cabinet";
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETCORNER1
	|| oldself.count == MTB64U_FURN_BSCKCABINETCORNER2)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 380;
		self.netname = "^x555Cabinet (Corner)";
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP1
	|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP2)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 250;
		self.netname = "^x555Cabinet (Top, Corner)";
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
	|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 380;
		self.netname = "^x555Cabinet (Top, Corner, Deep)";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOP1)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 175;
		self.netname = "^x555Cabinet (Top)";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEP1)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 350;
		self.netname = "^x555Cabinet (Top, Deep)";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 175;
		self.netname = "^x555Cabinet (Top, Deep, Short)";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORT1)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 87;
		self.netname = "^x555Cabinet (Top, Short)";
	
	} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 195;
		self.netname = "^x555Cabinet (Top, Short, with Shelves)";
	} else if (oldself.count == MTB64U_FURN_STOVE
	|| oldself.count == MTB64U_FURN_STOVE2
	|| oldself.count == MTB64U_FURN_STOVE3
	|| oldself.count == MTB64U_FURN_STOVE4)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 380;
		self.netname = "^x111Stove";
	} else if (oldself.count == MTB64U_FURN_SINK
	|| oldself.count == MTB64U_FURN_SINK2)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 300;
		self.netname = "^xFFFSink";
	} else if (oldself.count == MTB64U_FURN_FILECABINET)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 450;
		self.netname = "^x999FileCabinet";
	} else if (oldself.count == MTB64U_FURN_SHELVES)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 500;
		self.netname = "^xDDDShelves";
	} else if (oldself.count == MTB64U_ARCHIVEBOX)
	{
		self.iscontainer = 1;
		self.iscontainer_storage = 600;
		self.netname = "^x999Archive";
	}
	
	
	if (oldself.multitool_forceinventory) {
		//This is set by map spawned furnishings etc
		oldself.spawnshieldtime = 1; //Got to set this to make Item_GiveAmmoTo happy
		if (Item_GiveTo(oldself, self)) //Transfer inventory set by mapper in spawnfunc to furnishing/building/etc
		{
			self.multitool_forceinventory = 1; //If we have inv, even if not set as container, allow ContainerAllInventoryPinata
		}
		oldself.spawnshieldtime = 0; //reset to 0
	}
	
	if (autocvar_g_balance_multitoolutilitool_noanimdroppeditems == 2) {
		self.noanimdroppeditems = 1;
	}
	
        self.solid = SOLID_BSP;
	if (oldself.multitool_forcesolidtype) {
		//print("FORCING SOLIDTYPE", vtos(self.mins)," mins ...", vtos(self.maxs)," maxs\n");
		self.solid = oldself.multitool_forcesolidtype;
		//print(etos(self), ":entity  ",ftos(self.solid)," Solidtype for multitool_forcesolidtype\n");
	}
	self.angles_y = oldself.angles_y + trn; //the door is at the back of what you are looking for defensive structures
	self = oldself;
	
	fbspot = e.origin;
	fbsorg = e.origin;
	fbsrad = 512;
	
	
	if (self.count == -1) {
		//SniperTower
		entity cp1;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 1584';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 200;
		self.max_health = 400;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
	} else if (self.count == -5) {
		//BellTower
		entity cp1;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '64 64 696';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 200;
		self.max_health = 400;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
	} else if ((self.count > 0 && self.count < 4) || (self.count == 8) || (self.count == 10)) {
		//Turret Towers
		float sufficentforgeparts;
		entity t1, t2, t3, t4, l1, cp1;
		
		sufficentforgeparts = 0;
		
		if (self.owner == world && autocvar_g_balance_multitool_noautoturretsforworldtowers >= 1) {
			sufficentforgeparts = 0;
		} else if (self.owner.multitool_noturretsintowers == 1) {
			sufficentforgeparts = 0;
			if ((clienttype(self.owner) == CLIENTTYPE_REAL)) {
				if (self.owner.multitool_helpfultipnagnexttime2 < time)
				{
					//We don't want to nag the self.owner too much about this
					if (self.owner.multitool_helpfultipnagtimes2 < 1) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 2;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 2) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 5;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 3) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 10;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 4) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 14;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 5) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 24;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 6) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 48;
					} else if (self.owner.multitool_helpfultipnagtimes2 < 7) {
						self.owner.multitool_helpfultipnagnexttime2 = time + 96;
					} else {
						self.owner.multitool_helpfultipnagnexttime2 = time + 192;
					}
					
					self.owner.multitool_helpfultipnagtimes2 = self.owner.multitool_helpfultipnagtimes2 + 1;
				 	
					sprint(self.owner, "Building auto-turrets in multitool towers disabled by player, To re-enable enter the command ^xA22multitool noturretsintowers^7 and toggle noturretsintowers to ALLOW\n");
				}
			}
		} else if (self.count == 1) {
			//player, failure message, ForgepieceNail, ForgepieceRocket, ForgepieceCell
			if(autocvar_g_balance_multitool_ancientonly) {
				if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 4, 0, 0))
				{
					sufficentforgeparts = 1;
				}
			} else {
				if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 8, 0, 0))
				{
					sufficentforgeparts = 1;
				}
			}
		} else if (self.count == 2) {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 4, 0, 4))
			{
				sufficentforgeparts = 1;
			}
		} else if (self.count == 3) {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 4, 4, 0))
			{
				sufficentforgeparts = 1;
			}
		} else if (self.count == 8) {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 4, 8, 0))
			{
				sufficentforgeparts = 1;
			}
		} else if (self.count == 10) {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 5, 10, 0))
			{
				sufficentforgeparts = 1;
			}
		} else {
			//Shouldn't reach here
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 2, 2, 2))
			{
				sufficentforgeparts = 1;
			}
		}
		
		if (self.owner == world && autocvar_g_balance_multitool_noautoturretsforworldtowers > 0 &&
		autocvar_g_balance_multitool_noautoturretsforworldtowers < 1) {
			if (random() < autocvar_g_balance_multitool_noautoturretsforworldtowers) {
		  		sufficentforgeparts = 0;
		  	}
		}
		
		t1 = spawn();
		t2 = spawn();
		t3 = spawn();
		t4 = spawn();
		l1 = spawn();
		
		t1.realowner = t2.realowner = t3.realowner = t4.realowner = self.owner;
		if (teamplay) {
			t1.team = t2.team = t3.team = t4.team = self.owner.team;
		}
		t1.turret_scale_range = t2.turret_scale_range = 
		t3.turret_scale_range = t4.turret_scale_range = 4;
		
		//t1.angles_y = random() * 180;
		oldself = self;
		
		
		
		self = t1;
		if (sufficentforgeparts) {
			multitool_spawnturret(oldself);
		}
		
		if (oldself.count == 10) {
			self.origin = e.origin + '224 224 578';
			self.angles_y = 45;
		} else if (oldself.count == 8) {
			self.origin = e.origin + '224 224 768';
			self.angles_y = 45;
		} else {
			self.origin = e.origin + '0 192 656';
			self.angles_y = 90;
		}
		setorigin(self, self.origin);
		
		
		
		self = t2;
		if (sufficentforgeparts) {
			multitool_spawnturret(oldself);
		}
		
		if (oldself.count == 10) {
			self.origin = e.origin + '224 -224 578';
			self.angles_y = -45;
		} else if (oldself.count == 8) {
			self.origin = e.origin + '224 -224 768';
			self.angles_y = -45;
		} else {
			self.origin = e.origin + '192 0 656';
			self.angles_y = 0;
		}
		setorigin(self, self.origin);
		
		
		
		self = t3;
		if (sufficentforgeparts) {
			multitool_spawnturret(oldself);
		}
		
		if (oldself.count == 10) {
			self.origin = e.origin + '-224 -224 578';
			self.angles_y = -135;
		} else if (oldself.count == 8) {
			self.origin = e.origin + '-224 -224 768';
			self.angles_y = -135;
		} else {
			self.origin = e.origin + '0 -192 656';
			self.angles_y = -90;
		}
		setorigin(self, self.origin);
		
		
		
		self = t4;
		if (sufficentforgeparts) {
			multitool_spawnturret(oldself);
		}
		
		if (oldself.count == 10) {
			self.origin = e.origin + '-224 224 578';
			self.angles_y = 135;
		} else if (oldself.count == 8) {
			self.origin = e.origin + '-224 224 786';
			self.angles_y = 135;
		} else {
			self.origin = e.origin + '-192 0 656';
			self.angles_y = 180;
		}
		setorigin(self, self.origin);
		
		entity t5;
		if (oldself.count == 10) {
			t5 = spawn();
			self = t5;
			if (teamplay) {
			self.team = oldself.owner.team;
			}
			self.multitool_reparableturret = 1;
			
			if (sufficentforgeparts) {
				if(autocvar_g_balance_multitool_ancientonly) {
					spawnfunc_turret_magichk();
				} else {
					spawnfunc_turret_hk();
				}
			}
			
			//self.origin = e.origin + '0 0 976';
			self.origin = e.origin + '0 0 1120';
			self.angles_y = 45;
			setorigin(self, self.origin);
			t5.realowner = oldself.owner;
		}
		
		t1.realowner = t2.realowner = t3.realowner = t4.realowner = oldself.owner;
		//t1.colormap = t2.colormap = t3.colormap = t4.colormap = oldself.owner.colormap;
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-64 -64 0';
		if (oldself.count == 10) {
			self.maxs = '64 64 170';
			self.origin = e.origin + '0 0 776';
		} else {
			self.maxs = '64 64 240';
			self.origin = e.origin + '0 0 448';
		}
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		if (oldself.count == 10) {
			self.origin = e.origin + '0 0 608';
		} else if (oldself.count == 8) {
			self.origin = e.origin + '0 0 784';
		} else {
			self.origin = e.origin + '80 80 656';
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		self = oldself;
		
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
		e.subordinate.subordinate.subordinate = t1;
		e.subordinate.subordinate.subordinate.subordinate = t2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = t3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = t4;
		
		if (oldself.count == 10) {
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = t5;
		}
		
		//print(etos(t1),"  ",etos(t2),"  ",etos(t3),"  ",etos(t4),"  ",etos(t5)," etos\n");
	} else if (self.count == 4) {
		entity f1, cp1;
		//Flag Stuff
		f1 = spawn();
		self = f1;
		multitool_spawnflag('256 256 208', e, oldself);
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '192 192 208';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 300;
		self.max_health = 600;
		spawnfunc_multitool_controlpoint();
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = f1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == 5) {
		//Stronghold
		entity d1, cbw1, cbw2, cbw3, cp1;
		float arev;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_med_metal1.bsp";
		if (e.angles_y == 0) {
			//print("0\n");
			self.origin = e.origin + '352 -480 32';
			arev = 180;
		} else if (e.angles_y == -90) {
			//print("1\n");
			self.origin = e.origin + '-480 -352 32';
			arev = 180;
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			//print("2\n");
			self.origin = e.origin + '-352 480 32';
			arev = 180;
		} else if (e.angles_y == 90) {
			//print("3\n");
			self.origin = e.origin + '480 352 32';
			arev = 180;
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 30;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y + arev;
		//print(ftos(self.angles_y),"\n");
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 33';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		self = cbw2;
		self.origin = e.origin + '0 0 550';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw3;
		self.origin = e.origin + '0 0 910';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		entity f1, f2;
		//Flag Stuff
		f1 = spawn();
		f2 = spawn();
		self = f1;
		multitool_spawnflag('472 472 992', e, oldself);
		self = f2;
		multitool_spawnflag('-472 -472 992', e, oldself);
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 544';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 768;	//Radius to search for it in.
		self.health = 1500;
		self.max_health = 3000;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = f1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate  = cp1;
	} else if (self.count == 6) {
		//Strong Tower
		entity f1, cp1;
		//Flag Stuff
		f1 = spawn();
		self = f1;
		multitool_spawnflag('0 0 596', e, oldself);
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 384';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 640;	//Radius to search for it in.
		self.health = 1200;
		self.max_health = 2400;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = f1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == 7) {
		//Small Castle
		entity l1, d1, cbw1, cbw2, cbw3, cbw4, cp1;
		l1 = spawn();
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-64 -64 0';
		self.maxs = '64 64 240';
		self.origin = e.origin + '0 0 448';
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		self = oldself;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		
		if (ourcastlecolor == 1 ||
		ourcastlecolor == 2 || ourcastlecolor == 5) {
			//Tan //White //LightTan
			self.model = "maps/buildables/door_up_small_metal1_rstcopper.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			self.model = "maps/buildables/door_up_small_metal1_whiterust.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			self.model = "maps/buildables/door_up_small_metal1_dullgrey.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			self.model = "maps/buildables/door_up_small_metal1_redrust.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			self.model = "maps/buildables/door_up_small_metal1_dark.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			self.model = "maps/buildables/door_up_small_metal1_dark.bsp";
		} else {
			self.model = "maps/buildables/door_up_small_metal1.bsp";
		}
		
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 600 32';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '600 0 32';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 -600 32';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '-600 0 32';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y;
		//print(ftos(self.angles_y),"\n");
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '760 760 260';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw2;
		self.origin = e.origin + '760 -760 260';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw3;
		self.origin = e.origin + '-760 760 260';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw4;
		self.origin = e.origin + '-760 -760 260';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		
		entity f1, f2, f3, f4;
		//Flag Stuff
		f1 = spawn();
		f2 = spawn();
		f3 = spawn();
		f4 = spawn();
		self = f1;
		multitool_spawnflag('560.000000 560.000000 888.000000', e, oldself);
		self = f2;
		multitool_spawnflag('-560.000000 -560.000000 888.000000', e, oldself);
		self = f3;
		multitool_spawnflag('560.000000 -560.000000 888.000000', e, oldself);
		self = f4;
		multitool_spawnflag('-560.000000 560.000000 888.000000', e, oldself);
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 448 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 2000;
		self.max_health = 4000;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = l1;
		e.subordinate.subordinate = d1;
		e.subordinate.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == 9) {
		//Townhall
		entity cbw1, cbw2, cbw3, cbw4, cbw5, cp1;
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		cbw5 = spawn();
		self = cbw1;
		self.origin = e.origin + '232 232 72';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw2;
		self.origin = e.origin + '232 -232 72';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw3;
		self.origin = e.origin + '-232 232 72';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw4;
		self.origin = e.origin + '-232 -232 72';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw5;
		self.origin = e.origin + '-220 -220 244';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 208';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 340;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 600;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
			cbw2.cntrlowner = cp1;
			cbw3.cntrlowner = cp1;
			cbw4.cntrlowner = cp1;
			cbw5.cntrlowner = cp1;
		}

		e.subordinate = cbw1;
		e.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == 11) {
		//Gmanse
		entity l1, d1, d2, cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cp1;
		l1 = spawn();
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-64 -64 0';
		self.maxs = '64 64 240';
		self.origin = e.origin + '0 0 448';
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		self = oldself;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 472 160';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '472 0 160';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 -472 160';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '-472 0 160';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y;
		//print(ftos(self.angles_y),"\n");
		
		//A door
		d2 = spawn();
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 -472 160';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '-472 0 160';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 472 160';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '472 0 160';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		if (self.angles_y > 180)
			self.angles_y = e.angles_y - 180;
		else
			self.angles_y = e.angles_y + 180;
		//print(ftos(self.angles_y),"\n");
		
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '192 192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw2;
		self.origin = e.origin + '192 -192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		self = cbw3;
		self.origin = e.origin + '-192 192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw4;
		self.origin = e.origin + '-192 -192 168';
		setorigin(self, self.origin);
		spawnfunc_item_armor_small();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '192 192 336';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 25;
		self.max_health = 750;
		spawnfunc_multitool_controlpoint();
		
		cbw5 = spawn();
		cbw6 = spawn();
		self = cbw5;
		self.origin = e.origin + '192 -192 368';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw6;
		self.origin = e.origin + '-192 192 368';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw5.cntrlowner = cp1;
			cbw6.cntrlowner = cp1;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = l1;
		e.subordinate.subordinate = d1;
		e.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == 12) {
		//arsenal
		entity d1, cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cbw7, cbw8, cbw9, cbw10, cbw11, cbw12, cp1;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 344 32';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '344 0 32';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 -344 32';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '-344 0 32';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 75';
		self.angles_y = e.angles_y;
		//print(ftos(self.angles_y),"\n");
		
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		cbw5 = spawn();
		cbw6 = spawn();
		cbw7 = spawn();
		cbw8 = spawn();
		cbw9 = spawn();
		cbw10 = spawn();
		cbw11 = spawn();
		cbw12 = spawn();
		
		self = cbw1;
		self.origin = e.origin + '-256.000000 -96.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw2;
		self.origin = e.origin + '-256.000000 96.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw3;
		self.origin = e.origin + '-96.000000 256.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw4;
		self.origin = e.origin + '96.000000 256.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw5;
		self.origin = e.origin + '256.000000 96.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw6;
		self.origin = e.origin + '256.000000 -96.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw7;
		self.origin = e.origin + '128.000000 -256.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw8;
		self.origin = e.origin + '-128.000000 -256.000000 176.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		
		self = cbw9;
		self.origin = e.origin + '-224.000000 0.000000 40.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		self = cbw10;
		self.origin = e.origin + '-160.000000 -160.000000 40.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		self = cbw11;
		self.origin = e.origin + '160.000000 -160.000000 40.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		self = cbw12;
		self.origin = e.origin + '224.000000 0.000000 40.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_rockets();
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 72 160';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 448;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw7;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw8;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw9;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw10;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw11;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw12;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == 13) {
		//Barracks
		entity cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cp1;
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		cbw5 = spawn();
		cbw6 = spawn();
		self = cbw1;
		self.origin = e.origin + '128 128 88';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw2;
		self.origin = e.origin + '-128 -128 88';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw3;
		self.origin = e.origin + '128 -128 88';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw4;
		self.origin = e.origin + '-128 128 88';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw5;
		self.origin = e.origin + '0 -224 200';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw6;
		self.origin = e.origin + '-224 0 200';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 168';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 576;	//Radius to search for it in.
		self.health = 200;
		self.max_health = 400;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
			cbw2.cntrlowner = cp1;
			cbw3.cntrlowner = cp1;
			cbw4.cntrlowner = cp1;
			cbw5.cntrlowner = cp1;
			cbw6.cntrlowner = cp1;
		}

		e.subordinate = cbw1;
		e.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	//C
	} else if (self.count == 14) {
		//church
		entity cbw1, cbw2, cp1;
		cbw1 = spawn();
		cbw2 = spawn();
		
		self = cbw1;
		self.origin = e.origin + '270 0 66';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		
		self = cbw2;
		self.origin = e.origin + '-270 0 66';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
			
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 64';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 576;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 400;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cbw1;
		e.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == 15) {
		//OldHangar
		
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else if(autocvar_g_balance_multitool_ancientonly) {
			//Do nothing
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build aircraft, Insufficent:", 1, 1, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cp1;
		entity cbw2, cbw3;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			self.vehicle_shieldtype = 9;
			spawnfunc_mountedgun_scorpion();
			
			cbw2 = spawn();
			self = cbw2;
			self.origin = e.origin + '130 130 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_shieldtype = 9;
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_scorpion();
			
			cbw3 = spawn();
			self = cbw3;
			self.origin = e.origin + '-128 -128 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_shieldtype = 9;
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_scorpion();
		} else {
			if not(autocvar_g_balance_multitoolutilitool_noaircraft) {
		 	 if not(autocvar_g_balance_multitool_noaircraft) {
			  if (sufficentforgeparts) {
				frandvar = random();
				if (frandvar > 0.8) {
					spawnfunc_vehicle_fokker();
				} else if (frandvar > 0.6) {
					self.colormap = (1024 + 7 + 7 * 16); //Green
					spawnfunc_vehicle_eindecker();
				} else if (frandvar > 0.4) {
					spawnfunc_vehicle_sopwith();
				} else if (frandvar > 0.2) {
					spawnfunc_vehicle_nieuport();
				} else {
					spawnfunc_vehicle_farman();
				}
			  }
			 }
			}
		}
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '448 448 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 576;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		if(autocvar_g_balance_multitool_ancientonly) {
			e.subordinate2a = cbw2;
			e.subordinate3 = cbw3;
		}
	} else if (self.count == 16) {
		//Old Tank Hangar -- 2 tanks
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else if(autocvar_g_balance_multitool_ancientonly) {
			//Do nothing
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build tanks, Insufficent:", 6, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cbw2, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '224 224 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		
		self.vehicle_droptype = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_mountedgun_charbelcher();
		} else {
			if not(autocvar_g_balance_multitoolutilitool_notanks) {
		 	 if not(autocvar_g_balance_multitool_notanks) {
				frandvar = random();
				if (frandvar > 0.85) {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tanka7v();
					}
				} else if (frandvar > 0.45) {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tankt27();
					}
				} else {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tankiv();
					}
				}
			 }
			}
		}
		cbw2 = spawn();
		self = cbw2;
		self.origin = e.origin + '-224 -224 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		
		self.vehicle_droptype = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_mountedgun_charbelcher();
		} else {
			if not(autocvar_g_balance_multitoolutilitool_notanks) {
		 	 if not(autocvar_g_balance_multitool_notanks) {
				frandvar = random();
				if (frandvar > 0.85) {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tanka7v();
					}
				} else if (frandvar > 0.45) {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tankt27();
					}
				} else {
					if (sufficentforgeparts) {
						spawnfunc_vehicle_tankiv();
					}
				}
			 }
			}
		}
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '448 448 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 576;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		e.subordinate3 = cbw2;
	} else if (self.count == 17) {
		//Chataeu
		entity l1, d1, d2, cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cp1;
		l1 = spawn();
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-64 -64 0';
		self.maxs = '64 64 240';
		self.origin = e.origin + '0 0 448';
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		self = oldself;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 640 160';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '640 0 160';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 -640 160';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '-640 0 160';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y;
		//print(ftos(self.angles_y),"\n");
		
		//A door
		d2 = spawn();
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		if (e.angles_y == 0) {
			self.origin = e.origin + '0 -640 160';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '-640 0 160';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '0 640 160';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '640 0 160';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		if (self.angles_y > 180)
			self.angles_y = e.angles_y - 180;
		else
			self.angles_y = e.angles_y + 180;
		//print(ftos(self.angles_y),"\n");
		
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '192 192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw2;
		self.origin = e.origin + '192 -192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		self = cbw3;
		self.origin = e.origin + '-192 192 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw4;
		self.origin = e.origin + '-192 -192 168';
		setorigin(self, self.origin);
		spawnfunc_item_armor_small();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 336';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1280;	//Radius to search for it in.
		self.health = 25;
		self.max_health = 750;
		spawnfunc_multitool_controlpoint();
		
		cbw5 = spawn();
		cbw6 = spawn();
		self = cbw5;
		self.origin = e.origin + '512 -512 368';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw6;
		self.origin = e.origin + '-512 512 368';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw5.cntrlowner = cp1;
			cbw6.cntrlowner = cp1;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = l1;
		e.subordinate.subordinate = d1;
		e.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 18) {
		//PalladianManor
		entity l1, d1, d2, cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cp1;
		l1 = spawn();
		
		//An armor
		self = l1;
		self.origin = e.origin + '-256 256 496';
		setorigin(self, self.origin);
		spawnfunc_item_armor_small();
		self = oldself;
		
		//A door
		d1 = spawn();
		d2 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
			vector ol;
			vector il;
			if (e.angles_y == 0) {
				//print("0 netradiant\n");
				//0
				ol = '0 392 160';
				il = '-256 -520 160';
			} else if (e.angles_y == -90) {
				//print("90 netradiant\n");
				//90
				ol = '392 0 160';
				il = '-520 256 160';
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				//print("180 netradiant\n");
				//180
				ol = '0 -392 160';
				il = '256 520 160';
			} else if (e.angles_y == 90) {
				//print("270 netradiant\n");
				//270
				ol = '-392 0 160';
				il = '520 -256 160';
			}
		self.origin = e.origin + ol;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y;
		//print(ftos(self.angles_y),"\n");
		
		//A door
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_small_metal1.bsp";
		//Origin set above
		self.origin = e.origin + il;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		if (self.angles_y > 180)
			self.angles_y = e.angles_y - 180;
		else
			self.angles_y = e.angles_y + 180;
		//print(ftos(self.angles_y),"\n");
		
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '608 608 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw2;
		self.origin = e.origin + '608 -608 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		self = cbw3;
		self.origin = e.origin + '-608 608 168';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		self = cbw4;
		self.origin = e.origin + '-608 -608 168';
		setorigin(self, self.origin);
		spawnfunc_item_armor_small();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 480';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1280;	//Radius to search for it in.
		self.health = 25;
		self.max_health = 750;
		spawnfunc_multitool_controlpoint();
		
		cbw5 = spawn();
		cbw6 = spawn();
		self = cbw5;
		self.origin = e.origin + '512 -512 248';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		self = cbw6;
		self.origin = e.origin + '-512 512 248';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw5.cntrlowner = cp1;
			cbw6.cntrlowner = cp1;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = l1;
		e.subordinate.subordinate = d1;
		e.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 19) {
		//House (stone)
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '-32 -32 62';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '32 32 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
			
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
		}
		
		e.subordinate = cbw1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == 20) {
		//Treetop Sentry (treehouse)
		entity l1, cp1, cbw1, cbw2;
		entity cbw3, cbw4;
		entity cbw5, cbw6;
		entity cbw7, cbw8;
		l1 = spawn();
		self = l1;
		
			//A ladder
			vector ol;
			if (e.angles_y == 0) {
				//print("0 netradiant\n");
				//0
				ol = '-96 -96 32';
			} else if (e.angles_y == -90) {
				//print("90 netradiant\n");
				//90
				ol = '-96 96 32';
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				//print("180 netradiant\n");
				//180
				ol = '96 96 32';
			} else if (e.angles_y == 90) {
				//print("270 netradiant\n");
				//270
				ol = '96 -96 32';
			}
			
			l1 = spawn();
			l1.solid  = SOLID_TRIGGER;
			l1.mins = '-16 -16 -10';
			l1.maxs = '16 16 0';
			
			//Outside ladder
			self = l1;
			self.origin = e.origin + ol;
			
			//Tracer
			local entity ldrtracer;
			ldrtracer = spawn();
			ldrtracer.origin = self.origin;
			traceline(ldrtracer.origin + '0 0 2', ldrtracer.origin - '0 0 10000', MOVE_WORLDONLY, ldrtracer);
			l1.mins_z = self.origin_z - trace_endpos_z;
			l1.mins_z = l1.mins_z * -1; //Got to invert as it's going down, not up, and is relative;
			//End tracer
			remove(ldrtracer);
			
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '32 32 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		//////This adds Scorpion 1 of mannable nature
		  cbw2 = spawn(); //Think to keep origin correct
		  cbw1 = spawn(); //Scorpion
		  self = cbw1;
		  self.team = oldself.owner.team;
		
		  if(autocvar_g_balance_multitool_ancientonly)
		  	self.origin = e.origin + '0 176 32';
		  else
		  	self.origin = e.origin + '0 208 32';
		
		  cbw2.origin = self.origin;
		  setorigin(self, self.origin);
		  self.angles_y = 90;
		
		  self.spawnflags = 32;
		  if(autocvar_g_balance_multitool_ancientonly) {
		  	spawnfunc_mountedgun_scorpion();
		  } else {
		  	spawnfunc_mountedgun_lewis();
		  }
		
		  //This enforces origin
		  self = cbw2;
		  self.think = multitool_mountedgun_think;
		  self.nextthink = time;
		  setorigin(self, self.origin);
		  self.subordinate5 = cbw1;
		//////End Scorpion 1
		
		//////This adds Scorpion 2 of mannable nature
		  cbw4 = spawn(); //Think to keep origin correct
		  cbw3 = spawn(); //Scorpion
		  self = cbw3;
		  self.team = oldself.owner.team;
		
		  if(autocvar_g_balance_multitool_ancientonly)
		  	self.origin = e.origin + '0 -176 32';
		  else
		  	self.origin = e.origin + '0 -208 32';
		
		  cbw4.origin = self.origin;
		  setorigin(self, self.origin);
		  self.angles_y = -90;
		
		  self.spawnflags = 32;
		  if(autocvar_g_balance_multitool_ancientonly) {
		  	spawnfunc_mountedgun_scorpion();
		  } else {
		  	spawnfunc_mountedgun_lewis();
		  }
		
		  //This enforces origin
		  self = cbw4;
		  self.think = multitool_mountedgun_think;
		  self.nextthink = time;
		  setorigin(self, self.origin);
		  self.subordinate5 = cbw3;
		//////End Scorpion 2
		
		//////////////////////////////////
		//////This adds Scorpion 3 of mannable nature
		  cbw6 = spawn(); //Think to keep origin correct
		  cbw5 = spawn(); //Scorpion
		  self = cbw5;
		  self.team = oldself.owner.team;
		
		  if(autocvar_g_balance_multitool_ancientonly)
		  	self.origin = e.origin + '176 0 32';
		  else
		  	self.origin = e.origin + '208 0 32';
		
		  cbw6.origin = self.origin;
		  setorigin(self, self.origin);
		  self.angles_y = 0;
		
		  self.spawnflags = 32;
		  if(autocvar_g_balance_multitool_ancientonly) {
		  	spawnfunc_mountedgun_scorpion();
		  } else {
		  	spawnfunc_mountedgun_lewis();
		  }
		
		  //This enforces origin
		  self = cbw6;
		  self.think = multitool_mountedgun_think;
		  self.nextthink = time;
		  setorigin(self, self.origin);
		  self.subordinate5 = cbw5;
		//////End Scorpion 3
		
		//////This adds Scorpion 4 of mannable nature
		  cbw8 = spawn(); //Think to keep origin correct
		  cbw7 = spawn(); //Scorpion
		  self = cbw7;
		  self.team = oldself.owner.team;
		
		  if(autocvar_g_balance_multitool_ancientonly)
		  	self.origin = e.origin + '-176 0 32';
		  else
		  	self.origin = e.origin + '-208 0 32';
		
		  cbw8.origin = self.origin;
		  setorigin(self, self.origin);
		  self.angles_y = 180;
		
		  self.spawnflags = 32;
		  if(autocvar_g_balance_multitool_ancientonly) {
		  	spawnfunc_mountedgun_scorpion();
		  } else {
		  	spawnfunc_mountedgun_lewis();
		  }
		
		  //This enforces origin
		  self = cbw8;
		  self.think = multitool_mountedgun_think;
		  self.nextthink = time;
		  setorigin(self, self.origin);
		  self.subordinate5 = cbw7;
		//////End Scorpion 4
					
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		e.subordinate = l1;
		e.subordinate2 = cbw1;
		e.subordinate2a = cbw3;
		e.subordinate3 = cbw5;
		e.subordinate3a = cbw7;
		e.subordinate.subordinate = cp1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw8;
		if (e.requiresexist && e.requiresexist != world) {
			e.requiresexist.dstrybldondeath = e;
		}
	} else if (self.count == 21) {
		//SiegeWorkshop
		float frandvar;
		float usesiegecannon;
		entity cbw1, cp1;
		entity cbw2, cbw3, cbw4, cbw5;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		if(autocvar_g_balance_multitool_ancientonly) {
			spawnfunc_mountedgun_batteringram();
		} else {
		  usesiegecannon = 0;
		  if (random() < autocvar_g_balance_multitool_siegemortarrate) {
		  	usesiegecannon = 1;
		  }
		  
		  if (usesiegecannon)
		  {
			spawnfunc_mountedgun_siegemortar();
		  } else {
			//Some have shields, some don't
			self.vehicle_shieldtype = 3;
			spawnfunc_mountedgun_maxim();
		
			cbw2 = spawn();
			self = cbw2;
			self.origin = e.origin + '130 130 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			frandvar = random();
			self.vehicle_droptype = 1;
			
			if (frandvar > 0.85) {
				self.vehicle_shieldtype = 3;
				spawnfunc_mountedgun_spadu();
			} else if (frandvar > 0.6) {
				self.vehicle_shieldtype = 6;
				spawnfunc_mountedgun_lewis();
			} else if (frandvar > 0.4) {
				self.vehicle_shieldtype = 6;
				spawnfunc_mountedgun_hotchkissm1914();
			} else {
				self.vehicle_shieldtype = 3;
				spawnfunc_mountedgun_maxim();
			}
			
			cbw3 = spawn();
			self = cbw3;
			self.origin = e.origin + '-128 -128 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			frandvar = random();
			self.vehicle_droptype = 1;
			
			if (frandvar > 0.85) {
				spawnfunc_mountedgun_spadu();
			} else if (frandvar > 0.6) {
				spawnfunc_mountedgun_lewis();
			} else if (frandvar > 0.4) {
				spawnfunc_mountedgun_hotchkissm1914();
			} else {
				spawnfunc_mountedgun_maxim();
			}
			
			cbw4 = spawn();
			self = cbw4;
			self.origin = e.origin + '-120 120 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_maxim();
			
			cbw5 = spawn();
			self = cbw5;
			self.origin = e.origin + '140 -140 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			frandvar = random();
			self.vehicle_droptype = 1;
			
			if (frandvar > 0.85) {
				self.vehicle_shieldtype = 3;
				spawnfunc_mountedgun_spadu();
			} else if (frandvar > 0.6) {
				self.vehicle_shieldtype = 6;
				spawnfunc_mountedgun_lewis();
			} else if (frandvar > 0.4) {
				self.vehicle_shieldtype = 6;
				spawnfunc_mountedgun_hotchkissm1914();
			} else {
				self.vehicle_shieldtype = 3;
				spawnfunc_mountedgun_maxim();
			}
		  }
		}
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '320 320 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 576;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		
		if(!autocvar_g_balance_multitool_ancientonly) {
			if (!usesiegecannon) {
				e.subordinate2a = cbw2;
				e.subordinate3 = cbw3;
				e.subordinate3a = cbw4;
				e.subordinate3b = cbw5;
			}
		}
	} else if (self.count == 22) {
		//gaol
		entity l1, d1, d2, cbw1, cbw2, pr2b, pr1, pr2, tp2, cp1;
		entity pr3tor, tp3tor;
		vector pr1origin;
		vector pr2borigin;
		entity tp4;
		
		pr1 = spawn();
		pr2 = spawn();
		pr2b = spawn();
		tp2 = spawn();
		pr3tor = spawn();
		tp3tor = spawn();
		tp2.origin = e.origin + '0 0 46';
		tp3tor.origin = e.origin + '0 0 400';
		tp4 = spawn();
		
		l1 = spawn();
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-64 -64 0';
		self.maxs = '64 64 360';
		self.origin = e.origin + '0 0 576';
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y + 90;
		self.model = "maps/buildables/door_up_med_metal2.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-752 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 752 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '752 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -752 8';
		}
		pr1origin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 74';
		self.angles_y = e.angles_y + 90;
		//print(ftos(self.angles_y),"\n");
		
		self = pr1;
		self.spawnflags = 0;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr1origin;
		setorigin(self, self.origin);
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = pr2;
		self.spawnflags = 2;
		self.mins = '-144 -144 0';
		self.maxs = '144 144 120';
		self.origin = e.origin + '0 0 8';
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		
		//Torture post
		self = pr3tor;
		self.spawnflags = 3;
		self.mins = '-144 -144 0';
		self.maxs = '144 144 232';
		self.origin = e.origin + '0 0 296';
		setorigin(self, self.origin);
		self.enemy = tp3tor;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();

		
		//A thing for ironmaiden, reserving a room
		self = tp4;
		self.spawnflags = 2; //So we don't get confused with a freeing-prison block
		SMI_SetOriginVsBldAngles(tp4, '-448 -512 144', e);
		setsize(self, '-240 -240 0', '240 240 144');
		self.solid = SOLID_NOT;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		
		
		d2 = spawn();
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y - 90;
		self.model = "maps/buildables/door_up_med_metal2.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-304 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 304 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '304 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -304 8';
		}
		pr2borigin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 74';
		self.angles_y = e.angles_y - 90;
		
		self = pr2b;
		self.spawnflags = 2;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr2borigin;
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = oldself;
		
		
		
		cbw1 = spawn();
		cbw2 = spawn();
		
		self = cbw1;
		self.origin = e.origin + '-128.000000 -128.000000 768.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		
		self = cbw2;
		self.origin = e.origin + '-128.000000 128.000000 768.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			if (random() < 0.75) { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_lightcrossbow(); } else { spawnfunc_weapon_m1903(); } } else { if (autocvar_g_balance_multitool_ancientonly) { spawnfunc_weapon_crossbowdtwr(); } else { spawnfunc_weapon_g98(); }  }
		}
		
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '96 96 576';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = pr2b;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr3tor;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp3tor;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp4;

		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 23) {
		//small jail
		entity d1, d2, pr2b, pr1, pr2, tp2, cp1;
		vector pr1origin;
		vector pr2borigin;
		
		pr1 = spawn();
		pr2 = spawn();
		pr2b = spawn();
		tp2 = spawn();
		tp2.origin = e.origin + '0 0 46';
		
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y + 90;
		self.model = "maps/buildables/door_up_med_metal2.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-432 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 432 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '432 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -432 8';
		}
		pr1origin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 74';
		self.angles_y = e.angles_y + 90;
		//print(ftos(self.angles_y),"\n");
		
		self = pr1;
		self.spawnflags = 0;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr1origin;
		setorigin(self, self.origin);
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = pr2;
		self.spawnflags = 2;
		self.mins = '-144 -144 0';
		self.maxs = '144 144 120';
		self.origin = e.origin + '0 0 8';
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();

		
		d2 = spawn();
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y - 90;
		self.model = "maps/buildables/door_up_med_metal2.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-304 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 304 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '304 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -304 8';
		}
		pr2borigin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 74';
		self.angles_y = e.angles_y - 90;
		
		self = pr2b;
		self.spawnflags = 2;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr2borigin;
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = oldself;
		
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '352 352 208';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
				
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = pr2b;
		
		e.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate = pr1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = pr2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;

		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 24 || self.count == 25 || self.count == 26
		|| self.count == 1036) {
		//Forge Building
		entity cp1, cbw1, cbw2, shield, brcntl;
		
		cbw2 = spawn();
		self = cbw2;
		
		if (e.count == 24) {
			self.classname = "lclforgen";
		} else if (e.count == 25) {
			self.classname = "lclforger";
		} else if (e.count == 26) {
			self.classname = "lclforgec";
		} else if (e.count == 1036) {
			self.classname = "lclforgehmmr";
		}  
		
		self.islocalresourceprovider = 1; //So we can be searched for;
		self.resource_forgeparts_nails_local = 0; // Start empty Ofcourse // 1000; //Test
		self.resource_forgeparts_rockets_local = 0;
		self.resource_forgeparts_cells_local = 0;
		self.origin = e.origin;
		setorigin(self, self.origin);
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		if (e.count == 24) {
			self.origin = e.origin + '96 96 0';
		} else if (e.count == 25) {
			self.origin = e.origin + '64 64 32';
		} else if (e.count == 26) {
			self.origin = e.origin + '128 128 16';
		} else if (e.count == 1036) {
			self.origin = e.origin + '128 128 64';
		} else {
			self.origin = e.origin + '32 32 0';
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		cbw2.subordinate4 = cp1; //So we can figure out our team or owner easily
		
		//This adds to forgeparts each min
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin;
		
		if (e.count == 24) {
			self.think = multitool_forgebuilding_nails_think;
		} else if (e.count == 25) {
			self.think = multitool_forgebuilding_rockets_think;
		} else if (e.count == 26) {
			self.think = multitool_forgebuilding_cells_think;
		} else if (e.count == 1036) {
			self.think = multitool_forgebuilding_hammerforge_think;
		} else {
			//Fallback
			self.think = multitool_forgebuilding_nails_think;
		}
		
		self.ammount = 0; //Default global distrib
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		self.subordinate5 = e; //So we can find origin to search for local energy
		self.subordinate9 = cbw2; //So we know where to add resources
		//
		
		
		//Visual indication of local distribution (default off ofcourse)
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		
		if (e.count == 24) {
			shield.model = "maps/buildables/building_forge1_lock.bsp";
		} else if (e.count == 25) {
			shield.model = "maps/buildables/building_forge2_lock.bsp";
		} else if (e.count == 26) {
			shield.model = "maps/buildables/building_forge3_lock.bsp";
		} else if (e.count == 1036) {
			shield.model = "maps/buildables/building_hammerforge_lock.bsp";
		}
		
		shield.solid = SOLID_BSP; //
		//shield.origin = cp1.origin;
		shield.origin = e.origin;
		shield.angles = e.angles;
		shield.mins = '-128 -128 -128';
		shield.maxs = '128 128 128';
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	self.alpha = -1; //Making sure
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        	self.solid = SOLID_NOT; //Off by default
        	self.movetype = MOVETYPE_NONE;
		self.alpha = -1; //Default is global distibution so we will be unseen
		
		
		
		brcntl = spawn();
		brcntl.origin = cp1.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_forgebuildingcontrol();
		self.ammount = 0;
		
		self = oldself;
		
		//brcntl.subordinate5 = e; //Model
		brcntl.subordinate7 = shield; //oilpumpcontrol needs to know the locallock indicating model
		brcntl.subordinate4 = cbw1; //so we can control state
		//
		
		
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = shield;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = brcntl;
		
		if (numberoflocalforgebuildings < 0) {
			numberoflocalforgebuildings = 1; //Just in case less than 0 for some reason
		} else {
			numberoflocalforgebuildings = numberoflocalforgebuildings + 1;
		}
	
	} else if (self.count == 1037) {
		//Observation tower
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '112 112 672';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
	
	} else if (self.count == 27) {
		//CrusaderStronghold
		entity d1, cbw1, cbw2, cbw3, cp1;
		float arev;
		
		entity bnners1;
		entity bnners2;
		entity frepots1;
		entity hngchn1;
		entity jldr1;
		entity pr1;
		entity pr2, tp2;
		entity pr3tor, tp3tor;
		
		//A door
		jldr1 = spawn();
		pr1 = spawn();
		pr2 = spawn();
		tp2 = spawn();
		pr3tor = spawn();
		tp3tor = spawn();
		
	
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		self.model = "maps/buildables/door_up_med2_x_metal1.bsp";
		if (e.angles_y == 0) {
			//print("0\n");
			//Stronghold was: 352 -480 32
			//CrusaderSHD is: 224 -832 256
			//self.origin = e.origin + '352 -480 32';
			self.origin = e.origin + '224 -832 256';
			arev = 180;
			jldr1.origin = e.origin + '0 608 64'; //Jail door
			pr1.origin = e.origin + '224 -640 256'; //Jail escape
			pr2.origin = e.origin + '128 608 64'; //Jail
			pr3tor.origin = e.origin + '-256 256 64';
			//
			// +X +Y (Z) [Original]
			//   TO
			// +X +Y (Z) [Same]
		} else if (e.angles_y == -90) {
			//print("1\n");
			//self.origin = e.origin + '-480 -352 32';
			self.origin = e.origin + '-832 -224 256';
			arev = 180;
			jldr1.origin = e.origin + '608 0 64';
			pr1.origin = e.origin + '-640 -224 256';
			pr2.origin = e.origin + '608 -128 64';
			pr3tor.origin = e.origin + '256 256 64';
			//
			// +X +Y (Z) [Original]
			//   TO
			// +Y -X (Z)
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			//print("2\n");
			//self.origin = e.origin + '-352 480 32';
			self.origin = e.origin + '-224 832 256';
			arev = 180;
			jldr1.origin = e.origin + '0 -608 64';
			pr1.origin = e.origin + '-224 640 256';
			pr2.origin = e.origin + '-128 -608 64';
			pr3tor.origin = e.origin + '256 -256 64';
			//
			// +X +Y (Z) [Original]
			//   TO
			// -X -Y (Z)
		} else if (e.angles_y == 90) {
			//print("3\n");
			//self.origin = e.origin + '480 352 32';
			self.origin = e.origin + '832 224 256';
			arev = 180;
			jldr1.origin = e.origin + '-608 0 64';
			pr1.origin = e.origin + '640 224 256';
			pr2.origin = e.origin + '-608 128  64';			
			pr3tor.origin = e.origin + '-256 -256 64';
			//
			// +X +Y (Z) [Original]
			//   TO
			// -Y +X (Z)
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 30;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 90';
		self.angles_y = e.angles_y + arev;
		//print(ftos(self.angles_y),"\n");
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		self = cbw1;
		self.origin = e.origin + '192 192 68';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		self = cbw2;
		self.origin = e.origin + '256 256 578';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw3;
		self.origin = e.origin + '-192 -192 68';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		entity f1, f2;
		//Flag Stuff
		f1 = spawn();
		f2 = spawn();
		self = f1;
		////multitool_spawnflag('472 472 992', e, oldself);
		////multitool_spawnflag('600 600 1200', e, oldself);
		if (e.angles_y == 0 || e.angles_y == -180 || e.angles_y == 180) {
			multitool_spawnflag('600 856 1200', e, oldself);
		} else {
			multitool_spawnflag('856 600 1200', e, oldself);
		}
		self = f2;
		////multitool_spawnflag('-600 -600 1200', e, oldself);
		if (e.angles_y == 0 || e.angles_y == -180 || e.angles_y == 180) {
			multitool_spawnflag('-600 -856 1200', e, oldself);
		} else {
			multitool_spawnflag('-856 -600 1200', e, oldself);
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 580';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1248;	//Radius to search for it in.
		self.health = 1500;
		self.max_health = 3000;
		spawnfunc_multitool_controlpoint();
		
		
		//
		bnners1 = spawn();
		bnners2 = spawn();
		frepots1 = spawn();
		hngchn1 = spawn();

		bnners1.origin = bnners2.origin = frepots1.origin = hngchn1.origin = e.origin;
		bnners1.angles = bnners2.angles = frepots1.angles = hngchn1.angles = e.angles;
			
			hngchn1.model = "maps/buildables/building_crusaderstronghold_duengonchain.bsp";
			frepots1.model = "maps/buildables/building_crusaderstronghold_firepots.bsp";
			
			
			
			
	
			//bnners1.model = "maps/buildables/building_crusaderstronghold_banners_red.bsp";
			//bnners2.model = "maps/buildables/building_crusaderstronghold_altbanners_white.bsp";
			
			multitool_setcrusaderstrongholdbannermodels(bnners1, bnners2, oldself.owner, 1, 0);

			
			self = bnners1;
			setorigin(self, self.origin);
			//gamemodel is good for this as this needs to change sometimes
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        		//self.solid = SOLID_BSP;
        		//self.movetype = MOVETYPE_PUSH;
        		self.solid = SOLID_NOT;
        		self.movetype = MOVETYPE_NONE;
			
			self = bnners2;
			setorigin(self, self.origin);
			//gamemodel is good for this as this needs to change sometimes
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        		//self.solid = SOLID_BSP;
        		//self.movetype = MOVETYPE_PUSH;
        		self.solid = SOLID_NOT;
        		self.movetype = MOVETYPE_NONE;
			
			self = frepots1;
			setorigin(self, self.origin);
        		//if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			//Client model is good for this, doesn't need to change, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        		self.solid = SOLID_BSP;
        		self.movetype = MOVETYPE_PUSH;
			//self.solid = SOLID_NOT;
        		//self.movetype = MOVETYPE_NONE;
			
			self = hngchn1;
			setorigin(self, self.origin);
        		//if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			//Client model is good for this, doesn't need to change, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        		//self.solid = SOLID_BSP;
        		//self.movetype = MOVETYPE_PUSH;
			self.solid = SOLID_NOT;
        		self.movetype = MOVETYPE_NONE;
		
			
		////////////////////////
		//A second door
		self = jldr1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y;
		
		if (ourcastlecolor == 1 ||
		ourcastlecolor == 2 || ourcastlecolor == 5) {
			//Tan //White //LightTan
			self.model = "maps/buildables/door_up_small_metal1_rstcopper.bsp";
		} else if (ourcastlecolor == 3) {
			//Green
			self.model = "maps/buildables/door_up_small_metal1_whiterust.bsp";
		} else if (ourcastlecolor == 4) {
			//Brown
			self.model = "maps/buildables/door_up_small_metal1_dullgrey.bsp";
		} else if (ourcastlecolor == 6) {
			//Black
			self.model = "maps/buildables/door_up_small_metal1_redrust.bsp";
		} else if (ourcastlecolor == 7) {
			//Mauve
			self.model = "maps/buildables/door_up_small_metal1_dark.bsp";
		} else if (ourcastlecolor == 8) {
			//Pink
			self.model = "maps/buildables/door_up_small_metal1_dark.bsp";
		} else {
			self.model = "maps/buildables/door_up_small_metal1.bsp";
		}
		
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 20;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 + '0 0 72';
		self.angles_y = e.angles_y - 90; //Door lock facing in, jail door
		//print(ftos(self.angles_y),"\n");
		//FINISHED A second door	
		////////////////////////
		
		self = pr1;
		self.spawnflags = 0;
		self.mins = '-96 -96 -16';
		self.maxs = '96 96 224';
		setorigin(self, self.origin);
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		
		
		tp2.origin = pr2.origin;
		tp2.origin_z = tp2.origin_z + 64;
		self = tp2;
		setorigin(self, self.origin);
		
		self = pr2;
		self.spawnflags = 2;
		self.mins = '-128 -128 -16';
		self.maxs = '128 128 416';
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		
		
		
		tp3tor.origin = pr3tor.origin;
		tp3tor.origin_z = tp3tor.origin_z + 84;
		tp3tor.angles = '0 0 -180'; //Upsidedown
		tp3tor.angles_y = e.angles_y;
		self = tp3tor;
		setorigin(self, self.origin);
		
		//Torture chain
		self = pr3tor;
		self.spawnflags = 3;
		self.mins = '-32 -32 -16';
		self.maxs = '32 32 480';
		setorigin(self, self.origin);
		self.enemy = tp3tor;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		
		self = oldself;
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		jldr1.teamlockallow = 1;
		jldr1.teamlockent = cp1;
		
		
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = f1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = f2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate  = cp1;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = bnners1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = bnners2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = frepots1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = hngchn1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = jldr1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr3tor;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp3tor;
	//
	
	} else if (self.count == 110 || self.count == 111 || self.count == 112
		|| self.count == 1110 || self.count == 1111 || self.count == 1112
		|| self.count == 1113 || self.count == 1114 || self.count == 1115
		|| self.count == 1116 || self.count == 1117 || self.count == 1118
		) {
		
		float sufficentforgeparts;
		//sufficentforgeparts = 0;
		sufficentforgeparts = 1;
		
		//if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forenterableturrets) {
		//	sufficentforgeparts = 1;
		//} else {
		//	if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turret, Insufficent:", 1, 0, 0))
		//	{
		//		sufficentforgeparts = 1;
		//	}
		//}
		
		
		//Mannable Turret 
		entity cp1, cbw1, cbw2;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '0 0 0';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		//This adds Turrets of mannable nature
		cbw2 = spawn();
		cbw1 = spawn();
		self = cbw1;
		self.team = oldself.owner.team;
		
		self.origin = e.origin; // + '0 0 32';
		
		cbw2.origin = self.origin;
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.spawnflags = 32;
		
		if (sufficentforgeparts) {
			if (e.count == 1110) {
				spawnfunc_mountedgun_shlac();
			} else if (e.count == 1111) {
				spawnfunc_mountedgun_autonex();
			} else if (e.count == 1112) {
				spawnfunc_mountedgun_grail();
			} else if (e.count == 1113) {
				spawnfunc_mountedgun_bpcannon();
			} else if (e.count == 1114) {
				spawnfunc_mountedgun_browning50();
			} else if (e.count == 1115) {
				spawnfunc_mountedgun_m134();
			} else if (e.count == 1116) {
				spawnfunc_mountedgun_gau19();
			} else if (e.count == 1117) {
				spawnfunc_mountedgun_t17mm();
			} else if (e.count == 1118) {
				spawnfunc_mountedgun_lasercannon_red();
			} else if(autocvar_g_balance_multitool_ancientonly) {
		  		spawnfunc_mountedgun_scorpion();
		  	} else {
				if (e.count == 110) {
					spawnfunc_mountedgun_hotchkissm1914();
				} else if (e.count == 111) {
					spawnfunc_mountedgun_lewis();
				} else if (e.count == 112) {
					spawnfunc_mountedgun_maxim();
				}
			}
		
			if (teamplay) {
				self.tur_head.colormap = self.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				self.tur_head.colormap = self.colormap = oldself.owner.colormap;
			}
		
			//This enforces colormap
			self = cbw2;
			self.think = multitool_mannableturret_think;
			self.nextthink = time;
			setorigin(self, self.origin);
			self.subordinate4 = cp1; //So we can figure out our current team
			self.subordinate5 = cbw1;
		}

		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		e.subordinate.subordinate = cbw2;
	
	} else if (self.count == 501 || self.count == 1501) {
		//Field
		entity cp1, cbw1;
		entity extragrowth1, extragrowth2, extragrowth3, extragrowth4;
		entity extragrowth5, extragrowth6, extragrowth7, extragrowth8;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1;	//Radius to search for it in.
		if (oldself.count == 1501) {
			self.health = 10;
			self.max_health = 45;
		} else {
			self.health = 5;
			self.max_health = 25;
		}
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		//This adds to energy tanks each min
		cbw1 = spawn();
		self = cbw1;
		if (specialconsiderations || oldself.count == 1501) {
			self.think = multitool_field_greens_think;
		} else {
			self.think = multitool_field_grain_think;
		}
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		
		//print(vtos(self.origin),"self.origin\n");
		//Kelp might grow muchly
		//Begin extra stuff
		float pc;
		vector pv;
		pv = e.origin;
		pv_z = pv_z + 384 + 128; //Center and then some
		pc = pointcontents(pv);
		if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
			
			extragrowth1 = spawn();
			extragrowth1.classname = "building";
			//not setting accptcrrdbldspltr
			extragrowth1.model = "maps/buildables/building_kelp.bsp";
			extragrowth1.solid = SOLID_BSP;
			extragrowth1.origin = e.origin;
			extragrowth1.origin_z = e.origin_z + 384;
			extragrowth1.angles = e.angles;
			extragrowth1.angles_y = e.angles_y + 45;
	
			self = extragrowth1;
			setorigin(self, self.origin);
			//gamemodel is fine for this, it doesn't interact;
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        		self.solid = SOLID_BSP;
        		self.movetype = MOVETYPE_PUSH;
			
			e.subordinate.subordinate.subordinate = extragrowth1;
		
		 	pv = e.origin;
		 	pv_z = extragrowth1.origin_z + 384 + 128; //Center and then some
		 	pc = pointcontents(pv);
		 	if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
				extragrowth2 = spawn();
				extragrowth2.classname = "building";
				extragrowth2.model = "maps/buildables/building_kelp.bsp";
				extragrowth2.solid = SOLID_BSP;
				extragrowth2.origin = extragrowth1.origin;
				extragrowth2.origin_z = extragrowth1.origin_z + 384;
				extragrowth2.angles = e.angles;
				extragrowth2.angles_y = e.angles_y;
		
				self = extragrowth2;
				setorigin(self, self.origin);
				//gamemodel is fine for this, it doesn't interact;
        			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        			self.solid = SOLID_BSP;
        			self.movetype = MOVETYPE_PUSH;
				
				e.subordinate.subordinate.subordinate.subordinate = extragrowth2;
		
				  pv = e.origin;
				  pv_z = extragrowth2.origin_z + 384 + 128; //Center and then some
				  pc = pointcontents(pv);
				  if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
					extragrowth3 = spawn();
					extragrowth3.classname = "building";
					extragrowth3.model = "maps/buildables/building_kelp.bsp";
					extragrowth3.solid = SOLID_BSP;
					extragrowth3.origin = extragrowth2.origin;
					extragrowth3.origin_z = extragrowth2.origin_z + 384;
					extragrowth3.angles = e.angles;
					extragrowth3.angles_y = e.angles_y + 45;
	
					self = extragrowth3;
					setorigin(self, self.origin);
					//gamemodel is fine for this, it doesn't interact;
        				if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        				self.solid = SOLID_BSP;
        				self.movetype = MOVETYPE_PUSH;
					
					e.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth3;
		
					  pv = e.origin;
					  pv_z = extragrowth3.origin_z + 384 + 128; //Center and then some
					  pc = pointcontents(pv);
					  if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
						extragrowth4 = spawn();
						extragrowth4.classname = "building";
						extragrowth4.model = "maps/buildables/building_kelp.bsp";
						extragrowth4.solid = SOLID_BSP;
						extragrowth4.origin = extragrowth3.origin;
						extragrowth4.origin_z = extragrowth3.origin_z + 384;
						extragrowth4.angles = e.angles;
						extragrowth4.angles_y = e.angles_y;
	
						self = extragrowth4;
						setorigin(self, self.origin);
						//gamemodel is fine for this, it doesn't interact;
        					if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        					self.solid = SOLID_BSP;
        					self.movetype = MOVETYPE_PUSH;
						
						e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth4;
					   
					  	pv = e.origin;
					  	pv_z = extragrowth4.origin_z + 384 + 128; //Center and then some
					  	pc = pointcontents(pv);
					  	if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
							extragrowth5 = spawn();
							extragrowth5.classname = "building";
							extragrowth5.model = "maps/buildables/building_kelp.bsp";
							extragrowth5.solid = SOLID_BSP;
							extragrowth5.origin = extragrowth4.origin;
							extragrowth5.origin_z = extragrowth4.origin_z + 384;
							extragrowth5.angles = e.angles;
							extragrowth5.angles_y = e.angles_y + 45;
	
							self = extragrowth5;
							setorigin(self, self.origin);
							//gamemodel is fine for this, it doesn't interact;
        						if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        						self.solid = SOLID_BSP;
        						self.movetype = MOVETYPE_PUSH;
							//print(vtos(self.origin),"self.origin\n");
						
							e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth5;
						
							pv = e.origin;
					 	 	pv_z = extragrowth5.origin_z + 384 + 128; //Center and then some
					 	 	pc = pointcontents(pv);
					 	 	if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
								extragrowth6 = spawn();
								extragrowth6.classname = "building";
								extragrowth6.model = "maps/buildables/building_kelp.bsp";
								extragrowth6.solid = SOLID_BSP;
								extragrowth6.origin = extragrowth5.origin;
								extragrowth6.origin_z = extragrowth5.origin_z + 384;
								extragrowth6.angles = e.angles;
								extragrowth6.angles_y = e.angles_y;
	
								self = extragrowth6;
								setorigin(self, self.origin);
								//gamemodel is fine for this, it doesn't interact;
        							if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        							self.solid = SOLID_BSP;
        							self.movetype = MOVETYPE_PUSH;
								//e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth4;
								//e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth5;
								  e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth6;
						   	
								pv = e.origin;
					 	 		pv_z = extragrowth6.origin_z + 384 + 128; //Center and then some
					 	 		pc = pointcontents(pv);
					 	 		if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
									extragrowth7 = spawn();
									extragrowth7.classname = "building";
									extragrowth7.model = "maps/buildables/building_kelp.bsp";
									extragrowth7.solid = SOLID_BSP;
									extragrowth7.origin = extragrowth6.origin;
									extragrowth7.origin_z = extragrowth6.origin_z + 384;
									extragrowth7.angles = e.angles;
									extragrowth7.angles_y = e.angles_y + 45;
	
									self = extragrowth7;
									setorigin(self, self.origin);
									//gamemodel is fine for this, it doesn't interact;
        								if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        								self.solid = SOLID_BSP;
        								self.movetype = MOVETYPE_PUSH;
									e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth7;
						   		
									pv = e.origin;
					 	 			pv_z = extragrowth7.origin_z + 384 + 128; //Center and then some
					 	 			pc = pointcontents(pv);
					 	 			if (pc == CONTENT_WATER || pc == CONTENT_SLIME || pc == CONTENT_LAVA) {
										extragrowth8 = spawn();
										extragrowth8.classname = "building";
										extragrowth8.model = "maps/buildables/building_kelp.bsp";
										extragrowth8.solid = SOLID_BSP;
										extragrowth8.origin = extragrowth7.origin;
										extragrowth8.origin_z = extragrowth7.origin_z + 384;
										extragrowth8.angles = e.angles;
										extragrowth8.angles_y = e.angles_y;
										//print(vtos(self.origin),"self.origin\n");
		
										self = extragrowth8;
										setorigin(self, self.origin);
										//gamemodel is fine for this, it doesn't interact;
        									if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        									self.solid = SOLID_BSP;
        									self.movetype = MOVETYPE_PUSH;
										e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = extragrowth8;
						   			}
								}
							}
						}
					   }
				  }
			 }
		}
		//End extra stuff
		
		self = oldself;
	} else if (self.count == 502) {
		//Vineyard
		entity cp1, cbw1, cbw2, cbw3;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1;	//Radius to search for it in.
		
			self.health = 5;
			self.max_health = 25;

		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		//This adds to energy tanks each min
		cbw1 = spawn();
		self = cbw1;
		
			self.think = multitool_field_grapes_think;

		self.nextthink = time + 70 + (40 * random()); //Vineyards are slower
		self.subordinate4 = cp1; //So we can figure out our current team
		
		entity tcr;
		tcr = spawn(); //Spawn tracer
		
		cbw2 = spawn();
		self = cbw2;
		if (random() > 0.5) {
			self.origin = e.origin + '128.000000 128.000000 0.000000';
		} else {
			self.origin = e.origin + '-128.000000 -128.000000 0.000000';
		}
		
		//Use tracer
		tcr.origin = self.origin;
		traceline(tcr.origin + '0 0 768', tcr.origin - '0 0 768', MOVE_NORMAL, tcr);
		
		self = cbw2;
		setorigin(self, tcr.origin);
		self.respawntime = 360;
		self.respawntimejitter = 120;
		spawnfunc_item_food_grapes();
		
		cbw3 = spawn();
		self = cbw3;
		if (random() > 0.5) {
			self.origin = e.origin + '-32.000000 32.000000 0.000000';
		} else {
			self.origin = e.origin + '32.000000 -32.000000 0.000000';
		}
		
		//Use tracer
		tcr.origin = self.origin;
		traceline(tcr.origin + '0 0 768', tcr.origin - '0 0 768', MOVE_NORMAL, tcr);
		
		self = cbw3;
		setorigin(self, tcr.origin);
		self.respawntime = 460;
		self.respawntimejitter = 140;
		spawnfunc_item_food_grapes();
		
		remove(tcr); //Remove tracer
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		
		self = oldself;
	} else if (self.count == 503 || self.count == 1502) {
		//RecruitmentPost
		entity f1, cp1, brcntl, spwnthnk;
		//Flag Stuff
		f1 = spawn();
		self = f1;
		multitool_spawnflag('0 0 64', e, oldself);
		self.alpha = 0.8; //Flag (starts disabled)
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 8';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_recruitmentpost();
		self.ammount = 1; //State
		self.subordinate5 = f1; //Flag
		
		spwnthnk = spawn();
		spwnthnk.think = multitool_recruitmentpost_think;
		spwnthnk.nextthink = time;
		spwnthnk.origin = e.origin;
		spwnthnk.subordinate4 = cp1; //So we know what team we are
		spwnthnk.subordinate5 = f1; //Flag
		if (e.count == 503) {
			spwnthnk.cnt = 1; //Medeval
		} else {
			spwnthnk.cnt = 0; //Future
		}
		self = spwnthnk;
		setorigin(self, self.origin);
		
		brcntl.subordinate4 = spwnthnk; //so we can control state
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = brcntl;
		e.subordinate.subordinate.subordinate = spwnthnk;
		e.subordinate.subordinate.subordinate.subordinate = f1;
		
		local float myrecruitoptions;
		myrecruitoptions = mutitool_recruitmentpost_myselectmonster(spwnthnk.cnt, e.origin, 1024);
		if not(myrecruitoptions)
		{
			if (spwnthnk.cnt == 1) {
				//Search for dojo etc stuff.
				myrecruitoptions = mutitool_recruitmentpost_myselectmonster(spwnthnk.cnt, e.origin, 1536);	
			}
		}
		
		if not(myrecruitoptions)
		{
			f1.alpha = 0.5; //Flag (nothing in vicinity)
			if(clienttype(cp1.realowner) == CLIENTTYPE_REAL) {
				if (spwnthnk.cnt == 1) { //Medeval
					sprint(cp1.realowner, "Build a barracks or stronghold in the vicinity to recruit knights\n");
					sprint(cp1.realowner, "Build a small castle in the vicinity to recruit royal guards\n");
					sprint(cp1.realowner, "Build a dojo in the vicinity to recruit fighters\n");
					sprint(cp1.realowner, "Build a shrine in the vicinity to recruit ninja assassins\n");
				} else {
					sprint(cp1.realowner, "Build a security building or glass base in the vicinity to attract soliders\n");
				}
			}
		} else {
			if(clienttype(cp1.realowner) == CLIENTTYPE_REAL) {
				if (myrecruitoptions == MULTITOOLRECRUIT_ROYALGUARD) { //Medeval
					royalguard_precacheforothers(); //So other clients will see it
					sprint(cp1.realowner, "Royal guards are most likely to be recruited\n");
				} else if (myrecruitoptions == MULTITOOLRECRUIT_KNIGHT) { //Medeval
					knight_precacheforothers();
					sprint(cp1.realowner, "Knights are most likely to be recruited\n");
				} else if (myrecruitoptions == UTILITOOLRECRUIT_SOLIDER) { //Futuristic
					soldier_precacheforothers();
					sprint(cp1.realowner, "Solider are most likely to join your cause\n");	
				} else if (myrecruitoptions == MULTITOOLRECRUIT_FIGHTER) { //Medeval
					fighter_precacheforothers();
					sprint(cp1.realowner, "Fighters are most likely to be recruited\n");
				} else if (myrecruitoptions == MULTITOOLRECRUIT_NINJAASSASSIN) { //Medeval
					ninjaassassin_precacheforothers();
					sprint(cp1.realowner, "Ninja Assassins are most likely to be recruited\n");
				} else {
					sprint(cp1.realowner, "It is unknown what will be recruited\n");
				}
			}
		}	

	} else if (self.count == 520 || self.count == 521 || self.count == 522 || self.count == 523
		|| self.count == 530 || self.count == 531 || self.count == 532 || self.count == 533) {
		//Wall - Hedge
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}

		if (oldself.count == 520 || oldself.count == 530 || oldself.count == 523 || oldself.count == 533) {
			self.origin = e.origin;
		} else if (oldself.count == 532) {
			self.origin = e.origin + '0 0 152';
		} else {
			self.origin = e.origin + '0 0 128';
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 32;	//Radius to search for it in.
		self.health = 5;
		self.max_health = 10;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		if (oldself.count == 520 || oldself.count == 523) {
			setsize(self, '-64 -64 0', '64 64 38');
		} else if (oldself.count == 530 || oldself.count == 533) {
			setsize(self, '-44 -44 0', '44 44 38');
		}
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 540 || self.count == 541 || self.count == 542
	|| self.count == 543 || self.count == 544 || self.count == 545 || self.count == 546) {
		//Wall - Palisade
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		if (oldself.count == 540 || oldself.count == 542 || oldself.count == 544 || oldself.count == 545) {
			self.origin = e.origin + '0 0 192';
		} else if (oldself.count == 543) {
			self.origin = e.origin + '0 0 300';
		} else {
			self.origin = e.origin;
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 15;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 550) {
		//Wall - Berm
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 188';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 15;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 551) {
		//Wall - Berm
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 256';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 15;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 560 || self.count == 563 || self.count == 569) {
		//Wall - Curtain
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 384';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 17;
		self.max_health = 35;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 561) {
		//Wall - Curtain
		entity cp1, l1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '128 128 384';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 17;
		self.max_health = 35;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		l1 = spawn();
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-32 -32 -256';
		self.maxs = '48 48 380';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 562) {
		//Wall - Curtain - Round
		entity cp1, l1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '48 0 384';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		l1 = spawn();
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-32 -32 -256';
		self.maxs = '32 32 520';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 570 || self.count == 573 || self.count == 10708) {
		//Wall - Castle
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 571) {
		//Wall - Castle
		entity cp1, l1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '48 0 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		l1 = spawn();
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-32 -32 -256';
		self.maxs = '32 32 600';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 572) {
		//Wall - Castle - Round
		entity cp1, l1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '48 0 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		l1 = spawn();
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-32 -32 -256';
		self.maxs = '32 32 584';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 566 || self.count == 574 || self.count == 575 || self.count == 583
		|| self.count == 1680 || self.count == 1681 || self.count == 1686 || self.count == 610 || self.count == 611 || self.count == 612
		|| self.count == 616) {
		//Vault - Castle
		entity cp1, shield;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		if (e.count == 616) {
			self.origin = e.origin + '0 0 0';
			fbspot = self.origin; //Flagbase will be moved here if it exists
			fbsrad = 0;	//Radius to search for it in.
			self.health = 19;
			self.max_health = 38;
			spawnfunc_multitool_controlpoint();
			setmodel(self, "null");
		} else {
			self.origin = e.origin + '248 248 0';
			fbspot = self.origin; //Flagbase will be moved here if it exists
			fbsrad = 0;	//Radius to search for it in.
			self.health = 19;
			self.max_health = 38;
			spawnfunc_multitool_controlpoint();
			setmodel(self, "models/marker.md3");
		}
		
		if (e.count == 1686 || e.count == 616) {
			setsize(self, '-136 -136 0', '136 136 38');
		} else {
			setsize(self, '-64 -64 0', '64 64 38');
		}
		
		
		if(oldself.owner.multitool_vaultwings == 1 && (e.count != 610) && (e.count != 611) && (e.count != 612) && (e.count != 616)) {
			print("Vaultwings\n");
			shield = spawn();
			shield.classname = "building";
			shield.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
			if (e.count == 583) {
				shield.model = "maps/buildables/vault_wings_polish.bsp";
			} else if (e.count == 566) {
				if (ourcastlecolor == 1 || ourcastlecolor == 5) {
					//Tan or Light tan gets mudbrick
					shield.model = "maps/buildables/vault_wings_curtain_mudbrick.bsp";
					precache_model (shield.model);
				} else {
					shield.model = "maps/buildables/vault_wings_curtain.bsp";
				}
			} else if (e.count == 1680 || e.count == 1681) {
				shield.model = "maps/buildables/vault_wings_future.bsp";
			} else if (e.count == 1686) {
				shield.model = "maps/buildables/vault_wings_concrete.bsp";
			} else {
				if (ourcastlecolor == 1) {
					//print("castlecolorsshield\n");
					//Tan
					shield.model = "maps/buildables/vault_wings_castletan.bsp";
				} else if (ourcastlecolor == 2) {
					//White
					shield.model = "maps/buildables/vault_wings_castlewhite.bsp";
				} else if (ourcastlecolor == 3) {
					//Green
					shield.model = "maps/buildables/vault_wings_castlegreen.bsp";
				} else if (ourcastlecolor == 4) {
					//Brown
					shield.model = "maps/buildables/vault_wings_castlebrown.bsp";
				} else if (ourcastlecolor == 5) {
					//LightTan
					shield.model = "maps/buildables/vault_wings_castlelighttan.bsp";
				} else if (ourcastlecolor == 6) {
					//Black
					shield.model = "maps/buildables/vault_wings_castleblack.bsp";
				} else if (ourcastlecolor == 7) {
					//Mauve
					shield.model = "maps/buildables/vault_wings_castlemauve.bsp";
				} else if (ourcastlecolor == 8) {
					//Pink
					shield.model = "maps/buildables/vault_wings_castlepink.bsp";
				} else {
					shield.model = "maps/buildables/vault_wings_castle.bsp";
				}
				
				if (ourcastlecolor) {
					precache_model (shield.model);
				}
			}
			shield.solid = SOLID_BSP;
			shield.origin = e.origin;
			shield.angles = e.angles;
	
			self = shield;
			setorigin(self, self.origin);
        		//if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			//Client model is good for this, doesn't need to change, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        		self.solid = SOLID_BSP;
        		self.movetype = MOVETYPE_PUSH;
			//self.alpha = 1;
			//self.subordinate4 = cp1; //So we can figure out our current team
		
		} else if(e.count == 616) {
			//print("roof\n");
			shield = spawn();
			shield.classname = "building";
			shield.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;

				if (ourwoodcolor == 1) {
					//Orange
					shield.model = "maps/buildables/vault_roof_dome_top_cprbronze.bsp";
				} else if (ourwoodcolor == 2) {
					//Cyan
					shield.model = "maps/buildables/vault_roof_dome_top_turq.bsp";
				//} else if (ourwoodcolor == 3) {
				//	//Tiles
				//	shield.model = "maps/buildables/.bsp";
				} else if (ourwoodcolor == 4) {
					//Red
					shield.model = "maps/buildables/vault_roof_dome_top_reddrk.bsp";
				} else if (ourwoodcolor == 5) {
					//Blue
					shield.model = "maps/buildables/vault_roof_dome_top_bluedrk.bsp";
				} else if (ourwoodcolor == 6) {
					//Light Blue
					shield.model = "maps/buildables/vault_roof_dome_top_bluelght.bsp";
				} else if (ourwoodcolor == 7) {
					//Brass
					shield.model = "maps/buildables/vault_roof_dome_top_brass.bsp";
				} else if (ourwoodcolor == 8) {
					//Black
					shield.model = "maps/buildables/vault_roof_dome_top_black.bsp";
				//} else if (ourwoodcolor == 9) {
				//	//
				//	shield.model = "maps/buildables/.bsp";
				} else if (ourwoodcolor == 10) {
					//LightRed
					shield.model = "maps/buildables/vault_roof_dome_top_redlght.bsp";
				} else if (ourwoodcolor == 11) {
					//Silver
					shield.model = "maps/buildables/vault_roof_dome_top_silver.bsp";
				} else if (ourwoodcolor == 12) {
					//Gold
					shield.model = "maps/buildables/vault_roof_dome_top_gold.bsp";
				} else if (ourwoodcolor == 14) {
					//Copper
					shield.model = "maps/buildables/vault_roof_dome_top_scopper.bsp";
				} else if (ourwoodcolor == 16) {
					//Plat
					shield.model = "maps/buildables/vault_roof_dome_top_plat.bsp";
				} else {
					//Tiles
					shield.model = "maps/buildables/vault_roof_dome_top_tiles.bsp";
				}
				
				precache_model (shield.model);

			shield.solid = SOLID_BSP;
			shield.origin = e.origin;
			shield.angles = e.angles;
	
			self = shield;
			setorigin(self, self.origin);
        		//if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			//Client model is good for this, doesn't need to change, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        		self.solid = SOLID_BSP;
        		self.movetype = MOVETYPE_PUSH;
			//self.alpha = 1;
			//self.subordinate4 = cp1; //So we can figure out our current team
		
		}
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = shield;
	} else if (self.count == 567 || self.count == 578 || self.count == 586 || self.count == 1539) {
		//Castle Fill Stairs - Castle, uses vault wings
		entity cp1, shield;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		if (e.count == 1539) {
			self.origin = e.origin + '64 -64 112';
		} else {
			self.origin = e.origin + '64 -64 192';
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		setsize(self, '-32 -32 0', '32 32 38');
		
		if(oldself.owner.multitool_vaultwings == 1) {
			print("Vaultwings\n");
			shield = spawn();
			shield.classname = "building";
			shield.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
			if (e.count == 586) {
				shield.model = "maps/buildables/vault_wings_polish.bsp";
			} else if (e.count == 567) {
				if (ourcastlecolor == 1 || ourcastlecolor == 5) {
					//Tan or Light tan gets mudbrick
					shield.model = "maps/buildables/vault_wings_curtain_mudbrick.bsp";
					precache_model (shield.model);
				} else {
					shield.model = "maps/buildables/vault_wings_curtain.bsp";
				}
			} else if (e.count == 1539) {
				shield.model = "maps/buildables/vault_wings_future.bsp";
			} else {
				if (ourcastlecolor == 1) {
					//print("castlecolorsshield\n");
					//Tan
					shield.model = "maps/buildables/vault_wings_castletan.bsp";
				} else if (ourcastlecolor == 2) {
					//White
					shield.model = "maps/buildables/vault_wings_castlewhite.bsp";
				} else if (ourcastlecolor == 3) {
					//Green
					shield.model = "maps/buildables/vault_wings_castlegreen.bsp";
				} else if (ourcastlecolor == 4) {
					//Brown
					shield.model = "maps/buildables/vault_wings_castlebrown.bsp";
				} else if (ourcastlecolor == 5) {
					//LightTan
					shield.model = "maps/buildables/vault_wings_castlelighttan.bsp";
				} else if (ourcastlecolor == 6) {
					//Black
					shield.model = "maps/buildables/vault_wings_castleblack.bsp";
				} else if (ourcastlecolor == 7) {
					//Mauve
					shield.model = "maps/buildables/vault_wings_castlemauve.bsp";
				} else if (ourcastlecolor == 8) {
					//Pink
					shield.model = "maps/buildables/vault_wings_castlepink.bsp";
				} else {
					shield.model = "maps/buildables/vault_wings_castle.bsp";
				}
				
				if (ourcastlecolor) {
					precache_model (shield.model);
				}
			}
			shield.solid = SOLID_BSP;
			shield.origin = e.origin;
			shield.angles = e.angles;
	
			self = shield;
			setorigin(self, self.origin);
        		//if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			//Client model is good for this, doesn't need to change, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
        		self.solid = SOLID_BSP;
        		self.movetype = MOVETYPE_PUSH;
			//self.alpha = 1;
			//self.subordinate4 = cp1; //So we can figure out our current team
		
		}
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = shield;
	} else if (self.count == 564 || self.count == 576 || self.count == 584 || self.count == 1538) {
		//Wall-Fill
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		setsize(self, '-142 -142 0', '142 142 38');
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 565 || self.count == 577 || self.count == 585
		|| self.count == 568 || self.count == 579 || self.count == 587
		|| self.count == 10700 || self.count == 10701 || self.count == 10702
		|| self.count == 10703 || self.count == 10704 || self.count == 10705
		|| self.count == 10706 || self.count == 10707
		|| self.count == 1540 || self.count == 1541) {
		//Wall-Interior
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '248 248 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		setsize(self, '-142 -142 0', '142 142 38');
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 10709 || self.count == 10710) {
		//portcullis Moving Gate
		entity cp1;
		entity d1;
		
		//e.mins = '-32 -32 0';
		//e.maxs = '32 32 64';
		//setsize(e, '-32 -32 0', '32 32 64');
		//print(e.model," here\n");
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		
		////Not a block
		//if (oldself.multitool_flipblock == 1) {
		//	self.origin_z = self.origin_z - 64; //Move Down (center though, not 128 down)
		//}
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 30;
		self.max_health = 70;
		spawnfunc_multitool_controlpoint();
		//setmodel(self, "null");
		setmodel(self, "models/marker.md3");
		setsize(self, '-2 -2 0', '2 2 64');
		
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
	
			//32 is from center
			if (e.angles_y == 0) {
				self.origin = e.origin + '0 32 0';
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '32 0 0';
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '0 -32 0';
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-32 0 0';
			}
			
			if (e.count == 10709) {
				self.dmg = 100;
				self.objcthitmaterial = 8; //Wood
				self.model = "maps/buildables/door_up_portcullis_wood_gate_large.bsp";
			} else {
				self.dmg = 200;
				self.objcthitmaterial = 2; //Metal
				self.model = "maps/buildables/door_up_portcullis_iron_gate_large.bsp";
			}

			
		
		setorigin(self, self.origin);
		//self.dmg set above, unlike sliding door, doesn't seem to instantly kill vehicle
		//self.health = 20;
		//self.spawnflags = 4;
		self.spawnflags = 2048; //NeedUse
		self.speed = 40;
		self.wait = 1;
		self.angles_y = -120;
		self.doorsetsubordinate = 1;
		self.doorreducedtriggerset = 1;
		self.doorsettriggersize = 1;
		self.doortriggermins = '-48 -48 0';
		self.doortriggermaxs = '48 48 128';
		spawnfunc_multitool_func_door();
		self.blocked = multitool_portcullis_door_blocked; //Uses impale deathtype, only change so far. Didn't want gibbing
		self.angles_y = e.angles_y;
		self.pos2 = self.pos1 + '0 0 176';
		
		
		
		self = oldself;
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d1.multitool_doorframeent = e;
		//We do not rename the classname, as it is used in the rotating door code
		//Instead we set these 2 vars:
		d1.accptcrssbwstklkbld = 1; //Accept crossbowbolts like building
		d1.accptlikebuilding = 1;   //Accept other things like building (mostly used in Axe, Chainsaw etc code): IE: Be treated like a classname "building" in some ways
		//Also we would like to have blood splatter if someone got a bullet through them:
		d1.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = d1;
	} else if (self.count == 580 || self.count == 582 || self.count == 588) {
		//Wall - Polish
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cp1;
	} else if (self.count == 581) {
		//Wall - Polish Tower
		entity cp1, l1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '48 0 448';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		l1 = spawn();
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-32 -32 -256';
		self.maxs = '32 32 600';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 630 || self.count == 631 || self.count == 632 || self.count == 633
		|| self.count == 1630 || self.count == 1631) {
		//Foundation
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 2';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 645 || self.count == 646 || self.count == 650 || self.count == 651 || self.count == 652
		|| self.count == 660 || self.count == 661 || self.count == 662
		|| self.count == 663 || self.count == 664
		|| self.count == 670 || self.count == 671 || self.count == 672
		|| self.count == 1650 || self.count == 1651) {
		//Bridge
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 8';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1652) {
		//Bridge-Sheild
		entity cp1, shield, cbw1;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 8';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		shield.model = "maps/buildables/bridge_future_light_shield.bsp";
		shield.isquestionableblocktypemultitool = 1; //No building on here even if blocktype any (unless admin sets otherwise)
		shield.solid = SOLID_BSP;
		shield.origin = e.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	spawnfunc_misc_gamemodel(); //no forced dynamic light for this model
        	self.solid = SOLID_BSP;
        	self.movetype = MOVETYPE_PUSH;
		self.alpha = 1;
		self.subordinate4 = cp1; //So we can figure out our current team
		
		cbw1 = spawn();
		cbw1.realowner = cp1;
		cbw1.think = multitool_bridgefuturelight_think;
		cbw1.ammount = 1; //Default on
		cbw1.nextthink = time;
		cbw1.origin = e.origin;
		cbw1.subordinate4 = shield;
		self = cbw1;
		setorigin(self, self.origin);
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
			shield.team = e.team;
			shield.colormap = e.colormap;
		} else {
			e.colormap = oldself.owner.colormap;
			shield.colormap = e.colormap;
		}

		e.subordinate = cp1;
		e.subordinate.subordinate = shield;
		e.subordinate.subordinate.subordinate = cbw1;
	} else if (self.count == 1653) {
		//Bridge-Light-Control
		entity cp1, brcntl;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 8';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		//setmodel(self, "models/marker.md3");
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_bridgecontrol();
		self.ammount = 1;
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = brcntl;
	
	} else if (self.count == MTB64U_DOOR_R_STEEL
	 || self.count == MTB64U_DOOR_R_PLAIN
	 || self.count == MTB64U_DOOR_R_PLAIN2
	 || self.count == MTB64U_DOOR_R_GLASS ||  self.count == MTB64_DOOR_R_WOOD
	 || self.count == MTB64_DOOR_R_JWOOD || self.count == MTB64_DOOR_R_FWOOD || self.count == MTB64_DOOR_R_IRONBAR) {
		//Block x64 type door
		entity cp1;
		entity d1;
		
		//e.mins = '-32 -32 0';
		//e.maxs = '32 32 64';
		//setsize(e, '-32 -32 0', '32 32 64');
		//print(e.model," here\n");
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		
		if (oldself.multitool_flipblock == 1) {
			self.origin_z = self.origin_z - 64; //Move Down (center though, not 128 down)
		}
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 30;
		self.max_health = 70;
		spawnfunc_multitool_controlpoint();
		//setmodel(self, "null");
		setmodel(self, "models/marker.md3");
		setsize(self, '-2 -2 0', '2 2 64');
		
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y + 90;
	
		//print(ftos(e.angles_y), " angles\n");
		if (e.count == MTB64_DOOR_R_WOOD) {
			self.objcthitmaterial = 8; //Wood
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_wood1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_wood1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_wood1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_wood1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_wood1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_wood1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_wood1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_wood1c.bsp";
			}
			self.noise1 = "sound/plats/medplat2.ogg";
		} else if (e.count == MTB64_DOOR_R_JWOOD) {
			self.objcthitmaterial = 8; //Wood
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_jwood1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_jwood1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_jwood1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_jwood1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_jwood1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_jwood1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_jwood1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_jwood1c.bsp";
			}
			self.noise1 = "sound/plats/medplat2.ogg";
		} else if (e.count == MTB64_DOOR_R_FWOOD) {
			self.objcthitmaterial = 8; //Wood
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_fwood1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_fwood1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_fwood1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_fwood1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_fwood1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_fwood1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_fwood1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_fwood1c.bsp";
			}
			self.noise1 = "sound/plats/medplat2.ogg";
		} else if (e.count == MTB64_DOOR_R_IRONBAR) {
			self.objcthitmaterial = 2; //Metal
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_ironbar_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_ironbar.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_ironbara_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_ironbara.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_ironbarb_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_ironbarb.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_ironbarc_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_ironbarc.bsp";
			}
			self.noise1 = "sound/plats/medplat2.ogg";
		} else if (e.count == MTB64U_DOOR_R_GLASS) {
			self.objcthitmaterial = 6; //Glass
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_glass1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_glass1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_glass1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_glass1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_glass1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_glass1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_glass1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_glass1c.bsp";
			}
		} else if (e.count == MTB64U_DOOR_R_PLAIN) {
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain1c.bsp";
			}
		} else if (e.count == MTB64U_DOOR_R_PLAIN2) {
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain2_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain2.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain2a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain2a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain2b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain2b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_plain2c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_plain2c.bsp";
			}
		} else {
			self.objcthitmaterial = 2; //Metal
			if (e.angles_y == 0) {
				self.origin = e.origin + '30 27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_steel1_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_steel1.bsp";
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '27 -30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_steel1a_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_steel1a.bsp";
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '-30 -27 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_steel1b_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_steel1b.bsp";
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-27 30 0';
				if (ourdoorcenter == 1.5 || ourdoorcenter == 2.5)
					self.model = "maps/buildables/door_rot_small_64_steel1c_short.bsp";
				else
					self.model = "maps/buildables/door_rot_small_64_steel1c.bsp";
			}
		}
		
		if (oldself.multitool_flipblock == 1) {
			self.origin_z = self.origin_z - 128; //Move Down
		}
				
		
		setorigin(self, self.origin);
		self.dmg = 10;
		//self.health = 20;
		//self.spawnflags = 4;
		self.spawnflags = 2048; //NeedUse
		self.speed = 40;
		self.wait = 1;
		self.angles_y = -120;
		self.doorsetsubordinate = 1;
		self.doorreducedtriggerset = 1;
		self.doorsettriggersize = 1;
		self.doortriggermins = '-48 -48 0';
		self.doortriggermaxs = '48 48 128';
		spawnfunc_multitool_func_door_rotating();
		//self.pos2 = self.pos1 - '0 0 104';
		//self.angles_y = e.angles_y + 90;
		//print(ftos(self.angles_y),"\n");
		
		
		
		self = oldself;
		
		if (e.count == MTB64U_DOOR_R_GLASS) {
			//This one is always coloured team color
			if (teamplay) {
				d1.team = oldself.owner.team;
				d1.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				d1.colormap = oldself.owner.colormap;
			}
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d1.multitool_doorframeent = e;
		//We do not rename the classname, as it is used in the rotating door code
		//Instead we set these 2 vars:
		d1.accptcrssbwstklkbld = 1; //Accept crossbowbolts like building
		d1.accptlikebuilding = 1;   //Accept other things like building (mostly used in Axe, Chainsaw etc code): IE: Be treated like a classname "building" in some ways
		//Also we would like to have blood splatter if someone got a bullet through them:
		d1.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = d1;
	} else if (self.count == MTB64_FITTEDWINDOW_CASTLE_ALOOP
		|| self.count == MTB64_FITTEDWINDOW_CASTLE_SWALL
		|| self.count == MTB64_FITTEDWINDOW_WINDOW
		|| self.count == MTB64U_FITTEDWINDOW_STEELSLIT
		|| self.count == MTB64U_FITTEDWINDOW_STEELPLATE
		|| self.count == MTB64U_FITTEDWINDOW_CWALL
		|| self.count == MTB64U_FITTEDWINDOW_UWINDOW) {
		//Block x64 type fitted window (similar to door but doesn't open)
		entity cp1;
		
		//e.mins = '-32 -32 0';
		//e.maxs = '32 32 64';
		//setsize(e, '-32 -32 0', '32 32 64');
		//print(e.model," here\n");
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		
		if (oldself.multitool_flipblock == 1) {
			self.origin_z = self.origin_z - 64; //Move Down (center though, not 128 down)
		}
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 30;
		self.max_health = 70;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "null");
		//setmodel(self, "models/marker.md3");
		setsize(self, '-2 -2 0', '2 2 64');
		
		self = oldself;
		
		if (e.count == MTB64U_FITTEDWINDOW_UWINDOW) {
			if (teamplay) {
				e.team = oldself.owner.team;
				e.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				e.colormap = oldself.owner.colormap;
			}
		}
		
		e.subordinate = cp1;

	} else if ((self.count >= MTB64FIRST && self.count <= MTB64LAST)
		|| (self.count >= MTB64UFIRST && self.count <= MTB64ULAST)) {
		//Block x64
		entity cp1;
		entity spkhrt; //Used for stakes and other hurt
		entity spkhrttop; //Used for second
		entity mtbdynlight; //Used for dynlight
		entity mtfrgburnent; //Forge burn entity
		entity mtfrgthink; //forgethink
		entity mybedspawnpt; //If we use
		entity cbw1;
		local float myisbedneedspawn; //We will add spawn
		local float myskipdynlight;
		myisbedneedspawn = 0;
		myskipdynlight = 0;
		
		entity tp2, pr1, pr3tor, tp3tor;
		local float pr1hasbeenadded;
		local float tp2hasbeenadded;
		pr1hasbeenadded = 0;
		tp2hasbeenadded = 0;
		
		//e.mins = '-32 -32 0';
		//e.maxs = '32 32 64';
		//setsize(e, '-32 -32 0', '32 32 64');
		//print(e.model," here\n");
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		if (oldself.multitool_flipblock == 1) {
			//print("here 22\n");
			self.origin_z = self.origin_z - 64;
		}
		if (oldself.multitool_roofcolor) {
			self.multitool_roofcolor = oldself.multitool_roofcolor;
		}
		if (oldself.multitool_flamecolor) {
			self.multitool_flamecolor = oldself.multitool_flamecolor;
		}
		if (oldself.multitool_woodcolor) {
			self.multitool_woodcolor = oldself.multitool_woodcolor;
		}
		if (oldself.multitool_marblecolor) {
			self.multitool_marblecolor = oldself.multitool_marblecolor;
		}
		if (oldself.multitool_castlecolor) {
			self.multitool_castlecolor = oldself.multitool_castlecolor;
		}
		if (oldself.multitool_sstonecolor) {
			self.multitool_sstonecolor = oldself.multitool_sstonecolor;
		}

		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "null");
		if (e.count == MTB64U_FURN_COMCRATE
		|| e.count == MTB64U_FURN_COMCRATE2
		|| e.count == MTB64U_FURN_MTLCRATE) {
			//These are big
			setsize(self, '-70 -70 0', '70 70 128');
		} else {
			//Normal x64 sized block, so similar control point, just abit bigger so we can touch it
			setsize(self, '-32 -32 0', '32 32 64');
		}
		
		
		if (e.count == MTB64_FURN_IRONBRAZIER) {
			//Test to see if we can spawn the flame and invis lava
			local float mypcon;
			local vector mydyntestorigin;
			mydyntestorigin = e.origin; 
			if (oldself.multitool_flipblock == 1) {
				mydyntestorigin_z = mydyntestorigin_z - 32; //Move Down
			} else {
				mydyntestorigin_z = mydyntestorigin_z + 32; //Move up
			}
			
			mypcon = pointcontents(mydyntestorigin);
			if (mypcon == CONTENT_WATER || mypcon == CONTENT_SLIME || mypcon == CONTENT_LAVA) {
				myskipdynlight = 1; //We cannot spawn dynlight
			}
		}
		
		
		if (e.count == MTB64_STAKES_WOOD1 || e.count == MTB64_BWIRE || e.count == MTB64U_BWIRE_X || e.count == MTB64U_BWIRE_O
		|| e.count == MTB64U_BWIRE || e.count == MTB64_FURN_BLKSMHFORGE
		|| e.count == MTB64_FURN_IRONMAIDEN
		|| e.count == MTB64_FURN_SPIKEDRACK
		|| e.count == MTB64_FURN_IMPALEMENTPOLE
		|| (e.count == MTB64_FURN_IRONBRAZIER && (!(myskipdynlight)))) {
			////Hurt Trigger (for stakes, bwire, etc)
			spkhrt = spawn();
			spkhrt.origin = e.origin;
			if (e.count == MTB64_FURN_BLKSMHFORGE) {
				precache_model ("maps/buildables/block_64_invis_lava.bsp");
				if (oldself.multitool_flipblock == 1) {
					spkhrt.origin_z = spkhrt.origin_z - 48; //Move Down
				} else {
					spkhrt.origin_z = spkhrt.origin_z + 16; //Move up
				}
				spkhrt.solid  = SOLID_BSP;
				spkhrt.model = "maps/buildables/block_64_invis_lava.bsp";
				
				self = spkhrt;
				setorigin(self, self.origin);
				
				if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			} else if (e.count == MTB64_FURN_IRONBRAZIER) {
				precache_model ("maps/buildables/block_32_invis_lava.bsp");
				if (oldself.multitool_flipblock == 1) {
					spkhrt.origin_z = spkhrt.origin_z - 128; //Move Down
				} else {
					spkhrt.origin_z = spkhrt.origin_z + 64; //Move up
				}
				spkhrt.solid  = SOLID_BSP;
				spkhrt.model = "maps/buildables/block_32_invis_lava.bsp";
				
				self = spkhrt;
				setorigin(self, self.origin);
				
				if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
			} else if (e.count == MTB64_STAKES_WOOD1) {
				if (oldself.multitool_flipblock == 1) {
					spkhrt.origin_z = spkhrt.origin_z - 64; //Move Down
				} else {
					spkhrt.origin_z = spkhrt.origin_z + 32; //Move up
				}
				spkhrt.solid = SOLID_TRIGGER;
				spkhrt.mins = '-28 -28 0';
				spkhrt.maxs = '28 28 32';
				spkhrt.dmg = 75;
			
				self = spkhrt;
				setorigin(self, self.origin);
			
				self.message2 = "was thrown onto a woooden stake by";
				self.message = "fell on a wooden stake";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
			} else if (e.count == MTB64_FURN_IRONMAIDEN) {
				
				spkhrt.origin_z = spkhrt.origin_z;

				spkhrt.solid = SOLID_TRIGGER;
				spkhrt.mins = '-16 -16 0';
				spkhrt.maxs = '16 16 64';
				spkhrt.dmg = 15;
			
				self = spkhrt;
				setorigin(self, self.origin);
			
				self.message2 = "was thrown into an iron maiden by";
				self.message = "died in the iron maiden";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
			} else if (e.count == MTB64_FURN_SPIKEDRACK) {
				
				spkhrt.origin_z = spkhrt.origin_z;

				spkhrt.solid = SOLID_TRIGGER;
				spkhrt.mins = '-16 -16 0';
				spkhrt.maxs = '16 16 32';
				spkhrt.dmg = 1;
			
				self = spkhrt;
				setorigin(self, self.origin);
			
				self.message2 = "was thrown onto a spiked rack by";
				self.message = "died on the spiked rack";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
			} else if (e.count == MTB64_FURN_IMPALEMENTPOLE) {
				e.angles_y = e.angles_y + (90-(180*random()));
				spkhrt.origin_z = spkhrt.origin_z + 63; //24+40-1

				spkhrt.solid = SOLID_TRIGGER;
				spkhrt.mins = '-0.15 -0.15 0';
				spkhrt.maxs = '0.15 0.15 132'; //195-63 (see above)
				spkhrt.dmg = 0.2;
			
				self = spkhrt;
				setorigin(self, self.origin);
			
				self.message2 = "was impaled by";
				self.message = "died from impalement";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
				
				//
				spkhrttop = spawn();
				spkhrttop.origin = e.origin;
				
				spkhrttop.origin_z = spkhrttop.origin_z + 192;

				spkhrttop.solid = SOLID_TRIGGER;
				spkhrttop.mins = '-2 -2 -16';
				spkhrttop.maxs = '2 2 16';
				spkhrttop.dmg = 100;
			
				self = spkhrttop;
				setorigin(self, self.origin);
			
				self.message2 = "was thrown onto an impalement pole by";
				self.message = "fell on an impalement pole";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
				
			} else {
				if (oldself.multitool_flipblock == 1) {
					spkhrt.origin_z = spkhrt.origin_z - 64; //Move Down
				}
				
				spkhrt.solid = SOLID_TRIGGER;

				if (e.count == MTB64U_BWIRE || e.count == MTB64_BWIRE) {
					if (e.angles_y == 0 || e.angles_y == -180 || e.angles_y == 180) {
						spkhrt.mins = '-32 -4 0';
						spkhrt.maxs = '32 4 64';
					} else {
						spkhrt.mins = '-4 -32 0';
						spkhrt.maxs = '4 32 64';
					}
				} else {
					spkhrt.mins = '-32 -32 0';
					spkhrt.maxs = '32 32 64';
				}
				spkhrt.dmg = 30;
			
				self = spkhrt;
				setorigin(self, self.origin);
			
				self.message2 = "was thrown onto razor wire by";
				self.message = "died on razor wire";
				
				spawnfunc_trigger_hurt();
				self.touch = multitool_trigger_hurt_touch_cut;
			}
		} else if (e.count == MTB64_FURN_GREEKPILLAR
		|| e.count == MTB64_FURN_GREEKPILLARM
		|| e.count == MTB64_FURN_ROMANCOLUMN
		|| e.count == MTB64_FURN_ROMANCOLUMNM) {
			spkhrt = spawn();
			spkhrt.origin = e.origin;
			
			precache_model ("maps/buildables/furn_invis_pillar.bsp");
			if (oldself.multitool_flipblock == 1) {
				spkhrt.origin_z = spkhrt.origin_z - 256; //Move Down
			}
			spkhrt.classname = "building";
			spkhrt.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
			spkhrt.solid  = SOLID_BSP;
			spkhrt.model = "maps/buildables/furn_invis_pillar.bsp";
				
			self = spkhrt;
			setorigin(self, self.origin);
			
			//Client model is good here: doesn't interact, has good collision
			if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_clientmodel(); } else { spawnfunc_misc_clientmodel_dlight(); }
		} else if (e.count == MTB64_FURN_BLKSMHBELLOWS) {
			spkhrt = spawn();
			spkhrt.origin = e.origin;
				
			spkhrt.solid = SOLID_TRIGGER;
			spkhrt.mins = '-64 -64 0';
			spkhrt.maxs = '64 64 128';
			
			self = spkhrt;
			setorigin(self, self.origin);
				
			spawnfunc_multitool_trigger_bellows();
		} else if (e.count == MTB64U_FURN_LAMP_STREET
			|| e.count == MTB64U_FURN_LAMP_STREET2
			|| e.count == MTB64U_FURN_LAMP_STREET3
			|| e.count == MTB64U_FURN_LAMP_STREET4
			|| e.count == MTB64U_FURN_LAMP_STREET5) {
			//Create dynamic light
			local vector mydynlmplightorigin;
			mydynlmplightorigin = e.origin;
			if (oldself.multitool_flipblock == 1) {
				mydynlmplightorigin_z = mydynlmplightorigin_z - 96; //Move Down
			} else {
				mydynlmplightorigin_z = mydynlmplightorigin_z + 96; //Move up
			}
			mtbdynlight = multitool_spawnlampstreetlight(mydynlmplightorigin, 768);
			mtbdynlight.subordinate4 = cp1;
			
			cbw1 = spawn();
			cbw1.realowner = cp1;
			cbw1.think = multitool_lampstreet_think;
			cbw1.ammount3 = mtbdynlight.light_lev; //Light lev, when turnd back on, was set above
			
			cbw1.ammount2 = 1; //Amount of energy needed;
			
			cbw1.ammount = 1; //Default on
			cbw1.nextthink = time;
			cbw1.origin = e.origin;
			cbw1.subordinate4 = mtbdynlight;

			setorigin(cbw1, cbw1.origin);
		
		}
		
		
		if (e.count == MTB64_FURN_IRONMAIDEN
		|| e.count == MTB64_FURN_SPIKEDRACK
		|| e.count == MTB64_FURN_IMPALEMENTPOLE
		|| e.count == MTB64_FURN_GIBBET) {
				//We continue adding things for the ironmaiden
				//(above we added the trigger_hurt for the spikes)
				//Escape
				pr1 = spawn();
				self = pr1;
				self.spawnflags = 0;
				self.mins = '-128 -128 0';
				self.maxs = '128 128 120';
				self.origin = e.origin;
				setorigin(self, self.origin);
				self.prisonisoffurniture = 1;
				self.prisonisoffurniture_owner = e;
				local float myresponsefromfind;
				myresponsefromfind = multitool_findoverlappingtriggerprison (self, self.mins, self.maxs, self.origin);
				if (myresponsefromfind == 1) {
					remove(self);
					remove(tp2);
						//print("Did not add escape, boxes w/ a prison overlapped\n");
				} else if (myresponsefromfind == 2) {
					
					tp2 = spawn();
					SMI_SetOriginVsBldAngles(tp2, '0 48 24', e);
				
						//print("Added a prison surround\n");
					self.spawnflags = 2;
					self.enemy = tp2;
					spawnfunc_trigger_prison();
					pr1hasbeenadded = 1;
					tp2hasbeenadded = 1;
				} else {
						//print("Added an escape\n");
					spawnfunc_trigger_prison();
					pr1hasbeenadded = 1;
				}
			
				//Torture
				pr3tor = spawn();
				tp3tor = spawn();
		
				tp3tor.origin = e.origin + '0 0 24';
				tp3tor.angles = e.angles;
				
				if (e.count == MTB64_FURN_GIBBET) {
					tp3tor.origin_z = tp3tor.origin_z + 40;
				} else if (e.count == MTB64_FURN_SPIKEDRACK) {
					//tp3tor.angles_x = tp3tor.angles_x - 89; //Down
					//tp3tor.angles_y = tp3tor.angles_y - 89;
					tp3tor.angles_x = tp3tor.angles_x + 89; //Up
					tp3tor.angles_y = tp3tor.angles_y + 89;
				} else if (e.count == MTB64_FURN_IMPALEMENTPOLE) {
					pr3tor.prisondamageonrelease = 80;
					pr3tor.prisondamagetypeonrelease = DEATH_IMPALE;
					tp3tor.origin_z = tp3tor.origin_z + 40 + (105*random());
					tp3tor.prisondamageonrelease = pr3tor.prisondamageonrelease;
					tp3tor.prisondamagetypeonrelease = pr3tor.prisondamagetypeonrelease;
					local float myrndfimp;
					myrndfimp = random();
					if (myrndfimp > 0.90) {
						tp3tor.angles_x = tp3tor.angles_x + 89 - (180*random()); //Up
						tp3tor.angles_y = tp3tor.angles_y + 89 - (180*random());
						tp3tor.angles_z = tp3tor.angles_y + 89 - (180*random());
					} else if (myrndfimp > 0.67) {
						if (random() > 0.5) {
							tp3tor.angles_x = tp3tor.angles_x + 89; //Up
							tp3tor.angles_y = tp3tor.angles_y + 89;
						} else {
							tp3tor.angles_x = tp3tor.angles_x - 89; //Down
							tp3tor.angles_y = tp3tor.angles_y - 89;
						}
						
						if (myrndfimp > 0.8) {
							tp3tor.angles_x = tp3tor.angles_x + (20*random());
							tp3tor.angles_y = tp3tor.angles_y + (20*random());
						}
					}
				}
				
				//Torture post
				self = pr3tor;
				self.spawnflags = 3;
				self.mins = '-64 -64 0';
				self.maxs = '64 64 96';
				self.origin = e.origin + '0 0 0';
				setorigin(self, self.origin);
				self.enemy = tp3tor;
				self.prisonisoffurniture = 1;
				self.prisonisoffurniture_owner = e;
				spawnfunc_trigger_prison();
		}
		
		if (e.count == MTB64_FURN_BLKSMHFORGE) {
			local vector mydynlightorigin;
			mydynlightorigin = spkhrt.origin;
			if (oldself.multitool_flipblock == 1) {
				mydynlightorigin_z = mydynlightorigin_z - 28; //Move Down
			} else {
				mydynlightorigin_z = mydynlightorigin_z + 28; //Move up
			}
			mtbdynlight = multitool_spawnforgelight(mydynlightorigin);
			
			mtfrgburnent = spawn();
			self = mtfrgburnent;
			self.solid = SOLID_BBOX;
			self.origin = mydynlightorigin;
			setorigin(self, self.origin);
			setsize(self, '-16 -16 -16', '16 16 -2');
			
			//To tamp down fire quick
			mtfrgthink = spawn();
			self = mtfrgthink;
			self.origin = mydynlightorigin;
			self.nextthink = time + 1;
			self.think = multitool_forge_think;
			self.subordinate4 = mtfrgburnent;		
		} else if (e.count == MTB64_FURN_IRONBRAZIER) {
			local vector mydynlightorigin;
			
			if (oldself.multitool_flamecolor) {
				e.multitool_flamecolor = 0; //Will be set to a colormap if applicable now
				
				if (oldself.multitool_flamecolor == -10) {
					print("team or player color\n");
					if (teamplay) {
						e.team = oldself.owner.team;
						e.colormap = 1024 + (oldself.owner.team - 1) * 17;
					} else {
						e.colormap = oldself.owner.colormap;
					}
					e.multitool_flamecolor = oldself.multitool_flamecolor;
				} else if (oldself.multitool_flamecolor >= 1) {
					//print("color\n");
					if (oldself.multitool_flamecolor == 16) {
						e.colormap = 1024; //White/0
					} else if (oldself.multitool_flamecolor == 17) {
						e.colormap = 1023; //Hack for black, shows up as diff cycle
					} else {
						e.colormap = 1024 + oldself.multitool_flamecolor + (oldself.multitool_flamecolor * 16);
					}
				}
			}
			
			if (myskipdynlight) {
				//Do not create the dynamic light, and set skin to "no fire" skin
				if (e.skin == 0) { //Perhaps later we'll add more skins, 3, 6, 9, etc, with the ++ being the "no flame" version, the +2 being the colormapped flame
					e.skin = 1; //Empty
				}
			} else {
				if (oldself.multitool_flamecolor == -10
				|| oldself.multitool_flamecolor >= 1) {
					if (e.skin == 0) { //Perhaps later we'll add more skins, 3, 6, 9, etc, with the ++ being the "no flame" version, the +2 being the colormapped flame
						e.skin = 2; //Change to colormapped skins
					}
				}
				
				e.canigniteflame = 1;
				//Create dynamic light
				mydynlightorigin = spkhrt.origin;
			
				if (oldself.multitool_flipblock == 1) {
					mydynlightorigin_z = mydynlightorigin_z - 32; //Move Down
				} else {
					mydynlightorigin_z = mydynlightorigin_z + 32; //Move up
				}
				
				local vector myflamedynlightcolor;
				myflamedynlightcolor = '0 0 0';
				
				if (oldself.multitool_flamecolor == -10) {
					local vector my_c0, my_c1;
	
					my_c0 = colormapPaletteColor(floor(oldself.owner.clientcolors / 16), 0); //Shirt
					my_c1 = colormapPaletteColor(mod(oldself.owner.clientcolors, 16), 1);    //Pants
					myflamedynlightcolor = my_c0+my_c1;
					
					mtbdynlight = multitool_spawnironbrazierlight(mydynlightorigin, myflamedynlightcolor);
				} else if (oldself.multitool_flamecolor >= 1) {
					switch (oldself.multitool_flamecolor)
					{
						default:
						case 0:
						  	myflamedynlightcolor = '1.000000 1.000000 1.000000';
							break;
						case 1:
						  	myflamedynlightcolor = '1.000000 0.333333 0.000000';
							break;
						case 2:
						  	myflamedynlightcolor = '0.000000 1.000000 0.501961';
							break;
						case 3:
						  	myflamedynlightcolor = '0.000000 1.000000 0.000000';
							break;
						case 4:
						  	myflamedynlightcolor = '1.000000 0.000000 0.000000';
							break;
						case 5:
						  	myflamedynlightcolor = '0.000000 0.666667 1.000000';
							break;
						case 6:
						  	myflamedynlightcolor = '0.000000 1.000000 1.000000';
							break;
						case 7:
						  	myflamedynlightcolor = '0.501961 1.000000 0.000000';
							break;
						case 8:
						  	myflamedynlightcolor = '0.501961 0.000000 1.000000';
							break;
						case 9:
						  	myflamedynlightcolor = '1.000000 0.000000 1.000000';
							break;
						case 10:
						  	myflamedynlightcolor = '1.000000 0.000000 0.501961';
							break;
						case 11:
						  	myflamedynlightcolor = '0.000000 0.000000 1.000000';
							break;
						case 12:
						  	myflamedynlightcolor = '1.000000 1.000000 0.000000';
							break;
						case 13:
						  	myflamedynlightcolor = '0.000000 0.333333 1.000000';
							break;
						case 14:
						  	myflamedynlightcolor = '1.000000 0.666667 0.000000';
							break;
						case 15:
						  	myflamedynlightcolor = '0.9 0.8 0.9'; //whiteish.. for cycle
							break;
						case 16:
						  	myflamedynlightcolor = '1 1 1'; //white
							break;
						case 17:
						  	myflamedynlightcolor = '0.0001 0.0001 0.0001';
							break;
  					}
					
					mtbdynlight = multitool_spawnironbrazierlight(mydynlightorigin, myflamedynlightcolor);
				} else {
					mtbdynlight = multitool_spawnironbrazierlight(mydynlightorigin, '0 0 0');
				}
			}
			//////Cannot contain and direct air like the forge can
			//mtfrgburnent = spawn();
			//self = mtfrgburnent;
			//self.solid = SOLID_BBOX;
			//self.origin = mydynlightorigin;
			//setorigin(self, self.origin);
			//setsize(self, '-16 -16 -16', '16 16 -2');
			
			////To tamp down fire quick
			//mtfrgthink = spawn();
			//self = mtfrgthink;
			//self.origin = mydynlightorigin;
			//self.nextthink = time + 1;
			//self.think = multitool_forge_think;
			//self.subordinate4 = mtfrgburnent;	
			//////Cannot contain and direct air like the forge can	
		}
		
		if (e.count == MTB64_FURN_BED_WOOD
       		|| e.count == MTB64U_FURN_BED
        	|| e.count == MTB64U_FURN_BED_FOAM
		|| e.count == MTB64U_FURN_FUTON)
		{
			if (autocvar_g_balance_multitool_bedspawnpoints) {
			if not(multitool_ownedspawnpoint_tooclose_ent(e, 1024, oldself.owner)) {
				myisbedneedspawn = 1;
				
				mybedspawnpt = spawn();
				self = mybedspawnpt;
				self.origin = e.origin + '0 0 64';
				setorigin(self, self.origin);
				if (oldself.owner.team == COLOR_TEAM1) {
					spawnfunc_info_player_team1();
				} else if (oldself.owner.team == COLOR_TEAM2) {
					spawnfunc_info_player_team2();
				} else if (oldself.owner.team == COLOR_TEAM3) {
					spawnfunc_info_player_team3();
				} else if (oldself.owner.team == COLOR_TEAM4) {
					spawnfunc_info_player_team4();
				} else {
					spawnfunc_info_player_deathmatch();
					self.cntrlowner = cp1;
				}
				self.spawnpointisofbuildable = 1;
				
				//If we spawned a spawnpoint, no dragging us
				//(to avoid ghost spawnpoints of other team not being noticable)
				//Other option was to have spawnpoint follow... but then
				//you could drag a team or personal spawn into other base
				//without being able to build there...
				e.multitool_dragable = 0;
				e.grab = 0;
			}
			}
		}
		
		self = oldself;
		
		if (oldself.count == MTB64U_WINDOW_FUTURE || oldself.count == MTB64U_WINDOW_FUTURE_X
		|| oldself.count == MTB64_CLAIMSTONE || oldself.count == MTB64U_CLAIMSTONE) {
			//This one is always coloured team color
			if (teamplay) {
				e.team = oldself.owner.team;
				e.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				e.colormap = oldself.owner.colormap;
			}
		}
		
		e.multitool_roofcolor = 0;
		if ((oldself.count >= MTB64_SHINGLES && oldself.count <= MTB64_SHINGLESLAST)
		|| (oldself.count >= MTB64_SHINGLES2 && oldself.count <= MTB64_SHINGLES2LAST)
		|| oldself.count == MTB64_FURN_CHAIR_FANCY1 || oldself.count == MTB64_FURN_CHAIR_FANCY2
		|| oldself.count == MTB64_FURN_CHAIR_FANCY3
		|| oldself.count == MTB64_FURN_CHAISELOUNGE
		|| oldself.count == MTB64U_FURN_STOVE2 || oldself.count == MTB64U_FURN_FRIDGE3
		|| oldself.count == MTB64U_FURN_BED_FOAM || oldself.count == MTB64U_FURN_SOFA_FOAM
		|| oldself.count == MTB64U_FURN_SOFA_TARTAN
		|| oldself.count == MTB64U_FURN_SOFA_POOFY
		|| oldself.count == MTB64U_FURN_SOFA_NORM
		|| oldself.count == MTB64U_FURN_CSTOOL
		|| oldself.count == MTB64U_FURN_RETROCHAIR
		|| oldself.count == MTB64U_FURN_PLSCHAIR
		|| oldself.count == MTB64U_FURN_SCHINTGRDESK
		|| oldself.count == MTB64U_FURN_SCHDESKCHAIR
		|| oldself.count == MTB64U_FURN_RETROTABLE
		|| oldself.count == MTB64U_FURN_BSCKCABINET1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINET2
		|| oldself.count == MTB64U_FURN_BSCKCABINET3
		|| oldself.count == MTB64U_FURN_BSCKCABINET4
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNER1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNER2
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP2
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
		|| oldself.count == MTB64U_FURN_BSCKCABINETBAR1
		|| oldself.count == MTB64U_FURN_BSCKCABINETBARENDR
		|| oldself.count == MTB64U_FURN_BSCKCABINETBARENDL
		|| oldself.count == MTB64U_FURN_SCHAIR
		|| oldself.count == MTB64U_FURN_OMLCHAIR2) {
			// For this one it is always skin 7 by default
			if (oldself.count == MTB64U_FURN_OMLCHAIR2) {
				if (oldself.multitool_woodcolor == 2) {
					e.skin = 7; //Subdued
				} else if (oldself.multitool_woodcolor == 1) {
					e.skin = 8; //Moderate
				} else {
					e.skin = 9; //Vibrant
				}
			}
			//
		
			if (oldself.multitool_roofcolor == -10) {
				print("team or player color\n");
				if (teamplay) {
					e.team = oldself.owner.team;
					e.colormap = 1024 + (oldself.owner.team - 1) * 17;
				} else {
					e.colormap = oldself.owner.colormap;
				}
				e.multitool_roofcolor = oldself.multitool_roofcolor;
			} else if (oldself.multitool_roofcolor == 0
			&& oldself.count == MTB64U_FURN_SCHDESKCHAIR)
			{
				e.colormap = 0;
				e.skin = 4;
			} else if (oldself.multitool_roofcolor == 0
			&& oldself.count == MTB64U_FURN_SCHINTGRDESK)
			{
				e.colormap = (1024 + 5 + 5 * 16); //Blue
				e.skin = 4;
			} else if (oldself.multitool_roofcolor >= 1) {
				//print("color\n");
				if (oldself.multitool_roofcolor == 16) {
					if (oldself.count == MTB64U_FURN_PLSCHAIR) {
						e.colormap = 0;
						e.skin = 3;
					} else if (oldself.count == MTB64U_FURN_SCHDESKCHAIR) {
						e.colormap = 0;
						e.skin = 3;
					} else {
						e.colormap = 1024; //White/0
					}
				} else if (oldself.multitool_roofcolor == 17) {
					e.colormap = 1023; //Hack for black, shows up as diff cycle
				} else {
					e.colormap = 1024 + oldself.multitool_roofcolor * 16;
					
					if (oldself.count == MTB64U_FURN_RETROCHAIR
					|| oldself.count == MTB64U_FURN_RETROTABLE) 
					{
						if (oldself.multitool_roofcolor == 4) {
							e.colormap = 0;
							e.skin = 1;
						} else {
							e.skin = 0;
						}
					} else if (oldself.count == MTB64U_FURN_PLSCHAIR) 
					{
						if (oldself.multitool_roofcolor == 4) {
							e.colormap = 0;
							e.skin = 1;
						} else if (oldself.multitool_roofcolor == 10) {
							e.colormap = 0;
							e.skin = 2;
						} else {
							e.skin = 0;
						}
					} else if (oldself.count == MTB64U_FURN_SCHDESKCHAIR) 
					{
						if (oldself.multitool_roofcolor == 4) {
							e.colormap = 0;
							e.skin = 1;
						} else if (oldself.multitool_roofcolor == 10) {
							e.colormap = 0;
							e.skin = 2;
						} else {
							e.skin = 0;
						}
					} else if (oldself.count == MTB64U_FURN_SCHINTGRDESK) 
					{
						if (oldself.multitool_roofcolor == 4) {
							e.colormap = 0;
							e.skin = 1;
						} else if (oldself.multitool_roofcolor == 10) {
							e.colormap = 0;
							e.skin = 2;
						} else {
							e.skin = 0;
						}
					}
				}
			}
		}
		
		//The kitchen cabinets/countertops use woodcolor for skin
		if (oldself.count == MTB64U_FURN_BSCKCABINET1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
		|| oldself.count == MTB64U_FURN_BSCKCABINET2
		|| oldself.count == MTB64U_FURN_BSCKCABINET3
		|| oldself.count == MTB64U_FURN_BSCKCABINET4
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNER1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNER2
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP2
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2
		|| oldself.count == MTB64U_FURN_BSCKCABINETBAR1
		|| oldself.count == MTB64U_FURN_BSCKCABINETBARENDR
		|| oldself.count == MTB64U_FURN_BSCKCABINETBARENDL)
		{
			if (oldself.multitool_forceskin) {
				//For map placed furnishings of this type
				oldself.multitool_woodcolor = oldself.multitool_forceskin;
			}
			
			if (oldself.multitool_woodcolor == 1) {
				e.skin = 1;
			} else if (oldself.multitool_woodcolor == 2) {
				e.skin = 2;
			} else if (oldself.multitool_woodcolor == 3) {
				e.skin = 3;
			} else if (oldself.multitool_woodcolor == 4) {
				e.skin = 4;
			} else if (oldself.multitool_woodcolor == 5) {
				e.skin = 5;
			} else if (oldself.multitool_woodcolor == 6) {
				e.skin = 6;
			} else if (oldself.multitool_woodcolor == 7) {
				e.skin = 7;
			} else if (oldself.multitool_woodcolor == 8) {
				e.skin = 8;
			} else {
				e.skin = 0;
			}
		}
		
		
		//The Office Modern Leather chair uses woodcolor for skin
		if (oldself.count == MTB64U_FURN_OMLCHAIR
		|| oldself.count == MTB64U_FURN_MLHSKCHAIR
		|| oldself.count == MTB64U_FURN_TRIBECACHAIR
		|| oldself.count == MTB64U_FURN_BARCELONACHAIR)
		{
			if (oldself.multitool_forceskin) {
				//For map placed furnishings of this type
				oldself.multitool_woodcolor = oldself.multitool_forceskin;
			}
			
			if (oldself.multitool_woodcolor == 1) {
				e.skin = 1;
			} else if (oldself.multitool_woodcolor == 2) {
				e.skin = 2;
			} else if (oldself.multitool_woodcolor == 3) {
				e.skin = 3;
			} else if (oldself.multitool_woodcolor == 4) {
				e.skin = 4;
			} else if (oldself.multitool_woodcolor == 5) {
				e.skin = 5;
			} else if (oldself.multitool_woodcolor == 6) {
				e.skin = 6;
			} else {
				e.skin = 0;
			}
		}
		
		
		//The Metal Tube And Glass Desk uses woodcolor for skin
		if (oldself.count == MTB64U_FURN_MGSTDESK
		|| oldself.count == MTB64U_FURN_MGSTDESKFLAT
		|| oldself.count == MTB64U_FURN_MGSTDESKFULLCORNER)
		{
			if (oldself.multitool_forceskin) {
				//For map placed furnishings of this type
				oldself.multitool_woodcolor = oldself.multitool_forceskin;
			}
			
			if (oldself.multitool_woodcolor == 1) {
				e.skin = 1;
			} else if (oldself.multitool_woodcolor == 2) {
				e.skin = 2;
			} else if (oldself.multitool_woodcolor == 3) {
				e.skin = 3;
			} else {
				e.skin = 0;
			}
		}
		
		if (oldself.count == MTB64U_FURN_SCHDESKCHAIR
		|| oldself.count == MTB64U_FURN_SCHINTGRDESK)
		{
			if (oldself.multitool_forceskin) {
				//For map placed furnishings of this type
				oldself.multitool_woodcolor = oldself.multitool_forceskin;
			}
			
			if (oldself.multitool_woodcolor == 1) {
				if (oldself.multitool_roofcolor) {
					e.skin = 6; //Derelict with color
				} else {
					e.skin = 5; //Derelict
				}
			} else if (oldself.multitool_woodcolor == 2) {
				if (oldself.multitool_roofcolor) {
					e.skin = 8; //Rusted with color
				} else {
					e.skin = 7; //Rusted
				}
			}
		}
		
		
		e.multitool_woodcolor = 0;
		if (oldself.count >= MTB64_WOOD1 && oldself.count <= MTB64_WOOD1LAST) {
			if (oldself.multitool_woodcolor == -10) {
				print("team or player color\n");
				if (teamplay) {
					e.team = oldself.owner.team;
					e.colormap = 1024 + (oldself.owner.team - 1) * 17;
				} else {
					e.colormap = oldself.owner.colormap;
				}
				e.multitool_woodcolor = oldself.multitool_woodcolor;
			} else if (oldself.multitool_woodcolor >= 1) {
				//print("color\n");
				if (oldself.multitool_woodcolor == 16) {
					e.colormap = 1024; //White/0
				} else if (oldself.multitool_woodcolor == 17) {
					e.colormap = 1023; //Hack for black, shows up as diff cycle
				} else {
					//e.colormap = 1024 + oldself.multitool_woodcolor * 16; //Muted
					e.colormap = (1024 + oldself.multitool_woodcolor + oldself.multitool_woodcolor * 16); //Brighter, uses pants and shirt so not muted 
					//In the style of: self.colormap = (1024 + 10 + 10 * 16);
				}
			}
		}

		e.subordinate = cp1;
		if (e.count == MTB64_STAKES_WOOD1 || e.count == MTB64_BWIRE || e.count == MTB64U_BWIRE_X || e.count == MTB64U_BWIRE_O
		|| e.count == MTB64U_BWIRE || e.count == MTB64_FURN_BLKSMHFORGE
		|| e.count == MTB64_FURN_BLKSMHBELLOWS
		|| e.count == MTB64_FURN_GREEKPILLAR
		|| e.count == MTB64_FURN_GREEKPILLARM
		|| e.count == MTB64_FURN_ROMANCOLUMN
		|| e.count == MTB64_FURN_ROMANCOLUMNM
		|| e.count == MTB64_FURN_IRONMAIDEN
		|| e.count == MTB64_FURN_SPIKEDRACK
		|| e.count == MTB64_FURN_IMPALEMENTPOLE
		|| (e.count == MTB64_FURN_IRONBRAZIER && (!(myskipdynlight)))) {
			e.subordinate.subordinate = spkhrt;
			
			if (e.count == MTB64_FURN_BLKSMHFORGE) {
				e.subordinate.subordinate.subordinate = mtbdynlight;
				e.subordinate.subordinate.subordinate.subordinate = mtfrgburnent;
				e.subordinate.subordinate.subordinate.subordinate.subordinate = mtfrgthink;
				e.subordinate4 = mtfrgburnent;
			} else if (e.count == MTB64_FURN_IRONBRAZIER) {
					e.subordinate.subordinate.subordinate = mtbdynlight;
					//////Cannot contain and direct air like the forge can
					//e.subordinate.subordinate.subordinate.subordinate = mtfrgburnent;
					//e.subordinate.subordinate.subordinate.subordinate.subordinate = mtfrgthink;
					//e.subordinate4 = mtfrgburnent;
					//////Cannot contain and direct air like the forge can
			} else if (e.count == MTB64_FURN_IRONMAIDEN || e.count == MTB64_FURN_SPIKEDRACK) {
				e.subordinate.subordinate.subordinate = pr3tor;
				e.subordinate.subordinate.subordinate.subordinate = tp3tor;
				if (pr1hasbeenadded && pr1) {
				e.subordinate.subordinate.subordinate.subordinate.subordinate = pr1;
					if (tp2hasbeenadded && tp2) {
					e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;	
					}
				}
				
			} else if (e.count == MTB64_FURN_IMPALEMENTPOLE) {
				e.subordinate.subordinate.subordinate = spkhrttop;
				e.subordinate.subordinate.subordinate.subordinate = pr3tor;
				e.subordinate.subordinate.subordinate.subordinate.subordinate = tp3tor;
				if (pr1hasbeenadded && pr1) {
				e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr1;
					if (tp2hasbeenadded && tp2) {
					e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;	
					}
				}
				
			}
		} else if (e.count == MTB64U_FURN_LAMP_STREET
			|| e.count == MTB64U_FURN_LAMP_STREET2
			|| e.count == MTB64U_FURN_LAMP_STREET3
			|| e.count == MTB64U_FURN_LAMP_STREET4
			|| e.count == MTB64U_FURN_LAMP_STREET5) {
			e.subordinate.subordinate = mtbdynlight;
			e.subordinate.subordinate.subordinate = cbw1;
		} else if (e.count == MTB64_FURN_GIBBET) {
			e.subordinate.subordinate = pr3tor;
			e.subordinate.subordinate.subordinate = tp3tor;
			if (pr1hasbeenadded && pr1) {
			e.subordinate.subordinate.subordinate.subordinate = pr1;
				if (tp2hasbeenadded && tp2) {
				e.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;	
				}
			}
		} else if (myisbedneedspawn) {
			e.subordinate.subordinate = mybedspawnpt;
		}
		
		if (oldself.multitool_forceskin) {
			//For map placed furnishings
			//print("\nFORCESKIN\n");
			e.skin = oldself.multitool_forceskin;
		}
	} else if (self.count == -2) {
		//House (japanese)
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '232 232 72';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);

		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 512;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
			
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
		}
		
		e.subordinate = cbw1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == -3) {
		//Shrine
		entity cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cbw7, cbw8, cp1;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '320 320 200';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw2;
		self.origin = e.origin + '320 -320 200';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw3;
		self.origin = e.origin + '-320 320 200';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw4;
		self.origin = e.origin + '-320 -320 200';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		
		cbw5 = spawn();
		cbw6 = spawn();
		cbw7 = spawn();
		cbw8 = spawn();
		self = cbw5;
		self.origin = e.origin + '320 320 384';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw6;
		self.origin = e.origin + '320 -320 384';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw7;
		self.origin = e.origin + '-320 320 384';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		self = cbw8;
		self.origin = e.origin + '-320 -320 384';
		setorigin(self, self.origin);
		spawnfunc_item_health_large();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '304 0 368';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 800;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cbw1;
		e.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw7;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw8;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == -4) {
		//Dojo
		entity cbw1, cbw2, cbw3, cbw4, cp1;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		self = cbw1;
		self.origin = e.origin + '512 512 48';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		self = cbw2;
		self.origin = e.origin + '512 -512 48';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		self = cbw3;
		self.origin = e.origin + '-512 512 48';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		self = cbw4;
		self.origin = e.origin + '-512 -512 48';
		setorigin(self, self.origin);
		spawnfunc_item_armor_large();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1024;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cbw1;
		e.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	} else if (self.count == -615) {
		//Trap Floor
		entity cp1;
		entity d1, d2, d3, d4;
		d1 = spawn();
		d2 = spawn();
		d3 = spawn();
		d4 = spawn();
		
		d1.origin = e.origin + '0 232 8';
		d2.origin = e.origin + '232 0 8.000000';
		d3.origin = e.origin + '0 -232 8.000000';
		d4.origin = e.origin + '-232 0 8.000000';
		
		d1.model = "maps/buildables/door_rotdown_trap_wood1.bsp";
		d2.model = "maps/buildables/door_rotdown_trap_wood1a.bsp";
		d3.model = "maps/buildables/door_rotdown_trap_wood1b.bsp";
		d4.model = "maps/buildables/door_rotdown_trap_wood1c.bsp";
		d1.spawnflags = 64; //Axis of rotation X
		d2.spawnflags = 128;//Axis of rotation Y
		d3.spawnflags = 64; //Axis of rotation X
		d4.spawnflags = 128;//Axis of rotation Y
		d1.angles_y = 80;
		d2.angles_y = -80;
		d3.angles_y = -80;
		d4.angles_y = 80;
		
		d1.noise1 = "plats/medplat2.wav";
		d1.noise2 = "plats/medplat2.wav";
		d2.noise1 = "plats/medplat2.wav";
		d2.noise2 = "plats/medplat2.wav";
		d3.noise1 = "plats/medplat2.wav";
		d3.noise2 = "plats/medplat2.wav";
		d4.noise1 = "plats/medplat2.wav";
		d4.noise2 = "plats/medplat2.wav";
		d1.speed = 400;
		d1.wait = 4;
		d1.dmg = 10000;
		d1.message = "was crushed";
		d1.health = 2;
		//d1.doorsetsubordinate = 1;
		d4.speed = d3.speed = d2.speed = d1.speed;
		d4.wait = d3.wait = d2.wait = d1.wait;
		d4.dmg = d3.dmg = d2.dmg = d1.dmg;
		d4.message = d3.message = d2.message = d1.message;
		d4.health = d3.health = d2.health = d1.health;
		//d4.doorsetsubordinate = d3.doorsetsubordinate = d2.doorsetsubordinate = d1.doorsetsubordinate;
		
		self = d1;
		spawnfunc_multitool_func_door_rotating();
		
		self = d2;
		spawnfunc_multitool_func_door_rotating();	
		
		self = d3;
		spawnfunc_multitool_func_door_rotating();
		
		self = d4;
		spawnfunc_multitool_func_door_rotating();
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 4;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "null");
		setsize(self, '-64 -64 0', '64 64 32');
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = d1;
		e.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate = d3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = d4;
	} else if (self.count == -618) {
		//Trap Floor
		entity cp1;
		entity d1;
		d1 = spawn();
		
		d1.origin = e.origin + '0 0 8';
		d1.angles_y = -2;
		
		d1.spawnflags = 4; //This Door don't link! (...Cuz the dash don't be silent)
		
		d1.model = "maps/buildables/door_down_trap_iron1.bsp";
		
		d1.noise1 = "plats/medplat2.wav";
		//d1.noise2 = "plats/medplat2.wav";
		d1.speed = 2400;
		//d1.wait = 4;
		d1.dmg = 10000;
		d1.message = "was crushed by an iron grate";
		d1.health = 2;
		//d1.doorsetsubordinate = 1;
		self = d1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 - '0 0 488';
		
		//Some code to stop at spikes if you've allready built them
		local entity fndent;
		//Search for spikes, and now also any floor //(-610, -609, 1, //1 means search for all floors to collide with
		fndent = multitool_findspikebldbynumbers(-610, -609, 1, 1, e.origin, 504, d1.origin_z - 488, d1.origin_z);
		if (fndent != world) {
			//fndent.owner is the tower/building itself (the old "e"), like our e here
			//print(vtos(fndent.owner.origin),"O origin\n");
			//print(vtos(e.origin),"E origin\n\n");
			if (fndent.owner.origin_x == e.origin_x && fndent.owner.origin_y == e.origin_y) { //Same tile
				//print("Setting pos to higher as found spikes in our tile\n");
				self.pos2_z = fndent.origin_z + 28; //12+16
				if (fndent.owner && fndent.owner != world) {
					//Should be the tower
					fndent.owner.multitoolresetgrate = d1; //Will set pos2 back to self.pos2 = self.pos1 - '0 0 488' if destroyed
				}
			}
		} else {
			//Anything
			//print("Otherway\n");
			multitool_tracezspecial(d1.origin, '0 0 -488', MOVE_NORMAL);
			if (trace_ent == world) {
				if (trace_endpos_z < d1.origin_z)
				if (trace_endpos_z > d1.origin_z - 488)
				{
					self.pos2_z = trace_endpos_z+16;
				}
			} else if(trace_ent.multitool_hitbox) {
			 	if (trace_ent.multitool_hitbox != world)
				if (trace_ent.classname == "building")
				if (trace_ent.multitool_hitbox.classname == "bldhitbx")
				if (trace_endpos_z < d1.origin_z)
				if (trace_endpos_z > d1.origin_z - 488)
				{
					self.pos2_z = trace_endpos_z+16;
					trace_ent.multitoolresetgrate = d1;
					//print("set anything other resetgrate\n");
				}
			}

		}
		
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 4;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "null");
		setsize(self, '-64 -64 0', '64 64 32');
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = d1;
	} else if (self.count <= -600 && self.count > -1000) {
		//Floor
		entity cp1;
		entity spktop, spkhrt;
		if (e.count == -610 || e.count == -609) {
			spktop = spawn();
			spktop.classname = "building";
			spktop.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
			if (e.count == -610) {
				spktop.model = "maps/buildables/floor_iron_spikes-top.bsp";
			} else {
				spktop.model = "maps/buildables/floor_wood_stakes-top.bsp";
			}
			spktop.solid = SOLID_NOT;
			spktop.origin = e.origin;
			spktop.angles = e.angles;
		
			self = spktop;
			setorigin(self, self.origin);
			//gamemodel is goodenough
        		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        		self.solid = SOLID_NOT;
			
			////Hurt Trigger
			spkhrt = spawn();
			spkhrt.origin = e.origin;
			spkhrt.origin_z = spktop.origin_z + 128; //Move up
			spkhrt.solid = SOLID_TRIGGER;
			spkhrt.mins = '-248 -248 0';
			if (e.count == -610) {
				spkhrt.maxs = '248 248 64';
				spkhrt.dmg = 200;
			} else {
				spkhrt.maxs = '248 248 32';
				spkhrt.dmg = 100;
			}
			
			self = spkhrt;
			setorigin(self, self.origin);
			if (e.count == -610) {
				self.message2 = "was impaled by";
				self.message = "was impaled";
			} else {
				self.message2 = "was thrown onto a woooden stake by";
				self.message = "fell on a wooden stake";
			}
			
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_impale; //Our own version so we can set different deathtype
		
		}
		
		//////Some code to stop grates spikes and other floors if you've allready built them
			local entity fndent;
			//Search for only iron grate (-618, -618, 0,) //0 meaning don't search for all floors
			fndent = multitool_findspikebldbynumbers(-618, -618, 0, 1, e.origin, 504, e.origin_z + 64, e.origin_z + 488);
			if (fndent != world) {
				//fndent.owner is the tower/building
				//If we're the grate (-618), fndent.owner.subordinate.subordinate is the door (grate)
				//print(vtos(fndent.owner.origin),"O originFNdgrate\n");
				//print(vtos(e.origin),"E originFNdgrate\n\n");
				if (fndent.owner.origin_x == e.origin_x && fndent.owner.origin_y == e.origin_y) { //Same tile
				if (fndent.owner.subordinate.subordinate) {
				if (fndent.owner.subordinate.subordinate != world) {
					//print(fndent.owner.subordinate.subordinate.classname,"classname\n");
					//print(ftos(fndent.owner.subordinate.subordinate.pos2_z),"_pos2_z\n");
					
					if (fndent.owner.subordinate.subordinate.origin_z > e.origin_z) {
					if (fndent.owner.subordinate.subordinate.pos2_z < e.origin_z + 28)
					{
						fndent.owner.subordinate.subordinate.pos2_z = e.origin_z + 28;//12+16 (height of floor + grate)
						//print("changed z for grate\n");
						e.multitoolresetgrate = fndent.owner.subordinate.subordinate; //If we're -610 or -609 we'll change this back if destroyed
					}
					}
				}
				}
				}
			}
		//////End
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 4;	//Radius to search for it in.
		self.health = 19;
		self.max_health = 38;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "null");
		setsize(self, '-64 -64 0', '64 64 32');
		
		self = oldself;

		e.subordinate = cp1;
		
		if (e.count == -610 || e.count == -609) {
		e.subordinate.subordinate = spktop;
		e.subordinate.subordinate.subordinate = spkhrt;
		}
	} else if (self.count == 1001) {
		entity f1, cp1;
		//Flag Stuff
		f1 = spawn();
		self = f1;
		multitool_spawnflag('160 160 320', e, oldself);
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '192 192 192';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 352;	//Radius to search for it in.
		self.health = 300;
		self.max_health = 600;
		spawnfunc_multitool_controlpoint();
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = f1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == 1002 || self.count == 1031) {
		//Sheildgen
		entity cp1, shield, cbw1, brcntl;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 80;	//Radius to search for it in.
		self.health = 150;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		if (e.count == 1031) {
			shield.model = "maps/buildables/building_shieldgen_canopy_shield.bsp";
		} else {
			shield.model = "maps/buildables/building_shieldgen_shield.bsp";
		}
		shield.isquestionableblocktypemultitool = 1; //No building on here even if blocktype any (unless admin sets otherwise)
		shield.solid = SOLID_BSP;
		shield.origin = e.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	spawnfunc_misc_gamemodel(); //No dlight for this.
        	self.solid = SOLID_BSP;
        	self.movetype = MOVETYPE_PUSH;
		self.alpha = 1;
		self.subordinate4 = cp1; //So we can figure out our current team
		
		cbw1 = spawn();
		cbw1.realowner = cp1;
		cbw1.think = multitool_shieldgen_think;
		if (e.count == 1031) {
			cbw1.ammount2 = 8; //Amount of energy needed; (0.75 of top coverage, round up)
		} else {
			cbw1.ammount2 = 10; //Amount of energy needed;
		}
		cbw1.ammount = 1; //Default on
		cbw1.nextthink = time;
		cbw1.origin = e.origin;
		cbw1.subordinate4 = shield;
		self = cbw1;
		setorigin(self, self.origin);
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_shieldcontrol();
		self.subordinate4 = cbw1; //Shieldgen think
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
			shield.team = e.team;
			shield.colormap = e.colormap;
		} else {
			e.colormap = oldself.owner.colormap;
			shield.colormap = e.colormap;
		}

		e.subordinate = cp1;
		e.subordinate.subordinate = shield;
		e.subordinate.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate.subordinate = brcntl;
	} else if (self.count == 1003) {
		//House (Future)
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '128 128 80';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
			
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
		}
		
		e.subordinate = cbw1;
		e.subordinate.subordinate = cp1;
	} else if (self.count == 1004) {
		//arsenal
		entity d1, cbw1, cbw2, cbw3, cbw4, cbw5, cbw6, cbw7, cbw8, cbw9, cbw10, cbw11, cbw12, cp1;
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y + 90;
		self.model = "maps/buildables/door_down_med_steel1.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-416 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 416 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '416 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -416 8';
		}
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 40;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 - '0 0 104';
		self.angles_y = e.angles_y + 90;
		//print(ftos(self.angles_y),"\n");
		
		self = oldself;
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		cbw5 = spawn();
		cbw6 = spawn();
		cbw7 = spawn();
		cbw8 = spawn();
		cbw9 = spawn();
		cbw10 = spawn();
		cbw11 = spawn();
		cbw12 = spawn();
		
		self = cbw1;
		self.origin = e.origin + '-256.000000 -96.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw2;
		self.origin = e.origin + '-256.000000 96.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw3;
		self.origin = e.origin + '-96.000000 256.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw4;
		self.origin = e.origin + '96.000000 256.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw5;
		self.origin = e.origin + '256.000000 96.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw6;
		self.origin = e.origin + '256.000000 -96.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw7;
		self.origin = e.origin + '128.000000 -256.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw8;
		self.origin = e.origin + '-128.000000 -256.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		
		self = cbw9;
		self.origin = e.origin + '-224.000000 0.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		self = cbw10;
		self.origin = e.origin + '-160.000000 -160.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
		
		self = cbw11;
		self.origin = e.origin + '160.000000 -160.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_bullets();
		}
				
		self = cbw12;
		self.origin = e.origin + '224.000000 0.000000 8.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noammo) {
			spawnfunc_item_rockets();
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 14';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 512;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw7;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw8;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw9;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw10;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw11;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw12;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 1005) {
		//MilHangar
		
		float selectedtype;
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		selectedtype = 0;
		
		float frandvar;
		frandvar = random();
			if (frandvar > 0.80) {
				selectedtype = 1;
			} else if (frandvar > 0.25) {
				selectedtype = 2;
			} else {
				selectedtype = 0;
			}
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 2; //For this one we use 2 to allow mil vehicles too
		} else {
			if (selectedtype) {
				if (multitool_use_forgebuilding_materials(self.owner, "Cannot build military aircraft, Insufficent:", 1, 28, 0))
				{
					sufficentforgeparts = 2;
				} else if (multitool_use_forgebuilding_materials(self.owner, "Cannot build utility aircraft, Insufficent:", 1, 0, 0))
				{
					sufficentforgeparts = 1;
				}
			} else if (multitool_use_forgebuilding_materials(self.owner, "Cannot build utility aircraft, Insufficent:", 1, 0, 0)) {
					sufficentforgeparts = 1;
			}
		}
		
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		if not(autocvar_g_balance_multitoolutilitool_noaircraft) {
		 if not(autocvar_g_balance_utilitool_noaircraft) {
		  if (sufficentforgeparts) {
			frandvar = random();
			if (selectedtype == 1 && sufficentforgeparts == 2) {
				spawnfunc_vehicle_mraptor();
			} else if (selectedtype == 2 && sufficentforgeparts == 2) {
				spawnfunc_vehicle_raptor();
			} else {
				spawnfunc_vehicle_bumblebee();
			}
		  }
		 }
		}
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '256 256 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1152;	//Radius to search for it in.
		self.health = 150;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
	} else if (self.count == 1006) {
		//security building
		entity d1, d2, cbw1, cbw2, cbw3, cbw4, cbw5, pr2b, pr1, pr2, tp2, cp1;
		vector pr1origin;
		vector pr2borigin;
		
		pr1 = spawn();
		pr2 = spawn();
		pr2b = spawn();
		tp2 = spawn();
		tp2.origin = e.origin + '0 0 46';
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y + 90;
		self.model = "maps/buildables/door_down_med_steel1.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-752 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 752 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '752 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -752 8';
		}
		pr1origin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 40;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 - '0 0 104';
		self.angles_y = e.angles_y + 90;
		//print(ftos(self.angles_y),"\n");
		
		self = pr1;
		self.spawnflags = 0;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr1origin;
		setorigin(self, self.origin);
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = pr2;
		self.spawnflags = 2;
		self.mins = '-136 -136 0';
		self.maxs = '136 136 120';
		self.origin = e.origin + '0 0 8';
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();

		
		d2 = spawn();
		self = d2;
		self.solid = SOLID_BSP;
		self.angles_y = e.angles_y - 90;
		self.model = "maps/buildables/door_down_med_steel1.bsp";
		//print(ftos(e.angles_y), " angles\n");
		if (e.angles_y == 0) {
			self.origin = e.origin + '-304 0 8';
		} else if (e.angles_y == -90) {
			self.origin = e.origin + '0 304 8';
		} else if (e.angles_y == -180 || e.angles_y == 180) {
			self.origin = e.origin + '304 0 8';
		} else if (e.angles_y == 90) {
			self.origin = e.origin + '0 -304 8';
		}
		pr2borigin = self.origin;
		setorigin(self, self.origin);
		self.dmg = 10000;
		self.health = 20;
		self.spawnflags = 4;
		self.speed = 40;
		self.wait = 1;
		spawnfunc_multitool_func_door();
		self.pos2 = self.pos1 - '0 0 104';
		self.angles_y = e.angles_y - 90;
		
		self = pr2b;
		self.spawnflags = 2;
		self.mins = '-80 -80 0';
		self.maxs = '80 80 120';
		self.origin = pr2borigin;
		setorigin(self, self.origin);
		self.enemy = tp2;
		self.prisonisfrombuilding = 1; //For origin searches
		self.prisonisfrombuilding_owner = e; //For origin searches
		spawnfunc_trigger_prison();
		
		self = oldself;
		
		
		
		cbw1 = spawn();
		cbw2 = spawn();
		cbw3 = spawn();
		cbw4 = spawn();
		cbw5 = spawn();
		
		self = cbw1;
		self.origin = e.origin + '-256.000000 -96.000000 196.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw2;
		self.origin = e.origin + '-256.000000 96.000000 196.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw3;
		self.origin = e.origin + '-96.000000 256.000000 196.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		self = cbw4;
		self.origin = e.origin + '96.000000 256.000000 196.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		
		self = cbw5;
		self.origin = e.origin + '256.000000 96.000000 196.000000';
		setorigin(self, self.origin);
		if not(autocvar_g_balance_multitoolutilitool_noweapons) {
			self.ammo_nails = 15;
			spawnfunc_weapon_carbine();
		}
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '192 192 192';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 512;	//Radius to search for it in.
		self.health = 250;
		self.max_health = 500;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d2.teamlockallow = 1;
		d2.teamlockent = cp1;
		
		//Make a chain so we can delete later
		e.subordinate = d1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr2b;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = d2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr1;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = pr2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = tp2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cp1;
	
	} else if (self.count == 1007) {
		//TankPad -- 1 tank
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build tank, Insufficent:", 2, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		
		if not(autocvar_g_balance_multitoolutilitool_notanks) {
		 if not(autocvar_g_balance_utilitool_notanks) {
		  if (sufficentforgeparts) {
			frandvar = random();
			if (frandvar > 0.875) {
				spawnfunc_vehicle_tankll48();
			} else if (frandvar > 0.75) {
				spawnfunc_vehicle_tankll40();
			} else if (frandvar > 0.625) {
				spawnfunc_vehicle_tankll37();
			} else if (frandvar > 0.5) {
				self.spawnflags |= 16384; //So we spawn 17mm secondary
				spawnfunc_vehicle_tankll24_heat();
			} else if (frandvar > 0.375) {
				spawnfunc_vehicle_tankll24_raa();
			} else if (frandvar > 0.25) {
				self.spawnflags |= 16384; //So we spawn 17mm secondary
				spawnfunc_vehicle_tankll24_aa();
			} else if (frandvar > 0.125) {
				spawnfunc_vehicle_tankll24_ai();
			} else {
				spawnfunc_vehicle_tankll24();
			}
		  }
		 }
		}
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '144 144 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
	} else if (self.count == 1008) {
		//Stockpile
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.think = multitool_stockpilethink;
		self.count = 576; //Search radius
		self.nextthink = time;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '144 144 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate  = cbw1;
	} else if (self.count == 1009) {
		//Ammodepot
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.think = multitool_ammodepotthink;
		self.count = 400; //Search radius
		self.nextthink = time;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		cbw1.subordinate4 = cp1; //So we know what team we are on
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		cbw1.subordinate4 = cp1; //So we can figure out our current team
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
	} else if (self.count == 1010) {
		//Oiltank
		entity cp1;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		if (teamplay)
		{
			if (self.team == COLOR_TEAM1) {
				capacity_crude_team1 = capacity_crude_team1 + OIL_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM2) {
				capacity_crude_team2 = capacity_crude_team2 + OIL_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM3) {
				capacity_crude_team3 = capacity_crude_team3 + OIL_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM4) {
				capacity_crude_team4 = capacity_crude_team4 + OIL_TANK_CAPACITY;
			} else {
				capacity_crude_world = capacity_crude_world + OIL_TANK_CAPACITY;
			}
		} else {
			capacity_crude_world = capacity_crude_world + OIL_TANK_CAPACITY;
		}
		
		
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '400 400 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 512;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1011) {
		//energytank
		entity cp1;
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		if (teamplay)
		{
			if (self.team == COLOR_TEAM1) {
				capacity_energy_team1 = capacity_energy_team1 + ENERGY_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM2) {
				capacity_energy_team2 = capacity_energy_team2 + ENERGY_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM3) {
				capacity_energy_team3 = capacity_energy_team3 + ENERGY_TANK_CAPACITY;
			} else if (self.team == COLOR_TEAM4) {
				capacity_energy_team4 = capacity_energy_team4 + ENERGY_TANK_CAPACITY;
			} else {
				capacity_energy_world = capacity_energy_world + ENERGY_TANK_CAPACITY;
			}
		} else {
			capacity_energy_world = capacity_energy_world + ENERGY_TANK_CAPACITY;
		}
		
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '400 400 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 512;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1012) {
		//Apartments (Future)
		entity cbw1, cbw2, cbw4, cbw3, cbw5, cbw6, cbw7, cbw8, cbw9, cbw10, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '448 448 80';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		
		cbw2 = spawn();
		self = cbw2;
		self.origin = e.origin + '-448 -448 80';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		cbw3 = spawn();
		self = cbw3;
		self.origin = e.origin + '448 -448 240';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		cbw4 = spawn();
		self = cbw4;
		self.origin = e.origin + '-448 448 240';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		///
		cbw5 = spawn();
		self = cbw5;
		self.origin = e.origin + '448 448 400';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
		
		cbw6 = spawn();
		self = cbw6;
		self.origin = e.origin + '-448 -448 400';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		cbw7 = spawn();
		self = cbw7;
		self.origin = e.origin + '448 -448 560';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		cbw8 = spawn();
		self = cbw8;
		self.origin = e.origin + '-448 448 560';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;	
		//
		cbw9 = spawn();
		self = cbw9;
		self.origin = e.origin + '448 -448 720';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;
			
		cbw10 = spawn();
		self = cbw10;
		self.origin = e.origin + '-448 448 720';
		setorigin(self, self.origin);
			if (oldself.owner.team == COLOR_TEAM1) {
				spawnfunc_info_player_team1();
			} else if (oldself.owner.team == COLOR_TEAM2) {
				spawnfunc_info_player_team2();
			} else if (oldself.owner.team == COLOR_TEAM3) {
				spawnfunc_info_player_team3();
			} else if (oldself.owner.team == COLOR_TEAM4) {
				spawnfunc_info_player_team4();
			} else {
				spawnfunc_info_player_deathmatch();
			}
			self.spawnpointisofbuildable = 1;	
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		
		local float myhousingamnt;
		myhousingamnt = multitool_getmyhousingamnt(e.count);
		if(myhousingamnt) multitool_addinithousingcapacity (self, myhousingamnt);
		
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 512';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
			
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
			cbw1.cntrlowner = cp1;
			cbw2.cntrlowner = cp1;
			cbw3.cntrlowner = cp1;
			cbw4.cntrlowner = cp1;
			cbw5.cntrlowner = cp1;
			cbw6.cntrlowner = cp1;
			cbw7.cntrlowner = cp1;
			cbw8.cntrlowner = cp1;
			cbw9.cntrlowner = cp1;
			cbw10.cntrlowner = cp1;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw6;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw7;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw8;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw9;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw10;
	} else if (self.count == 1013 || self.count == 1014 || self.count == 1038) {
		//Flac or missile turret
		float sufficentforgeparts;
		entity cp1;
		entity t1;
		
		sufficentforgeparts = 0;
		
		//Futuristic is very simple and efficent! 1 or the other forgepiece
		if (self.owner == world && autocvar_g_balance_utilitool_noautoturretsforworldpedestals >= 1) {
			sufficentforgeparts = 0;
		} else if (self.count == 1013 || self.count == 1038) {
			//Flac
			//player, failure message, ForgepieceNail, ForgepieceRocket, ForgepieceCell
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 1, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		} else { //1014
			//player, failure message, ForgepieceNail, ForgepieceRocket, ForgepieceCell
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turrets, Insufficent:", 0, 1, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		if (self.owner == world && autocvar_g_balance_utilitool_noautoturretsforworldpedestals > 0 &&
		autocvar_g_balance_utilitool_noautoturretsforworldpedestals < 1) {
			if (random() < autocvar_g_balance_utilitool_noautoturretsforworldpedestals) {
		  		sufficentforgeparts = 0;
		  	}
		}
		
		
		t1 = spawn();
		
		t1.realowner = self.owner;
		if (teamplay) {
			t1.team = self.owner.team;
		}
		t1.turret_scale_range = 4;
		
		self = t1;
		if (e.count == 1013) {
			self.multitool_reparableturret = 1;
			if (sufficentforgeparts) {
				spawnfunc_turret_flac();
			}
			self.origin = e.origin + '0 0 448';
		} else if (e.count == 1038) {
			self.multitool_reparableturret = 1;
			if (sufficentforgeparts) {
				spawnfunc_turret_autoshlac();
			}
			self.origin = e.origin + '0 0 32';
		} else { //1014
			self.multitool_reparableturret = 1;
			if (sufficentforgeparts) {
				spawnfunc_turret_mlrs();
			}
			self.origin = e.origin + '0 0 256';
		}
		self.angles_y = e.angles_y + 90;
		setorigin(self, self.origin);
		t1.realowner = oldself.owner;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = t1;
	} else if (self.count == 1015) {
		//Oil Pump
		entity cp1, cbw1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		//This adds to oil tanks each min
		cbw1 = spawn();
		self = cbw1;
		self.think = multitool_oilpump_think;
		self.ammount = 0; //Global/Team by default, not to local tank
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		self.subordinate5 = e;
		self.cnt = 3 * random();
		
		//See if pump should pump anything
		entity tcr;
		tcr = spawn();
		tcr.origin = e.origin;
		traceline(tcr.origin + '0 0 64', tcr.origin - '0 0 10000', MOVE_WORLDONLY, tcr);
		
		float hitmaterial;
		hitmaterial = W_EvaluateMaterialHit();
		
		if ((hitmaterial == 1) || (hitmaterial == 2)) {
			//print("Metal\n");
			cbw1.cnt = 0;
		} else if (hitmaterial == 5) {
			//print("Concrete\n");
			cbw1.cnt = 0;
		} else if ((hitmaterial == 3) || (hitmaterial == 4)) {
			//print("Stone and Brick\n");
			cbw1.cnt = cbw1.cnt * 0.25;
		} else if (hitmaterial == 8) {
			//print("Wood and Bark\n");
			cbw1.cnt = 0;
		} else if (hitmaterial == 7) {
			//print("Dirt Etc\n");
			//Do nothing
		} else if (hitmaterial == 9) {
			//print("Sheetrock\n");
			cbw1.cnt = 0;
		} else {
			//print("NotMetal\n");
			//Do nothing
		}
		//print(ftos(cbw1.cnt), " amount of oil\n");
		remove(tcr);
		//End evaluation of material
		
		self = oldself;
		
		if (cbw1.cnt) {
			//Can drill down? Look for oil
			local float addoilmultip;
			local float fmtcnt;
			addoilmultip = 0;
			addoilmultip = mutitool_oilpump_lookforoil(e.origin, 4096);	
			if not(addoilmultip) {
				if(clienttype(cp1.realowner) == CLIENTTYPE_REAL) {
					sprint(cp1.realowner, "No oil was found\n");
				}
				cbw1.cnt = 0;
			} else if (cbw1.cnt == -3) {
				if(clienttype(cp1.realowner) == CLIENTTYPE_REAL) {
					sprint(cp1.realowner, "Pump must not be subsumed competely by oil\n");
				}
				cbw1.cnt = 0;
			} else {
				//We found oil, multiply current setting with for oil extraction rate
					//print(ftos(cbw1.cnt),"Oil-origcnt\n");
					//print(ftos(addoilmultip),"Oil-addoilmultip\n");
				cbw1.cnt = cbw1.cnt * addoilmultip;
				if(clienttype(cp1.realowner) == CLIENTTYPE_REAL) {
					fmtcnt = cbw1.cnt; //Not going to trust you, QC, to not implicitly convert during formatting
					fmtcnt = (floor(fmtcnt*10))*0.1;
					sprint(cp1.realowner, sprintf("Oil extraction rate: ^x100 %.1f^7\n", fmtcnt));
					//sprint(cp1.realowner, strcat("Oil extraction rate: ^x100", ftos(fmtcnt),"^7\n"));
				}
			}
		}
		
		if (cbw1.cnt) {
			if (teamplay) {
				e.team = oldself.owner.team;
				e.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				e.colormap = oldself.owner.colormap;
			}
		}

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
	} else if (self.count == 1016 || self.count == 1017 || self.count == 1018) {
		//ChemicalPlant
		entity cp1, cbw1;
		entity l1, l2, l3, l4;
		entity l5, l6, l7, l8;
		entity cbw2;
		
		cbw2 = spawn();
		self = cbw2;
		self.classname = "lclchemplant";
		self.islocalresourceprovider = 1; //So we can be searched for;
		self.resource_fuel_local = 0; // Start empty Ofcourse // 1000; //Test
		self.resource_rockets_local = 0;
		self.origin = e.origin;
		setorigin(self, self.origin);
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		if (e.count == 1017) {
			//Chemicalplant 2
			self.origin = e.origin + '768 768 16';
		} else if (e.count == 1018) {
			//Chemicalplant 3
			self.origin = e.origin + '128 128 16';
		} else {
			//Chemicalplant 1
			self.origin = e.origin + '0 0 0';
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1200;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		cbw2.subordinate4 = cp1; //So we can figure out our team or owner easily
		
		//This adds to energy tanks each min
		cbw1 = spawn();
		self = cbw1;
		self.think = multitool_chemicalplant_think;
		self.ammount = 0; //Default global distrib
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		self.subordinate5 = e; //So we can find origin to search for local energy
		self.subordinate9 = cbw2; //So we know where to add resources
		if (e.count == 1017) {
			//Chemicalplant3
			//A ladder
			vector ol;
			vector il;
			if (e.angles_y == 0) {
				//print("0 netradiant\n");
				//0
				ol = '0 -80 0';
				il = '984 0 0';
			} else if (e.angles_y == -90) {
				//print("90 netradiant\n");
				//90
				ol = '-80 0 0';
				il = '0 -984 0';
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				//print("180 netradiant\n");
				//180
				ol = '0 80 0';
				il = '-984 0 0';
			} else if (e.angles_y == 90) {
				//print("270 netradiant\n");
				//270
				ol = '80 0 0';
				il = '0 984 0';
			}
			
			l1 = spawn();
			l2 = spawn();
			l1.solid = l2.solid = SOLID_TRIGGER;
			l1.mins = l2.mins = '-16 -16 0';
			l1.maxs = '16 16 1216';
			l2.maxs = '16 16 976';
			
			//Outside ladder
			self = l1;
			self.origin = e.origin + ol;
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			//Inside ladder
			self = l2;
			self.origin = e.origin + il;
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
		} else if (e.count == 1018) {
			//Chemicalplant3
			//A ladder
			l1 = spawn();
			l2 = spawn();
			l3 = spawn();
			l4 = spawn();
			l5 = spawn();
			l6 = spawn();
			l7 = spawn();
			l8 = spawn();
			l1.solid = l2.solid = l3.solid = l4.solid = SOLID_TRIGGER;
			l1.mins = l2.mins = l3.mins = l4.mins = '-16 -16 0';
			l1.maxs = l2.maxs = l3.maxs = l4.maxs = '16 16 1488';
			
			l5.solid = l6.solid = l7.solid = l8.solid = SOLID_TRIGGER;
			l5.mins = l6.mins = l7.mins = l8.mins = '-16 -16 0';
			l5.maxs = l6.maxs = l7.maxs = l8.maxs = '16 16 1488';
			
			//Outside tanks
			self = l1;
			self.origin = e.origin + '512 40 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l2;
			self.origin = e.origin + '40 -512 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l3;
			self.origin = e.origin + '-512 -40 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l4;
			self.origin = e.origin + ' -40 512 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			//Inside tanks
			self = l5;
			self.origin = e.origin + '432 512 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l6;
			self.origin = e.origin + '512 -432 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l7;
			self.origin = e.origin + '-432 -512 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
			
			self = l8;
			self.origin = e.origin + '-512 432 0';
			setorigin(self, self.origin);
			spawnfunc_func_ladder();
		}
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		if (e.count == 1017) {
		e.subordinate.subordinate.subordinate = l1;
		e.subordinate.subordinate.subordinate.subordinate = l2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw2;
		} else if (e.count == 1018) {
		e.subordinate.subordinate.subordinate = l1;
		e.subordinate.subordinate.subordinate.subordinate = l2;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = l3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l4;
		
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l5;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l6;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l7;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = l8;
		e.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate = cbw2;
		} else {
		e.subordinate.subordinate.subordinate = cbw2;
		}
		
		if (numberoflocalchemplants < 0) {
			numberoflocalchemplants = 1; //Just in case less than 0 for some reason
		} else {
			numberoflocalchemplants = numberoflocalchemplants + 1;
		}
	} else if (self.count == 1019) {
		//MunitionsFactory
		entity cp1, cbw1, cbw2, shield, brcntl;
		
		cbw2 = spawn();
		self = cbw2;
		self.classname = "lclmuntnsftry";
		self.islocalresourceprovider = 1; //So we can be searched for;
		self.resource_nails_local = 0; // Start empty Ofcourse // 1000; //Test
		self.resource_shells_local = 0;
		self.origin = e.origin;
		setorigin(self, self.origin);
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.colormap = e.colormap;
		self.origin = e.origin + '0 0 784';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1200;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 400;
		spawnfunc_multitool_controlpoint();
		
		cbw2.subordinate4 = cp1; //So we can figure out our team or owner easily
		
		//This adds to munitions each min
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin;
		self.think = multitool_factory_think;
		self.ammount = 0; //Default global distrib
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		self.subordinate5 = e; //So we can find origin to search for local energy
		self.subordinate9 = cbw2; //So we know where to add resources
		//
		
		
		//Visual indication of local distribution (default off ofcourse)
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		
		shield.model = "maps/buildables/building_factory1_lock.bsp";
		
		shield.solid = SOLID_BSP;
		shield.origin = cp1.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	self.alpha = -1; //Making sure
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        	self.solid = SOLID_NOT; //Off by default
        	self.movetype = MOVETYPE_NONE;
		self.alpha = -1; //Default is global distibution so we will be unseen
		
		
		
		brcntl = spawn();
		brcntl.origin = cp1.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_munitionsfactorycontrol();
		self.ammount = 0;
		
		self = oldself;
		
		//brcntl.subordinate5 = e; //Model
		brcntl.subordinate7 = shield; //oilpumpcontrol needs to know the locallock indicating model
		brcntl.subordinate4 = cbw1; //so we can control state
		//
		
		
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		e.subordinate.subordinate.subordinate.subordinate = shield;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = brcntl;
		
		if (numberoflocalmunitionsfactories < 0) {
			numberoflocalmunitionsfactories = 1; //Just in case less than 0 for some reason
		} else {
			numberoflocalmunitionsfactories = numberoflocalmunitionsfactories + 1;
		}
	} else if (self.count == 1020) {
		//Raised sentry tower
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '0 0 448';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1021) {
		//Furnace
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '128 128 64';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 320;	//Radius to search for it in.
		self.health = 50;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		numberoffurnaces = numberoffurnaces + 1;
	} else if (self.count == 1022) {
		//OfficeBuilding (Future)
		entity cp1;	
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '320 320 1312';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
	} else if (self.count == 1023) {
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build helicopter, Insufficent:", 1, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		//FireSupression (Future)
		entity cp1;
		entity cbw1, cbw2, cbw3, cbw4;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '0 0 352';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 20;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
			cbw1 = spawn();
			self = cbw1;
			self.origin = e.origin + '384 384 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_deluge();
			
			cbw2 = spawn();
			self = cbw2;
			self.origin = e.origin + '-384 -384 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_deluge();
			
			cbw3 = spawn();
			self = cbw3;
			self.origin = e.origin + '-384 384 32';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			self.vehicle_droptype = 1;
			spawnfunc_mountedgun_deluge();
		
			cbw4 = spawn();
			self = cbw4;
			self.origin = e.origin + '0 0 784';
			setorigin(self, self.origin);
			self.angles_y = e.angles_y + 90;
			
			if not(autocvar_g_balance_multitoolutilitool_noaircraft) {
		 	 if not(autocvar_g_balance_utilitool_noaircraft) {
			  if (sufficentforgeparts) {
				if (random() > 0.25) {
					//Fire marshall's helicopter
					local float temprand;
					temprand = random();
					if (temprand > 0.5) {
						self.colormap = (1024 + 4 + 4 * 16);
					} else if (temprand > 0.25) {
						self.colormap = (1024 + 12 + 12 * 16);
					} else if (temprand > 0.15) {
						self.colormap = (1024 + 1 + 1 * 16);
					} else {
						self.colormap = (1024 + 14 + 14 * 16);
					}
					self.spawnflags = 32; //Add watercannon (deluge gun)
				}
				self.vehicle_droptype = 1;
				spawnfunc_vehicle_sparrow();
			  }
			 }
			}
			
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		e.subordinate2a = cbw2;
		e.subordinate3 = cbw3;
	} else if (self.count == 1024) {
		//OfficeBuilding2 (Future)
		entity cp1;	
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '320 320 1312';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 1536;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
	} else if (self.count == 1025) {
		//Tensionwire tower
		entity cp1, l1;
		
		l1 = spawn();
		
		//A ladder
		self = l1;
		self.solid = SOLID_TRIGGER;
		self.mins = '-16 -16 -64';
		self.maxs = '16 16 2240';
		self.origin = e.origin;
		setorigin(self, self.origin);
		spawnfunc_func_ladder();
		self = oldself;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '80 80 1856';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 384;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate.subordinate = l1;
	} else if (self.count == 1026) {
		//OfficeBuilding (Future)
		entity cp1;	
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		
		self.origin = e.origin + '320 320 1312';
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 300;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		if (teamplay) {
			e.team = oldself.owner.team;
			e.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			e.colormap = oldself.owner.colormap;
		}
		
		//Make a chain so we can delete later
		e.subordinate = cp1;
	} else if (self.count == 1027) {
		//APCPad
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build vehicle, Insufficent:", 1, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		
		if not(autocvar_g_balance_multitoolutilitool_nomiscgroundvehicle) {
		 if not(autocvar_g_balance_utilitool_nomiscgroundvehicle) {
		  if (sufficentforgeparts) {
			if (multitool_findnearbldngtype(e.origin, 384, 1023, TRUE)) {
				//If we are within 384 qunits (inches) of firesuppression(1023) or
				//it's scaffold (TRUE), spawn a firesuppression APC instead
				spawnfunc_vehicle_lightapc_deluge();
			} else if (multitool_findnearbldngclass(e.origin, 1024, BUILDINGCLASS_MILITARY)) {
				//We're near military buildings (within 1024 qu), build armed
				frandvar = random();
				if (frandvar > 0.95) {
					spawnfunc_vehicle_lightapc_m134();
				} else if (frandvar > 0.90) {
					spawnfunc_vehicle_lightapc_gau19();
				} else if (frandvar > 0.80) {	
					spawnfunc_vehicle_lightapc_browning50();
				} else if (frandvar > 0.70) {
					spawnfunc_vehicle_lightapc_t17mm();
				} else if (frandvar > 0.50) {
					spawnfunc_vehicle_lightapc_autonex();
				} else if (frandvar > 0.30) {
					spawnfunc_vehicle_lightapc_grail();
				} else {
					spawnfunc_vehicle_lightapc_shlac();
				}
		 	} else {
				//Not near anything, thus unarmed
				spawnfunc_vehicle_lightapc();
			}
		  }
		 }
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '144 144 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
	} else if (self.count == 1028) {
		//Covered Garage
		entity cp1;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '256 256 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 384;	//Radius to search for it in.
		self.health = 10;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1029) {
		//BulldozerPad
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build tanks, Insufficent:", 2, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		
		if not(autocvar_g_balance_multitoolutilitool_nomiscgroundvehicle) {
		 if not(autocvar_g_balance_utilitool_nomiscgroundvehicle) {
		  if (sufficentforgeparts) {
			spawnfunc_vehicle_bulldozer();
		  }
		 }
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '144 144 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 280;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
	} else if (self.count == 1030) {
		//Local Energy Battery
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.classname = "lclenrgybatt";
		self.islocalresourceprovider = 1; //So we can be searched for;
		self.current_energy_local = 0; // Start empty Ofcourse // 1000; //Test
		self.capacity_energy_local = ENERGY_BATTERY_CAPACITY;
		self.origin = e.origin;
		setorigin(self, self.origin);
		
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '104 104 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		cbw1.subordinate4 = cp1; //So we can figure out our team or owner easily

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
				
		if (numberoflocalenergybatterys < 0) {
			numberoflocalenergybatterys = 1; //Just in case less than 0 for some reason
		} else {
			numberoflocalenergybatterys = numberoflocalenergybatterys + 1;
		}
	} else if (self.count == 1032) {
		//Local Oil Tank
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.classname = "lcloiltank";
		self.islocalresourceprovider = 1; //So we can be searched for;
		self.current_crude_local = 0; // Start empty Ofcourse // 1000; //Test
		self.capacity_crude_local = OIL_TANK_SMALL_CAPACITY;
		self.origin = e.origin;
		setorigin(self, self.origin);
		
		
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '104 104 16';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;
		
		cbw1.subordinate4 = cp1; //So we can figure out our team or owner easily

		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
				
		if (numberoflocaloiltanks < 0) {
			numberoflocaloiltanks = 1; //Just in case less than 0 for some reason
		} else {
			numberoflocaloiltanks = numberoflocaloiltanks + 1;
		}
	} else if (self.count == 1033) {
		//OilDistribution Control
		entity cp1, brcntl, shield;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		
		
		
		//Visual indication of local distribution (default off ofcourse)
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		
		shield.model = "maps/buildables/building_solarpanel_lock.bsp";
		
		shield.solid = SOLID_BSP;
		shield.origin = e.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	self.alpha = -1; //Making sure
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        	self.solid = SOLID_NOT; //Off by default
        	self.movetype = MOVETYPE_NONE;
		self.alpha = -1; //Default is global distibution so we will be unseen
		
		
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_oilpumpcontrol();
		self.ammount = 0;
		
		self = oldself;
		
		brcntl.subordinate5 = e; //Model
		brcntl.subordinate7 = shield; //oilpumpcontrol needs to know the locallock indicating model

		e.subordinate = cp1;
		e.subordinate.subordinate = brcntl;
		e.subordinate.subordinate.subordinate = shield;
	} else if (self.count == 1034) {
		//Chemical Distribution Control
		entity cp1, brcntl, shield;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		
		
		
		//Visual indication of local distribution (default off ofcourse)
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		
		shield.model = "maps/buildables/building_solarpanel_lock.bsp";
		
		shield.solid = SOLID_BSP;
		shield.origin = e.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	self.alpha = -1; //Making sure
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        	self.solid = SOLID_NOT; //Off by default
        	self.movetype = MOVETYPE_NONE;
		self.alpha = -1; //Default is global distibution so we will be unseen
		
		
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-64 -64 0';
		brcntl.maxs = '64 64 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_chemicalcontrol();
		self.ammount = 0;
		
		self = oldself;
		
		brcntl.subordinate5 = e; //Model
		brcntl.subordinate7 = shield; //oilpumpcontrol needs to know the locallock indicating model

		e.subordinate = cp1;
		e.subordinate.subordinate = brcntl;
		e.subordinate.subordinate.subordinate = shield;
		
	} else if (self.count == 1035) {
		//Combat-Suit Pad
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forvehicles) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build suit, Insufficent:", 1, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		float frandvar;
		entity cbw1, cp1;
		cbw1 = spawn();
		self = cbw1;
		self.origin = e.origin + '0 0 32';
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		self.vehicle_droptype = 1;
		
		if not(autocvar_g_balance_multitoolutilitool_nosuits) {
		 if not(autocvar_g_balance_utilitool_nosuits) {
		  if (sufficentforgeparts) {
				frandvar = random();
				if (frandvar > 0.5) {
					spawnfunc_vehicle_mechbst();
				} else {
					spawnfunc_vehicle_mechmax();
				}
		  }
		 }
		}
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '48 48 32';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
	} else if (self.count == 1120 || self.count == 1121 || self.count == 1122
		|| self.count == 1123 || self.count == 1124 || self.count == 1125
		|| self.count == 1126 || self.count == 1127
		|| self.count == 1130 || self.count == 1131) {
		
		float sufficentforgeparts;
		sufficentforgeparts = 0;
		
		if (autocvar_g_balance_multitoolutilitool_ignoreforgeparts_forenterableturrets) {
			sufficentforgeparts = 1;
		} else {
			if (multitool_use_forgebuilding_materials(self.owner, "Cannot build turret, Insufficent:", 1, 0, 0))
			{
				sufficentforgeparts = 1;
			}
		}
		
		
		//Mannable Turret 
		entity cp1, cbw1, cbw2;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		
		if (e.count == 1130 || e.count == 1131) {
			self.origin = e.origin + '112 112 0';
		} else {
			self.origin = e.origin + '64 64 0';
		}
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		//This adds Turrets of mannable nature
		cbw2 = spawn();
		cbw1 = spawn();
		self = cbw1;
		self.team = oldself.owner.team;
		
		if (e.count == 1130 || e.count == 1131) {
			self.origin = e.origin + '0 0 480';
		} else {
			self.origin = e.origin + '0 0 32';
		}
		
		cbw2.origin = self.origin;
		setorigin(self, self.origin);
		self.angles_y = e.angles_y + 90;
		
		if (sufficentforgeparts) {
			if (e.count == 1121) {
				spawnfunc_vehicle_turretll20_grail();
			} else if (e.count == 1122 || e.count == 1130) {
				spawnfunc_vehicle_turretll20_t17mm();
			} else if (e.count == 1123 || e.count == 1131) {
				spawnfunc_vehicle_turretll20_aa();
			} else if (e.count == 1124) {
				spawnfunc_vehicle_turretll20_raa();
			} else if (e.count == 1125) {
				spawnfunc_vehicle_turretll20_ai();
			} else if (e.count == 1126) {
				spawnfunc_vehicle_turretll20_heat();
			} else if (e.count == 1127) {
				spawnfunc_vehicle_turretll20_cannon();
			} else { //1120
				spawnfunc_vehicle_turretll20();
			}
		
			if (teamplay) {
				self.tur_head.colormap = self.colormap = 1024 + (oldself.owner.team - 1) * 17;
			} else {
				self.tur_head.colormap = self.colormap = oldself.owner.colormap;
			}
		
			//This enforces colormap
			self = cbw2;
			self.think = multitool_mannableturret_think;
			self.nextthink = time;
			setorigin(self, self.origin);
			self.subordinate4 = cp1; //So we can figure out our current team
			self.subordinate5 = cbw1;
		}

		
		self = oldself;

		e.subordinate = cp1;
		e.subordinate2 = cbw1;
		e.subordinate.subordinate = cbw2;
	} else if (self.count == 1510) {
		//Solar Panel
		entity cp1, cbw1, brcntl, shield;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '64 64 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 128;	//Radius to search for it in.
		self.health = 100;
		self.max_health = 200;
		spawnfunc_multitool_controlpoint();
		
		//This adds to energy tanks each min
		cbw1 = spawn();
		self = cbw1;
		self.think = multitool_solarpanel_think;
		self.ammount = 0; //Global/Team by default, not to local batt
		self.nextthink = time + 60;
		self.subordinate4 = cp1; //So we can figure out our current team
		self.subordinate5 = e; //So we can find origin to trace to sky
		
		
		//Visual indication of local distribution (default off ofcourse)
		shield = spawn();
		shield.classname = "building";
		//not setting accptcrrdbldspltr
		
		shield.model = "maps/buildables/building_solarpanel_lock.bsp";
		
		shield.solid = SOLID_BSP;
		shield.origin = e.origin;
		shield.angles = e.angles;
	
		self = shield;
		setorigin(self, self.origin);
		//gamemodel is good for this as this needs to change sometimes
        	self.alpha = -1; //Making sure
		if (autocvar_g_balance_multitoolutilitool_noforcedlight) { spawnfunc_misc_gamemodel(); } else { spawnfunc_misc_gamemodel_dlight(); }
        	self.solid = SOLID_NOT; //Off by default
        	self.movetype = MOVETYPE_NONE;
		self.alpha = -1; //Default is global distibution so we will be unseen
		
		
		
		brcntl = spawn();
		brcntl.origin = e.origin;
				
		brcntl.solid = SOLID_TRIGGER;
		brcntl.mins = '-72 -72 0';
		brcntl.maxs = '72 72 128';
			
		self = brcntl;
		setorigin(self, self.origin);
				
		spawnfunc_multitool_trigger_solarpanelcontrol();
		self.subordinate4 = cbw1; //solarpanel think
		
		self = oldself;
		
		brcntl.subordinate7 = shield; //solarpanel think needs to know the locallock indicating model


		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = brcntl;
		e.subordinate.subordinate.subordinate.subordinate = shield;
	} else if (self.count == 1520 || self.count == 1521 || self.count == 1522 || self.count == 1523
	|| oldself.count == 1530 || oldself.count == 1531 || oldself.count == 1532
	|| oldself.count == 1533 || oldself.count == 1534 || oldself.count == 1535
	|| oldself.count == 1536 || oldself.count == 1537 || oldself.count == 1542
	|| oldself.count == 1543) {
		//Wall - FenceMil - Concrete
		entity cp1;
		entity cbw1, cbw2;
		entity cbw3, cbw4;
			
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}

		if (oldself.count == 1521 || oldself.count == 1530 || oldself.count == 1531 || oldself.count == 1532
		|| oldself.count == 1533 || oldself.count == 1536) {
			self.origin = e.origin + '0 0 256';
		} else if (oldself.count == 1534 || oldself.count == 1535 || oldself.count == 1537
		|| oldself.count == 1542 || oldself.count == 1543) {
			self.origin = e.origin + '0 0 384';
		} else {
			self.origin = e.origin;
		}
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 32;	//Radius to search for it in.
		self.health = 5;
		self.max_health = 10;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		if (oldself.count == 1521 || oldself.count == 1530 || oldself.count == 1531 || oldself.count == 1532
		|| oldself.count == 1533 || oldself.count == 1534 || oldself.count == 1535 || oldself.count == 1536
		|| oldself.count == 1537 || oldself.count == 1542 || oldself.count == 1543) {
			setsize(self, '-44 -44 0', '44 44 38');
		} else {
			setsize(self, '-64 -64 0', '64 64 38');
		}
		
		self = oldself;
		
		if (oldself.count == 1521 || oldself.count == 1531 || oldself.count == 1536 || oldself.count == 1537) {
			cbw1 = spawn();
			cbw2 = spawn();
			cbw3 = spawn();
			cbw4 = spawn();
			self = cbw1;
			self.angles_y = e.angles_y;
			cbw2.angles_y = e.angles_y;
			cbw3.angles_y = e.angles_y;
			cbw4.angles_y = e.angles_y;
			
				self.mins = '-256 -24 -24';
				self.maxs = '256 24 24';
				cbw2.mins = self.mins;
				cbw2.maxs = self.maxs;
				if (oldself.count == 1537) {
					self.origin = e.origin + '0 256 520';
					cbw2.origin = e.origin + '0 -256 520';
				} else if (oldself.count == 1536) {
					self.origin = e.origin + '0 256 392';
					cbw2.origin = e.origin + '0 -256 392';
				} else {
					self.origin = e.origin + '0 256 264';
					cbw2.origin = e.origin + '0 -256 264';
				}

				cbw3.mins = '-24 -256 -24';
				cbw3.maxs = '24 256 24';
				cbw4.mins = cbw3.mins;
				cbw4.maxs = cbw3.maxs;
				
				if (oldself.count == 1537) {
					cbw3.origin = e.origin + '256 0 520';
					cbw4.origin = e.origin + '-256 0 520';
				} else if (oldself.count == 1536) {
					cbw3.origin = e.origin + '256 0 392';
					cbw4.origin = e.origin + '-256 0 392';
				} else {
					cbw3.origin = e.origin + '256 0 264';
					cbw4.origin = e.origin + '-256 0 264';
				}

			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
			self = cbw2;
			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
			self = cbw3;
			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
			self = cbw4;
			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
		} else {
			cbw1 = spawn();
			cbw2 = spawn();
			self = cbw1;
			self.angles_y = e.angles_y;
			cbw2.angles_y = e.angles_y;
			if (e.angles_y == 0 || e.angles_y == -180 || e.angles_y == 180) {
				self.mins = '-256 -24 -24';
				self.maxs = '256 24 24';
				cbw2.mins = self.mins;
				cbw2.maxs = self.maxs;
				if (oldself.count == 1534 || oldself.count == 1535
				|| oldself.count == 1542 || oldself.count == 1543) {
					self.origin = e.origin + '0 64 392';
					cbw2.origin = e.origin + '0 -64 392';
				} else {
					self.origin = e.origin + '0 64 264';
					cbw2.origin = e.origin + '0 -64 264';
				}
			} else if (e.angles_y == -90 || e.angles_y == 90) {
				self.mins = '-24 -256 -24';
				self.maxs = '24 256 24';
				cbw2.mins = self.mins;
				cbw2.maxs = self.maxs;
				if (oldself.count == 1534 || oldself.count == 1535
				|| oldself.count == 1542 || oldself.count == 1543) {
					self.origin = e.origin + '64 0 392';
					cbw2.origin = e.origin + '-64 0 392';
				} else {
					self.origin = e.origin + '64 0 264';
					cbw2.origin = e.origin + '-64 0 264';
				}
			}
			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
			self = cbw2;
			setorigin(self, self.origin);
			self.dmg = 30;
			self.message2 = "was thrown onto razor wire by";
			self.message = "died on razor wire";
			spawnfunc_trigger_hurt();
			self.touch = multitool_trigger_hurt_touch_cut;
		}
		
		self = oldself;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = cbw1;
		e.subordinate.subordinate.subordinate = cbw2;
		if (oldself.count == 1521 || oldself.count == 1531
		|| oldself.count == 1536 || oldself.count == 1537) {
		e.subordinate.subordinate.subordinate.subordinate = cbw3;
		e.subordinate.subordinate.subordinate.subordinate.subordinate = cbw4;
		}
	} else if (self.count == 1524 || self.count == 1546) {
		//Fence Mil Moving Gate
		entity cp1;
		entity d1;
		
		//e.mins = '-32 -32 0';
		//e.maxs = '32 32 64';
		//setsize(e, '-32 -32 0', '32 32 64');
		//print(e.model," here\n");
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		
		////Not a block
		//if (oldself.multitool_flipblock == 1) {
		//	self.origin_z = self.origin_z - 64; //Move Down (center though, not 128 down)
		//}
		
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 0;	//Radius to search for it in.
		self.health = 30;
		self.max_health = 70;
		spawnfunc_multitool_controlpoint();
		//setmodel(self, "null");
		setmodel(self, "models/marker.md3");
		setsize(self, '-2 -2 0', '2 2 64');
		
		
		
		//A door
		d1 = spawn();
		self = d1;
		self.solid = SOLID_BSP;
	
			//32 is from center
			self.objcthitmaterial = 2; //Metal
			if (e.angles_y == 0) {
				self.origin = e.origin + '0 32 0';
			} else if (e.angles_y == -90) {
				self.origin = e.origin + '32 0 0';
			} else if (e.angles_y == -180 || e.angles_y == 180) {
				self.origin = e.origin + '0 -32 0';
			} else if (e.angles_y == 90) {
				self.origin = e.origin + '-32 0 0';
			}
			
			if (e.count == 1524) {
				self.model = "maps/buildables/door_side_fencemil_gate_large.bsp";
			} else {
				self.model = "maps/buildables/door_side_steel_gate_large.bsp";
			}

			
		
		setorigin(self, self.origin);
		self.dmg = 0; //Dont want to hurt vehicles in an instant (and even this set to 10 does that..)
		//self.health = 20;
		//self.spawnflags = 4;
		self.spawnflags = 2048; //NeedUse
		self.speed = 40;
		self.wait = 1;
		self.angles_y = -120;
		self.doorsetsubordinate = 1;
		self.doorreducedtriggerset = 1;
		self.doorsettriggersize = 1;
		self.doortriggermins = '-48 -48 0';
		self.doortriggermaxs = '48 48 128';
		spawnfunc_multitool_func_door();
		//self.pos2 = self.pos1 - '0 0 104';
		//self.angles_y = e.angles_y - 90;
		self.angles_y = e.angles_y;
		makevectors(self.angles);
		self.pos2 = self.pos1 - (v_forward * 224);
		//print(ftos(self.angles_y),"\n");
		
		
		
		self = oldself;
		
		d1.teamlockallow = 1;
		d1.teamlockent = cp1;
		d1.multitool_doorframeent = e;
		//We do not rename the classname, as it is used in the rotating door code
		//Instead we set these 2 vars:
		d1.accptcrssbwstklkbld = 1; //Accept crossbowbolts like building
		d1.accptlikebuilding = 1;   //Accept other things like building (mostly used in Axe, Chainsaw etc code): IE: Be treated like a classname "building" in some ways
		//Also we would like to have blood splatter if someone got a bullet through them:
		d1.accptcrrdbldspltr = BUILDING_ACCPTCRRDBLDSPLTR;
		
		e.subordinate = cp1;
		e.subordinate.subordinate = d1;
	} else if (self.count == 1548 || self.count == 1549) {
		//Wall - Concrete - Berm
		entity cp1;
		
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}

		if (oldself.count == 1548) {
			//Tall
			self.origin = e.origin + '0 0 384';
		} else {
			self.origin = e.origin + '0 0 256';
		}

		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 32;	//Radius to search for it in.
		self.health = 5;
		self.max_health = 10;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		setsize(self, '-44 -44 0', '44 44 38');
		
		self = oldself;
		
		e.subordinate = cp1;
	} else if (self.count == 1550) {
		//Wall - Tank Pyramid
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '0 0 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 15;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	} else if (self.count == 1551) {
		//Wall - Tank Pier
		entity cp1;
				
		//ControlPointStuff
		cp1 = spawn();
		self = cp1;
		self.owner = e;
		//print(etos(oldself.owner), "os owner plyr\n");
		self.realowner = oldself.owner;
		self.team = oldself.owner.team;
		self.skin = 4;
		if (teamplay) {
			self.colormap = 1024 + (oldself.owner.team - 1) * 17;
		} else {
			self.colormap = oldself.owner.colormap;
		}
		self.origin = e.origin + '192 192 0';
		fbspot = self.origin; //Flagbase will be moved here if it exists
		fbsrad = 256;	//Radius to search for it in.
		self.health = 15;
		self.max_health = 30;
		spawnfunc_multitool_controlpoint();
		setmodel(self, "models/marker.md3");
		
		self = oldself;

		e.subordinate = cp1;
	}
	
	
	entity hitbox;
	hitbox = spawn();
	hitbox.realowner = self.owner;
	hitbox.team = self.owner.team;
	//print(etos(self.owner),"\n");
	
	if ((oldself.count >= 570 && oldself.count <= 579)
	|| (multitool_isbuildingcurtainstone(oldself.count))
	|| (multitool_isbuildingcastlestoneextra(oldself.count))
	|| (oldself.count == 6) || (oldself.count == 8)
	|| (oldself.count == 7) || (oldself.count == 10)
	|| (oldself.count == 27)
	|| (oldself.count >= 660 && oldself.count <= 669)
	|| (oldself.count >= 10700 && oldself.count <= 10799)) {
		//Castle wall colors set
		//print("castlecolors6\n");
		if (oldself.multitool_castlecolor) {
			//print("here for color\n");
			hitbox.multitool_castlecolor = oldself.multitool_castlecolor;
		}
		
		if (oldself.count == 616 && oldself.multitool_woodcolor) {
			//print("here for color\n");
			hitbox.multitool_woodcolor = oldself.multitool_woodcolor;
		}
	}
	
	//Hitboxes
	
	if (oldself.count == 520 || oldself.count == 523) {
		//Hedge (shorter than other walls and buildings)
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 132', 0, hitpoints);
	} else if (oldself.count == 521 || oldself.count == 522) {
		//Hedge "Tower" (shorter than other walls and buildings)
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 132', 0, hitpoints);
	} else if (oldself.count == 530 || oldself.count == 533) {
		//Brick wall
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 148', 0, hitpoints);
	} else if (oldself.count == 531 || oldself.count == 532) {
		//Brick wall "tower"
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 148', 0, hitpoints);
	} else if (oldself.count == 1520 || oldself.count == 1522 || oldself.count == 1523) {
		//FenceMil
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 256', 0, hitpoints);
	} else if (oldself.count == 1524 || oldself.count == 1546 || oldself.count == 10709 || oldself.count == 10710) {
		//FenceMil Moving Gate
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 256', 0, hitpoints);
	} else if (oldself.count == 1521 || oldself.count == 1531 || oldself.count == 1536 || oldself.count == 1537) {
		//FenceMil "Tower" and Concrete wall
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 256', 0, hitpoints);
	} else if (oldself.count == 1530 || oldself.count == 1532 || oldself.count == 1533
		|| oldself.count == 1534 || oldself.count == 1535 || oldself.count == 1542
		|| oldself.count == 1543 || oldself.count == 1548 || oldself.count == 1549) {
		//Concrete wall 
		multitool_spawn_hitbox(e, hitbox, '-48 -48 0', '48 48 256', 0, hitpoints);
	} else if (oldself.count == 1012) {
		//Apartments
		multitool_spawn_hitbox(e, hitbox, '-512 -512 0', '512 512 1600', 0, hitpoints);
	} else if (oldself.count == 1015) {
		//Oil Pump
		multitool_spawn_hitbox(e, hitbox, '-32 -32 0', '32 32 300', 0, hitpoints);
	} else if (oldself.count == 1016 || oldself.count == 1017 || oldself.count == 1018) {
		multitool_spawn_hitbox(e, hitbox, '-512 -512 0', '512 512 600', 0, hitpoints);
	} else if (oldself.count == 1019) {
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 600', 0, hitpoints);
	} else if (oldself.count == 1120 || oldself.count == 1121 || oldself.count == 1122
		|| oldself.count == 1123 || oldself.count == 1124 || oldself.count == 1125
		|| oldself.count == 1126 || oldself.count == 1127) {
		multitool_spawn_hitbox(e, hitbox, '-48 -48 0', '48 48 70', 0, hitpoints);
	} else if (oldself.count == 110 || oldself.count == 111 || oldself.count == 112
		|| oldself.count == 1110 || oldself.count == 1111 || oldself.count == 1112
		|| oldself.count == 1113 || oldself.count == 1114 || oldself.count == 1115
		|| oldself.count == 1116 || oldself.count == 1117 || oldself.count == 1118) {
		//Point defense guns
		multitool_spawn_hitbox(e, hitbox, '-16 -16 0', '16 16 64', 0, hitpoints);
	} else if (oldself.count == 1130 || oldself.count == 1131 || oldself.count == 1020) {
		multitool_spawn_hitbox(e, hitbox, '-48 -48 0', '48 48 480', 0, hitpoints);
	} else if (oldself.count == 1025) {
		//Tensionwire tower
		multitool_spawn_hitbox(e, hitbox, '-348 -348 0', '348 348 2560', 0, hitpoints);
	} else if (oldself.count == 1021) {
		//Furnace
		multitool_spawn_hitbox(e, hitbox, '-160 -160 0', '160 160 256', 0, hitpoints);
	} else if (oldself.count == 1022 || oldself.count == 1026) {
		//OfficeTower1
		multitool_spawn_hitbox(e, hitbox, '-512 -512 0', '512 512 2368', 0, hitpoints);
	} else if (oldself.count == 1023) {
		//FireSupression
		multitool_spawn_hitbox(e, hitbox, '-512 -512 0', '512 512 784', 0, hitpoints);
	} else if (oldself.count == 1024) {
		//OfficeTower2
		multitool_spawn_hitbox(e, hitbox, '-512 -512 0', '512 512 2368', 0, hitpoints);
	} else if (oldself.count == 1036) {
		//Hammerforge
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 256', 0, hitpoints);
	} else if (oldself.count == 1037) {
		//Observation Tower
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 832', 0, hitpoints);
	} else if (oldself.count == 20) {
		//Tree sentry
		multitool_spawn_hitbox(e, hitbox, '-128 -128 0', '128 128 400', 0, hitpoints);
	} else if (oldself.count == 21) {
		//SiegeWorkshop
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '256 256 400', 0, hitpoints);
	} else if (oldself.count == 27) {
		//CrusaderStronghold
		multitool_spawn_hitbox(e, hitbox, '-256 -256 0', '256 256 1024', 0, hitpoints);
	} else if (oldself.count == 501 || oldself.count == 502) {
		//Field or vineyard
		multitool_spawn_hitbox(e, hitbox, '-16 -16 0', '16 16 16', 0, hitpoints);
	} else if (oldself.count == 503 || oldself.count == 1502) {
		//Recruitment Post
		multitool_spawn_hitbox(e, hitbox, '-32 -32 0', '32 32 64', 0, hitpoints);
	} else if (oldself.count == 1501) {
		//Greenhouse
		multitool_spawn_hitbox(e, hitbox, '-128 -128 0', '128 128 128', 0, hitpoints);
	} else if (oldself.count == 565 || oldself.count == 577 || oldself.count == 585
		|| oldself.count == 568 || oldself.count == 579 || oldself.count == 587
		|| oldself.count == 10700 || oldself.count == 10701 || oldself.count == 10702
		|| oldself.count == 10703 || oldself.count == 10704 || oldself.count == 10705
		|| oldself.count == 10706 || oldself.count == 10707
		|| oldself.count == 1540 || oldself.count == 1541) {
		//Interior walls
		multitool_spawn_hitbox(e, hitbox, '-260 -260 0', '260 260 400', 0, hitpoints);
	} else if (oldself.count >= 640 && oldself.count < 700) {
		//Bridges
		multitool_spawn_hitbox(e, hitbox, '-256 -256 -1400', '256 256 16', 0, hitpoints);
	} else if (oldself.count >= 1640 && oldself.count < 1700) {
		//Futuristic Bridges
		multitool_spawn_hitbox(e, hitbox, '-256 -256 -3074', '256 256 16', 0, hitpoints);
	} else if ((oldself.count >= 700 && oldself.count <= MTB64BOUNDLAST)
	|| (oldself.count >= MTB64UBOUNDFIRST && oldself.count <= MTB64UBOUNDLAST)) {
		//64x64 blocks
		
		if (oldself.count == MTB64U_DOOR_R_STEEL
		|| oldself.count == MTB64U_DOOR_R_PLAIN
		|| oldself.count == MTB64U_DOOR_R_PLAIN2
		|| oldself.count == MTB64U_DOOR_R_GLASS || oldself.count == MTB64_DOOR_R_WOOD
		|| oldself.count == MTB64_DOOR_R_JWOOD || oldself.count == MTB64_DOOR_R_FWOOD || oldself.count == MTB64_DOOR_R_IRONBAR
		|| oldself.count == MTB64_FITTEDWINDOW_CASTLE_ALOOP
		|| oldself.count == MTB64_FITTEDWINDOW_CASTLE_SWALL
		|| oldself.count == MTB64_FITTEDWINDOW_WINDOW
		|| oldself.count == MTB64U_FITTEDWINDOW_STEELSLIT
		|| oldself.count == MTB64U_FITTEDWINDOW_STEELPLATE
		|| oldself.count == MTB64U_FITTEDWINDOW_CWALL
		|| oldself.count == MTB64U_FITTEDWINDOW_UWINDOW) {
			//Doors are 2x blocks tall
			if (oldself.multitool_flipblock == 1) {
				//print("here\n");
				multitool_spawn_hitbox(e, hitbox, '-64 -64 -128', '64 64 0', 0, hitpoints); //Z offset for flipped block
			} else {
				multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 128', 0, hitpoints);
			}
		} else if (oldself.count == MTB64U_FURN_BSCKCABINETTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORT1
		|| oldself.count == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOP2
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1
		|| oldself.count == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2) {
			//These are abit taller
			if (oldself.multitool_flipblock == 1) {
				//print("here\n");
				multitool_spawn_hitbox(e, hitbox, '-64 -64 -96', '64 64 0', 0, hitpoints); //Z offset for flipped block
			} else {
				multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 96', 0, hitpoints);
			}
		} else {
			if (oldself.multitool_flipblock == 1) {
				//print("here\n");
				multitool_spawn_hitbox(e, hitbox, '-64 -64 -64', '64 64 0', 0, hitpoints); //Z offset for flipped block
			} else {
				multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 64', 0, hitpoints);
			}
		}
		
		if (oldself.multitool_roofcolor) {
			//print("here for color\n");
			hitbox.multitool_roofcolor = oldself.multitool_roofcolor;
		}
		
		if (oldself.multitool_flamecolor) {
			//print("here for color\n");
			hitbox.multitool_flamecolor = oldself.multitool_flamecolor;
		}
		
		if (oldself.multitool_woodcolor) {
			//print("here for color\n");
			hitbox.multitool_woodcolor = oldself.multitool_woodcolor;
		}
		
		if (oldself.multitool_marblecolor) {
			//print("here for color\n");
			hitbox.multitool_marblecolor = oldself.multitool_marblecolor;
		}
		
		if (oldself.multitool_castlecolor) {
			//print("here for color\n");
			hitbox.multitool_castlecolor = oldself.multitool_castlecolor;
		}
		
		if (oldself.multitool_sstonecolor) {
			//print("here for color\n");
			hitbox.multitool_sstonecolor = oldself.multitool_sstonecolor;
		}
		
		hitbox.multitool_doorcenter = oldself.multitool_doorcenter; //So we will set proper door frame
	} else if (oldself.count <= -600 && oldself.count > -1000) {
		//floors
		multitool_spawn_hitbox(e, hitbox, '-64 -64 -24', '64 64 12', 0, hitpoints);
	} else {
		multitool_spawn_hitbox(e, hitbox, '-64 -64 0', '64 64 400', 0, hitpoints);
	}
	hitbox.count = self.count;
	e.multitool_hitbox = hitbox;
	//print(etos(e), "e \n");
	//print(etos(hitbox), "hbx \n");
	//print(etos(e.multitool_hitbox), "ehbx \n");
	
	
	////////////////////////////////////////////////////////////
	//////Set some things on building from spawnscaffold
	if (self.spwnmnstrondth) {
		e.spwnmnstrondth = self.spwnmnstrondth;
		e.spwnmnstrondth_monster = self.spwnmnstrondth_monster;
		e.spwnmnstrondth_amnt = self.spwnmnstrondth_amnt;
		e.spwnmnstrondth_respawns = self.spwnmnstrondth_respawns;
		e.spwnmnstrondth_propagate = self.spwnmnstrondth_propagate;
		e.spwnmnstrondth_propagateinf = self.spwnmnstrondth_propagateinf;
	}
	if (self.readscrollondth) {
		e.readscrollondth = self.readscrollondth;
		e.readscrollondth_spell = self.readscrollondth_spell;
		e.readscrollondth_amnt = self.readscrollondth_amnt;
		e.readscrollondth_lvl = self.readscrollondth_lvl;
		e.readscrollondth_genincrease = self.readscrollondth_genincrease;
		e.readscrollondth_propagate = self.readscrollondth_propagate;
		e.readscrollondth_propagateinf = self.readscrollondth_propagateinf;
		e.readscrollondth_propagateonly = self.readscrollondth_propagateonly;
		e.readscrollondth_propagatespell = self.readscrollondth_propagatespell;
		e.readscrollondth_ontake = self.readscrollondth_ontake;
		e.readscrollondth_ontake_amnt = self.readscrollondth_ontake_amnt;
		e.readscrollondth_onput = self.readscrollondth_onput;
		e.readscrollondth_onput_amnt = self.readscrollondth_onput_amnt;
		e.readscrollondth_onsearch = self.readscrollondth_onsearch;
		e.readscrollondth_onsearch_amnt = self.readscrollondth_onsearch_amnt;
		e.readscrollondth_notdth = self.readscrollondth_notdth;
	}
	if (self.trapondth) {
		e.trapondth = self.trapondth;
		e.trapondth_trap = self.trapondth_trap;
		e.trapondth_amnt = self.trapondth_amnt;
		e.trapondth_ontake = self.trapondth_ontake;
		e.trapondth_ontake_amnt = self.trapondth_ontake_amnt;
		e.trapondth_onput = self.trapondth_onput;
		e.trapondth_onput_amnt = self.trapondth_onput_amnt;
		e.trapondth_onsearch = self.trapondth_onsearch;
		e.trapondth_onsearch_amnt = self.trapondth_onsearch_amnt;
		e.trapondth_notdth = self.trapondth_notdth;
		e.trapondth_dirstyle = self.trapondth_dirstyle;
		e.trapondth_onlyonce = self.trapondth_onlyonce;
	}
	if (self.xplodondth) {
		e.xplodondth = self.xplodondth;
		e.xplodondth_type = self.xplodondth_type;
	}
	e.noanimdroppeditems = self.noanimdroppeditems;
	e.inventory_permitems = self.inventory_permitems;
	e.isweak = self.isweak;
	e.multitool_forcesolidtype = self.multitool_forcesolidtype;
	e.multitool_forcenotdragable = self.multitool_forcenotdragable;
	////////////////////////////////////////////////////////////
	
	
	spamsound (self, CH_SHOTS, "object/impact_stone_1.ogg", VOL_BASE * 0.35, ATTN_NORM); //Not 0.25: Heavier Firing Pin
	
	//Check if it's in/touching lava and needs to burn
	if (multitool_iswooden(e.multitool_hitbox.count)) {
		if (multitool_CheckIsTouchingLava(e.multitool_hitbox, e))
		{
			Fire_AddDamage(e.multitool_hitbox, world, autocvar_g_balance_nukelayer_fire2_damage *
			200, 200, 
			WEP_FIREBALL);
			
			e.multitool_hitbox.fire_intensity = 5;
		} else if (ambient_temperature >= 300) {
			if (pointcontents(e.origin) == CONTENT_WATER) {
				//Do nothing
			} else if (ambient_temperature_entitywithinlimits(e)) {
				Fire_AddDamage(e.multitool_hitbox, world, autocvar_g_balance_nukelayer_fire2_damage *
				200, 200, 
				WEP_FIREBALL);
			}
		}
	}
	
	multitool_moveflagbase(fbspot, fbsorg, fbsrad);
	
	if (orphancontrolpointreaper != 1) {
		//print("spawning reaper --------------xxxxxxxxxxxxxxxxxxx\n");
		local entity otherself, reaper;
		otherself = self;
		reaper = spawn();
		self = reaper;
		spawnfunc_multitool_orphancontrolpointreaper();
		self = otherself;
	}
	
	//if (e.multitool_forcesolidtype) {
	//	print(etos(e), ":Entity  ",ftos(e.solid)," EndSolidtype for multitool_forcesolidtype\n");
	//}
	
	self.think = func_null;
	self.nextthink = 0;
	remove_safely(self);
}

void multitool_updateammo()
{
	if (self.alpha != -1) {
		self.vehicle_ammo1_current = self.multitool_ammocurrent;
		self.vehicle_ammo1_max = self.multitool_ammomax;
		self.vehicle_ammo2_current = self.multitool_ammocurrentr;
		self.vehicle_ammo2_max = self.multitool_ammocurrentc; //Yes, using max as current for cell ammo. (for display)
	}
}

void multitool_thirdpartycallupdateammoon(entity player)
{
	entity oldentself;
	
	if (player)
	if (player != world)
	if (!player.vehicle)
	if (!player.peaceful)
	if (player.weapon == WEP_MULTITOOL || player.weapon == WEP_UTILITOOL) 
	{
		oldentself = self;
		self = player;
		multitool_updateammo();
		self = oldentself;
	}
}

float multitool_tooclose(entity player)
{
	if (autocvar_g_balance_multitool_freebuild >= 4) {
		//Freebuild 4 allows you to skip this restriction
		return FALSE;
	}
	
	if (autocvar_g_balance_multitool_freebuild_blocks >= 4) {
		if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
			//Freebuild_blocks 4 allows you to skip this restriction
			return FALSE;
		}
	}
		
		
	entity f;
	
	if (
	(autocvar_g_balance_multitool_freebuild >= 2)
	|| 
	((
	(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
	|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
	) && (autocvar_g_balance_multitool_freebuild_blocks >= 2))
	)
	{
		//Freebuild 2 allows you to skip this restriction
		//Do Nothing instead of the operation below
	} else {
	 /////////////////////////////////////
	 /////////////////START///////////////
	 f = findradius(player.origin, autocvar_g_balance_multitool_minradius);
  	 while(f)
  	 {
	 	if (f.classname == "bldhitbx")
	 	{
	 		//print(ftos(player.team), "team\n");
    	 		if (teamplay) {
	 			if (player.team != f.team) {
					if (autocvar_g_balance_multitool_ignorebuild_blocks
					&&
					((f.count >= 700 && f.count <= MTB64BOUNDLAST)
					|| (f.count >= MTB64UBOUNDFIRST && f.count <= MTB64UBOUNDLAST))
					) {
						//Ignore blocks (Otherwise you have to capture every little piece)
						//print("Ignoring block\n");
					} else {
						if not(multitool_isfurniture(f.count)) {
	 						//print(ftos(f.team), "fteam\n");
	 						sprint(player, "Too close to enemy team's building\n");
	 						return TRUE;
						}
					}
 				}
			} else if (player != f.realowner) {
				if (autocvar_g_balance_multitool_ignorebuild_blocks
				&&
				((f.count >= 700 && f.count <= MTB64BOUNDLAST)
				|| (f.count >= MTB64UBOUNDFIRST && f.count <= MTB64UBOUNDLAST))
				) {
					//Ignore blocks (Otherwise you have to capture every little piece)
					//print("Ignoring block\n");
				} else {
					if not(multitool_isfurniture(f.count)) {
	 					sprint(player, "Too close to another player's building\n");
	 					return TRUE;
					}
				}
	 		}
	 	}
    	 	f = f.chain;
  	 }
	 /////////////////END///////////////
	 ///////////////////////////////////
	}
	
	
	if (teamplay)
	{
		////////////////////////////
		if (
		(autocvar_g_balance_multitool_freebuild >= 2)
		|| 
		((
		(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
		) && (autocvar_g_balance_multitool_freebuild_blocks >= 2))
		)
		{
			if (autocvar_g_balance_multitool_minradiusflag > 0) {
				if (autocvar_g_balance_multitool_minradiusflag > 128) {
					f = findradius(player.origin, 128);
				} else {
					f = findradius(player.origin, (autocvar_g_balance_multitool_minradiusflag * 0.25));
				}
			} else {
				//As you wish
				f = findradius(player.origin, autocvar_g_balance_multitool_minradiusflag);	
			}
		} else {
			f = findradius(player.origin, autocvar_g_balance_multitool_minradiusflag);
		}
		////////////////////////////
		
  		while(f)
  		{
			if (f.classname == "item_flag_team_base"
			|| f.classname == "onslaught_generator")
			{
				if (player.team != f.team) {
					sprint(player, "Too close to enemy team's flag\n");
					return TRUE;
				}	
			}
	    		f = f.chain;	
		}
	}
	
	//Blocks or Fill wall
	if ((
	(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
	|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
	)
	|| (player.multitool_setting == 564 || player.multitool_setting == 576 || player.multitool_setting == 584
	|| player.multitool_setting == 1538)) {
	  if (teamplay)
	  {
		f = findradius(player.origin, 128);
  		while(f)
  		{
			if (f.classname == "item_flag_team_base"
			|| f.classname == "onslaught_generator")
			{
					
					sprint(player, "Too close to flag or generator\n");
					return TRUE;
			}
	    		f = f.chain;	
		}
	  }
	}
	
	if (player.multitool_setting == 20) {
		//Treehouse
		f = findradius(player.origin, 260);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if (f.amnt == 20) {
					//amnt is only found on scaffolds in this code
					//its just like count
					sprint(player, "Can't place a treehouse ontop of a treehouse scaffold\n");
					return TRUE;
				}
				 
    				if (f.count == 20) {
					sprint(player, "Can't place a treehouse ontop of another treehouse\n");
					return TRUE;
				}
			}
    			f = f.chain;
  		}
		
		local entity ftreeent;
		ftreeent = multitool_findneartree(player.origin, TREETOP_SENTRY_RADIUS);
		if (ftreeent != world) {
			local vector ffindorigin;
			ffindorigin = ftreeent.origin;
			ffindorigin_z = ftreeent.origin_z + ftreeent.maxs_z + TREETOP_SENTRY_ZADD;

			f = findradius(ffindorigin, 260);
  			while(f)
  			{
				if (f.classname == "bldhitbx" || f.classname == "building")
				{
					if (f.amnt == 20) {
						//amnt is only found on scaffolds in this code
						//its just like count
						sprint(player, "Can't place a treehouse ontop of a treehouse scaffold in tree\n");
						return TRUE;
					}
					 
    					if (f.count == 20) {
						sprint(player, "Can't place a treehouse ontop of another treehouse in tree\n");
						return TRUE;
					}
				}
    				f = f.chain;
  			}
		
		}	
	}
	
	if (player.multitool_setting == 501 || player.multitool_setting == 502 || player.multitool_setting == 1501) {
		//Farms, Vineyards, etc
		f = findradius(player.origin, 260);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if (f.amnt == 501 || f.amnt == 502 || f.amnt == 1501) {
					//amnt is only found on scaffolds in this code
					//its just like count
					sprint(player, "Can't place a field ontop of a field scaffold\n");
					return TRUE;
				}
				 
    				if (f.count == 501 || f.count == 502 || f.count == 1501) {
					sprint(player, "Can't place a field ontop of another field\n");
					return TRUE;
				}
			}
    			f = f.chain;
  		}	
	}
	
	if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
	|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
		//Blocks, code like: //Farms
		f = findradius(player.origin, 16);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if ((f.amnt >= 700 && f.amnt <= MTB64BOUNDLAST)
				|| (f.amnt >= MTB64UBOUNDFIRST && f.amnt <= MTB64UBOUNDLAST))
				{
					//amnt is only found on scaffolds in this code
					//its just like count
					sprint(player, "Can't place a bock in a block scaffold\n");
					return TRUE;
				}
				 
    				//if ((f.count >= 700 && f.count <= MTB64BOUNDLAST )
				//|| (f.count >= MTB64UBOUNDFIRST && f.count <= MTB64UBOUNDLAST )) {
				//	sprint(player, "Can't place a block in another block\n");
				//	return TRUE;
				//}
			}
    			f = f.chain;
  		}	
	}
	
	if (player.multitool_setting == 565  || player.multitool_setting == 577 || player.multitool_setting == 585
	|| player.multitool_setting == 568  || player.multitool_setting == 579 || player.multitool_setting == 587
	|| player.multitool_setting == 10700 || player.multitool_setting == 10701 || player.multitool_setting == 10702
	|| player.multitool_setting == 10703 || player.multitool_setting == 10704 || player.multitool_setting == 10705
	|| player.multitool_setting == 10706 || player.multitool_setting == 10707
	|| player.multitool_setting == 1540 || player.multitool_setting == 1541) {
		//Interior Walls
		float mysnappedangle;
		float mytrn;
		//Snap angles
		//mytrn = player.angles_y - 90;
		mytrn = player.angles_y;
		
		if (mytrn < 135 && mytrn >= 45)
			mysnappedangle = 90;
		else if (mytrn < 45 && mytrn >= -45)
			mysnappedangle = 0;
		else if (mytrn < -45 && mytrn >= -135)
			mysnappedangle = -90;
		else
			mysnappedangle = 180;
		
		f = findradius(player.origin, 2);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if (f.amnt == 565 || f.amnt == 577 || f.amnt == 585
				|| f.amnt == 568 || f.amnt == 579 || f.amnt == 587
				|| f.amnt == 10700 || f.amnt == 10701 || f.amnt == 10702
				|| f.amnt == 10703 || f.amnt == 10704 || f.amnt == 10705
				|| f.amnt == 10706 || f.amnt == 10707 
				|| f.amnt == 1540 || f.amnt == 1541) {
					//amnt is only found on scaffolds in this code
					//its just like count
					//print(" Angles: ", ftos(f.angles_y + 90),"\n");
					//print(" MYAngles: ", ftos(mysnappedangle),"\n");
					if (f.angles_y + 90 == mysnappedangle) {
						sprint(player, "Can't build same interior wall as exists here\n");
						return TRUE;
					}
				}
				 
    				if (f.count == 565 || f.count == 577 || f.count == 585
				|| f.count == 568 || f.count == 579 || f.count == 587
				|| f.count == 10700 || f.count == 10701 || f.count == 10702
				|| f.count == 10703 || f.count == 10704 || f.count == 10705
				|| f.count == 10706 || f.count == 10707
				|| f.count == 1540 || f.count == 1541) {
					//print(" Angles: ", ftos(f.angles_y + 90),"\n");
					//print(" MYAngles: ", ftos(mysnappedangle),"\n");
					if (f.angles_y + 90 == mysnappedangle) {
						sprint(player, "Can't build same interior wall as exists here\n");
						return TRUE;
					}
				}
			}
    			f = f.chain;
  		}	
	}
	
	
	//Large walls
	if ((!autocvar_g_balance_multitool_allowlargewallinlargewall)
	&&(
	
	(!autocvar_g_balance_multitool_allowbermsinlargewall
	&&( player.multitool_setting == 550
	|| player.multitool_setting == 551
	|| player.multitool_setting == 1548
	|| player.multitool_setting == 1549))
	
	||
	(player.multitool_setting == 540
	|| player.multitool_setting == 541
	|| player.multitool_setting == 542
	|| player.multitool_setting == 543
	|| player.multitool_setting == 544
	|| player.multitool_setting == 545
	|| player.multitool_setting == 546
	|| player.multitool_setting == 560
	|| player.multitool_setting == 561
	|| player.multitool_setting == 562
	|| player.multitool_setting == 563
	|| player.multitool_setting == 569
	|| player.multitool_setting == 570
	|| player.multitool_setting == 571
	|| player.multitool_setting == 572
	|| player.multitool_setting == 573
	|| player.multitool_setting == 10708
	|| player.multitool_setting == 580
	|| player.multitool_setting == 581
	|| player.multitool_setting == 582
	|| player.multitool_setting == 588
	|| player.multitool_setting == 1530
	|| player.multitool_setting == 1531
	|| player.multitool_setting == 1532
	|| player.multitool_setting == 1533
	|| player.multitool_setting == 1534
	|| player.multitool_setting == 1535
	|| player.multitool_setting == 1536
	|| player.multitool_setting == 1537
	|| player.multitool_setting == 1542
	|| player.multitool_setting == 1543
	)
	
	)
	) {
		//Large Walls
		local vector mywallorigin;
		local float mywallshift;
		mywallshift = 0;
		mywallorigin = player.origin;
		
		//print(vtos(mywallorigin), "--Porigin\n");
		
		//Replicate the wallsnapping
		if (player.multitool_wallsnap == 1) {
			mywallorigin = vsnap(mywallorigin, 256);
			mywallshift = 128;
		} else {
			mywallorigin = vsnap(mywallorigin, 512);
			mywallshift = 256;
		}
		
		
		if (player.multitool_wallshift == 1) {
				vector mytesto1, mytesto2, mytesto3, mytesto4;
				mytesto1 = mywallorigin;
				mytesto2 = mywallorigin;
				mytesto3 = mywallorigin;
				mytesto4 = mywallorigin;
				
				mytesto1_x = mywallorigin_x + mywallshift;
				mytesto1_y = mywallorigin_y + mywallshift;
				
				mytesto2_x = mywallorigin_x - mywallshift;
				mytesto2_y = mywallorigin_y - mywallshift;
				
				mytesto3_x = mywallorigin_x + mywallshift;
				mytesto3_y = mywallorigin_y - mywallshift;
				
				mytesto4_x = mywallorigin_x - mywallshift;
				mytesto4_y = mywallorigin_y + mywallshift;
				
				
				if ((vlen(player.origin-mytesto2)) > (vlen(player.origin-mytesto1))) {
					//mytesto1 wins
					if ((vlen(player.origin-mytesto3)) > (vlen(player.origin-mytesto1))) {
						//mytesto1 wins
						mywallorigin = mytesto1;
						if ((vlen(player.origin-mytesto4)) > (vlen(player.origin-mytesto1))) {
							//mytesto1 wins
							mywallorigin = mytesto1;
						} else {
							//mytesto4 wins
							mywallorigin = mytesto4;
						}
					} else {
						//mytesto3 wins
						if ((vlen(player.origin-mytesto4)) > (vlen(player.origin-mytesto3))) {
							//mytesto3 wins
							mywallorigin = mytesto3;
						} else {
							//mytesto4 wins
							mywallorigin = mytesto4;
						}
					}
				} else {
					//mytesto2 wins
					if ((vlen(player.origin-mytesto3)) > (vlen(player.origin-mytesto2))) {
						//mytesto2 wins
						if ((vlen(player.origin-mytesto4)) > (vlen(player.origin-mytesto2))) {
							//mytesto2 wins
							mywallorigin = mytesto2;
						} else {
							//mytesto4 wins
							mywallorigin = mytesto4;
						}
					} else {
						//mytesto3 wins
						if ((vlen(player.origin-mytesto4)) > (vlen(player.origin-mytesto3))) {
							//mytesto3 wins
							mywallorigin = mytesto3;
						} else {
							//mytesto4 wins
							mywallorigin = mytesto4;
						}
					}
				}
					
		}
		
		mywallorigin_z = player.origin_z;
		
		//print(vtos(mywallorigin), "--Worigin\n");
		
		f = findradius(mywallorigin, autocvar_g_balance_multitool_largewallinlargewallsearchradius);
  		while(f)
  		{
			if (f.classname == "bldhitbx" || f.classname == "building")
			{
				if (
				(!autocvar_g_balance_multitool_allowbermsinlargewall
				&&( f.amnt == 550
				|| f.amnt == 551
				|| f.amnt == 1548
				|| f.amnt == 1549))
				
				||
				(f.amnt == 540
				|| f.amnt == 541
				|| f.amnt == 542
				|| f.amnt == 543
				|| f.amnt == 544
				|| f.amnt == 545
				|| f.amnt == 546
				|| f.amnt == 560
				|| f.amnt == 561
				|| f.amnt == 562
				|| f.amnt == 563
				|| f.amnt == 569
				|| f.amnt == 570
				|| f.amnt == 571
				|| f.amnt == 572
				|| f.amnt == 573
				|| f.amnt == 10708
				|| f.amnt == 580
				|| f.amnt == 581
				|| f.amnt == 582
				|| f.amnt == 588
				|| f.amnt == 1530
				|| f.amnt == 1531
				|| f.amnt == 1532
				|| f.amnt == 1533
				|| f.amnt == 1534
				|| f.amnt == 1535
				|| f.amnt == 1536
				|| f.amnt == 1537
				|| f.amnt == 1542
				|| f.amnt == 1543
				)
				
				) {
						sprint(player, "Can't build large wall inside of large wall scaffold\n");
						return TRUE;
				}
				 
				 
				 
				 
    				if (
				(!autocvar_g_balance_multitool_allowbermsinlargewall
				&&( f.count == 550
				|| f.count == 551
				|| f.count == 1548
				|| f.count == 1549))
				
				||
				(f.count == 540
				|| f.count == 541
				|| f.count == 542
				|| f.count == 543
				|| f.count == 544
				|| f.count == 545
				|| f.count == 546
				|| f.count == 560
				|| f.count == 561
				|| f.count == 562
				|| f.count == 563
				|| f.count == 569
				|| f.count == 570
				|| f.count == 571
				|| f.count == 572
				|| f.count == 573
				|| f.count == 10708
				|| f.count == 580
				|| f.count == 581
				|| f.count == 582
				|| f.count == 588
				|| f.count == 1530
				|| f.count == 1531
				|| f.count == 1532
				|| f.count == 1533
				|| f.count == 1534
				|| f.count == 1535
				|| f.count == 1536
				|| f.count == 1537
				|| f.count == 1542
				|| f.count == 1543
				)
				
				) {
					//print(vtos(f.absmax), "--ABSMAX\n");
					//print(vtos(f.maxs), "--Maxs\n");
					
					if (autocvar_g_balance_multitool_allowlargewallontopoflargewall &&
					(player.multitool_blocktype && (mywallorigin_z > (f.absmax_z - 64)))) {
						//64 to account for parapet
						//print("We good, nicca. As a builder, u is woke. Pat on the back mufugga. Heard you liked walls...\n");
					} else {
						sprint(player, "Can't build large wall inside of large wall\n");
						return TRUE;
					}
				}
			}
    			f = f.chain;
  		}	
	}

	return FALSE;
}

float multitool_toofar(entity player)
{
	if (player.multitool_setting == 4 || player.multitool_setting == 5
	|| player.multitool_setting == 7 || player.multitool_setting == 27
	|| player.multitool_setting == 1001)
	{
		//Garrisons, strongholds, and castles don't have the restriction
		//They allow you to start a settlement away from your flag base
		return FALSE;
	}
	
	if (autocvar_g_balance_multitool_claimstones) {
		if (player.multitool_setting == MTB64_CLAIMSTONE || player.multitool_setting == MTB64U_CLAIMSTONE)
		{
		//Same with claimstones
		return FALSE;
		}
	}
	
	if (autocvar_g_balance_multitool_freebuild >= 1) {
		//Freebuild allows you to skip this restriction
		return FALSE;
	}
	
	if (autocvar_g_balance_multitool_freebuild_blocks >= 1) {
		if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
			//Freebuild_blocks allows you to skip this restriction
			return FALSE;
		}
	}

	entity f;
	f = findradius(player.origin, autocvar_g_balance_multitool_maxradius);
  	while(f)
  	{
		if (f.classname == "bldhitbx")
		{
			if ((teamplay) && (player.team != f.team)) {
				//Carry on
			} else if (((teamplay) && (player.team == f.team))
			||(player == f.realowner)) {
				if not(multitool_isfurniture(f.count)) {
					if (f.count == MTB64_CLAIMSTONE || f.count == MTB64U_CLAIMSTONE) {
						if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
						|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
							//If found building is not furniture, 
							//If found building IS a claim stone
							//If we are trying to build blocks or a furnishings
							//and IF we have claimstones enabled
							//we've found a "building" of ours in the vicinity
							
							if (autocvar_g_balance_multitool_claimstones) {
								return FALSE;
							}
							
							//(If we want to use claimstone to start building buildings however,
							//we will need to lay down a normal block first)
						}
					} else if (((f.count >= 700 && f.count <= MTB64BOUNDLAST)
					|| (f.count >= MTB64UBOUNDFIRST && f.count <= MTB64UBOUNDLAST))
					&& (!autocvar_g_balance_multitool_toofarblockscountasbuildings)) {
						if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
						|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
							//If found building is not furniture, we've found a building of ours in the vicinity
							//
							//If found builfing is a block etc
							//AND If we do NOT have the toofarblockscount.. cvar set
							//(by default we do NOT have that set)
							//
							//If we are trying to build a block, not a building
							//then we've found a "building" of ours in the vicinity
							
							return FALSE;
						
							//Thus if you are building blocks, you're good
							//However if you are building with buildings, you might need something more substantial around
							//Such as a garrison etc
						}
					} else {
						//If found building is not furniture, we've found a building of ours in the vicinity
						return FALSE;
					}
				}
			}
		}
    		f = f.chain;
  	}
	
	f = findradius(player.origin, autocvar_g_balance_multitool_maxradiusbase);
  	while(f)
  	{
		if ((f.classname == "bldhitbx")
		&& (f.count == 4 || f.count == 5
		|| f.count == 7 || f.count == 27 || f.count == 1001))
		{
    			if ((teamplay) && (player.team != f.team)) {
				//Carry on
			} else if (((teamplay) && (player.team == f.team))
			||(player == f.realowner)) {
					return FALSE;
			}
		}
    		f = f.chain;
  	}
	
	if (teamplay)
	{
		f = findradius(player.origin, autocvar_g_balance_multitool_maxradiusflag);
  		while(f)
  		{
			if (f.classname == "item_flag_team_base"
			|| f.classname == "onslaught_generator")
			{
				if (player.team == f.team) {
					return FALSE;
				}	
			}
	    		f = f.chain;	
		}
	}

	sprint(player, "Too far away from garrison, stronghold, castle, flagbase, or other owned building\n");
	return TRUE;
}

float multitool_decreaseammo(entity player)
{
	player.rtnvl2 = 0; //This is our "additional" return value, as seen in defs.qh
	// We will set it to the multitool_ammocurrent that is being deducted.
	// Then we will set the scaffolds multitool_ammocurrent to player.rtnvl2
	// If the scaffold is destroyed by the owner or his team he will get that back (only the converted nails)
	
	if (autocvar_g_balance_multitool_nocost == 1) {
		//Nocost
	} else if (player.multitool_setting == 1) {
		sprint(player, "Tower-MG Cost:^x000 1000 Converted Nails^7 + ^xFF7 150 Free Nails^7\n");
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 150) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//mg
		//^x000 = Converted Nails Color, ^xFF7 = Free Nails
		//^xE00 = Converted Rockets Color, ^xF41 = Free Rockets
		//^x30D = Converted Cells Color,  ^x70F = Free Cells
	} else if (player.multitool_setting == 2) {
		sprint(player, "Tower-Plasma Cost:^x000 1200 Converted Nails^7 + ^x70F 150 Free Cells^7\n");
		
		if (player.multitool_ammocurrent >= 1200
		&&  player.ammo_cells >= 150) {
			player.multitool_ammocurrent -= 1200;
			player.rtnvl2 = 1200;
			player.ammo_cells -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//plasma.bsp";
	} else if (player.multitool_setting == 3) {
		sprint(player, "Tower-MLRS Cost:^x000 1400 Converted Nails^7 + ^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 1400
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 1400;
			player.rtnvl2 = 1400;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//mlrs.bsp";
	} else if (player.multitool_setting == 4) {
		sprint(player, "Garrison Cost:^x000 1250 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1250
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1250;
			player.rtnvl2 = 1250;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//garrison.bsp";
	} else if (player.multitool_setting == 5) {
		sprint(player, "Stronghold Cost:^x000 3500 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 3500
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 3500;
			player.rtnvl2 = 3500;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//stronghold.bsp";
	} else if (player.multitool_setting == 6) {
		sprint(player, "StrongTower Cost:^x000 2250 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 2250
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 2250;
			player.rtnvl2 = 2250;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//strongtower.bsp";
	} else if (player.multitool_setting == 7) {
		sprint(player, "SmallCastle Cost:^x000 4000 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 4000
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 4000;
			player.rtnvl2 = 4000;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//smallcastle.bsp";
	} else if (player.multitool_setting == 8) {
		sprint(player, "HellionTower Cost:^x000 1400 Converted Nails^7 + ^xE00 500 Converted Rockets^7 +^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 1400
		&&  player.multitool_ammocurrentr >= 500
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 1400;
			player.rtnvl2 = 1400;
			player.multitool_ammocurrentr -= 500;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hellion.bsp";
	} else if (player.multitool_setting == 9) {
		sprint(player, "TownHall Cost:^x000 900 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 900
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 900;
			player.rtnvl2 = 900;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//townhall.bsp";
	} else if (player.multitool_setting == 10) {
		sprint(player, "HKTower Cost:^x000 1650 Converted Nails^7 + ^xE00 2500 Converted Rockets^7 +^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 1650
		&&  player.multitool_ammocurrentr >= 2500
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 1650;
			player.rtnvl2 = 1650;
			player.multitool_ammocurrentr -= 2500;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hk.bsp";
	} else if (player.multitool_setting == 11) {
		sprint(player, "GovernorsMansion Cost:^x000 5000 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 5000
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 5000;
			player.rtnvl2 = 5000;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//gmanse.bsp";
	} else if (player.multitool_setting == 12) {
		sprint(player, "Arsenal Cost:^x000 2000 Converted Nails^7 + ^xFF7 50 Free Nails^7 + ^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 2000
		&&  player.ammo_nails >= 50
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.ammo_nails -= 50;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//arsenal.bsp";
	} else if (player.multitool_setting == 13) {
		sprint(player, "Barracks Cost:^x000 1050 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1050
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1050;
			player.rtnvl2 = 1050;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//barracks.bsp";
	} else if (player.multitool_setting == 14) {
		sprint(player, "Church Cost:^x000 500 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//church.bsp";
	} else if (player.multitool_setting == 15) {
		sprint(player, "Hangar Cost:^x000 1000 Converted Nails^7 + ^xE00 4500 Converted Rockets^7 +^xF41 150 Free Rockets^7 +  + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentr >= 4500
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentr -= 4500;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 16) {
		sprint(player, "Tank Hangar Cost:^x000 1000 Converted Nails^7 + ^xE00 6500 Converted Rockets^7 +^xF41 150 Free Rockets^7 +  + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentr >= 6500
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentr -= 6500;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldtankhangar.bsp";
	} else if (player.multitool_setting == 17) {
		sprint(player, "Chataeu Cost:^x000 5000 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 5000
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 5000;
			player.rtnvl2 = 5000;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//chataeu.bsp";
	} else if (player.multitool_setting == 18) {
		sprint(player, "PalladianManor Cost:^x000 5000 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 5000
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 5000;
			player.rtnvl2 = 5000;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//chataeu.bsp";
	} else if (player.multitool_setting == 19) {
		sprint(player, "StoneHouse Cost:^x000 425 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 425
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 425;
			player.rtnvl2 = 425;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//house.bsp";
	} else if (player.multitool_setting == 20) {
		sprint(player, "Treetop Sentry Cost:^x000 275 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 275
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 275;
			player.rtnvl2 = 275;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 21) {
		sprint(player, "SiegeWorkshop Cost:^x000 1000 Converted Nails^7 + ^xE00 4000 Converted Rockets^7 +^xF41 150 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentr >= 4000
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentr -= 4000;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 22) {
		sprint(player, "Gaol Cost:^x000 3800 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 3800
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 3800;
			player.rtnvl2 = 3800;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//stronghold.bsp";
	} else if (player.multitool_setting == 23) {
		sprint(player, "SmallJail Cost:^x000 1850 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1850
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1850;
			player.rtnvl2 = 1850;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//garrison.bsp";
	} else if (player.multitool_setting == 24) {
		sprint(player, "Forge N Cost:^x000 440 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 440
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 440;
			player.rtnvl2 = 440;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 25) {
		sprint(player, "Forge R Cost:^x000 400 Converted Nails^7 + ^xE00 40 Converted Rockets^7 +^xF41 15 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 400
		&&  player.multitool_ammocurrentr >= 40
		&&  player.ammo_rockets >= 15
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.multitool_ammocurrentr -= 40;
			player.ammo_rockets -= 15;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 26) {
		sprint(player, "Forge E Cost:^x000 400 Converted Nails^7 + ^x30D 40 Converted Cells^7 +^x70F 15 Free Cells^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 400
		&&  player.multitool_ammocurrentc >= 40
		&&  player.ammo_cells >= 15
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.multitool_ammocurrentc -= 40;
			player.ammo_cells -= 15;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 27) {
		sprint(player, "CrusaderStronghold Cost:^x000 3725 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 3725
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 3725;
			player.rtnvl2 = 3725;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (autocvar_g_balance_multitool_ancientonly &&
		(player.multitool_setting == 110
		|| player.multitool_setting == 111
		|| player.multitool_setting == 112)) {
		sprint(player, "Point Defense Scorpion Ballista Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 110) {
		sprint(player, "Point Defense Hotchkiss M1914 Gun Cost:^x000 500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 111) {
		sprint(player, "Point Defense Lewis Gun Cost:^x000 700 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 700
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 700;
			player.rtnvl2 = 700;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 112) {
		sprint(player, "Point Defense Maxim Gun Cost:^x000 900 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 900
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 900;
			player.rtnvl2 = 900;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 501) {
		sprint(player, "Field Cost:^x000 40 Converted Nails^7 + ^xFF7 2 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 40
		&&  player.ammo_nails >= 2) {
			player.multitool_ammocurrent -= 40;
			player.rtnvl2 = 40;
			player.ammo_nails -= 2;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//field.bsp";
	} else if (player.multitool_setting == 502) {
		sprint(player, "Vineyard Cost:^x000 60 Converted Nails^7 + ^xFF7 2 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 60
		&&  player.ammo_nails >= 2) {
			player.multitool_ammocurrent -= 60;
			player.rtnvl2 = 60;
			player.ammo_nails -= 2;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 503 ) {
		sprint(player, "Recruitment Post Cost:^x000 30 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 30
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 30;
			player.rtnvl2 = 30;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 520) {
		sprint(player, "Wall-Hedge Cost:^x000 100 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hedge.bsp";
	} else if (player.multitool_setting == 521) {
		sprint(player, "Wall-Hedge-Tower Cost:^x000 200 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hedge tower.bsp";
	} else if (player.multitool_setting == 522) {
		sprint(player, "Wall-Hedge-Tower-Round Cost:^x000 200 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hedge tower round.bsp";
	} else if (player.multitool_setting == 523) {
		sprint(player, "Wall-Hedge-Door Cost:^x000 100 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//hedge.bsp";
	} else if (player.multitool_setting == 530) {
		sprint(player, "Wall-Brick Cost:^x000 250 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//brick.bsp";
	} else if (player.multitool_setting == 531) {
		sprint(player, "Wall-Brick-Tower Cost:^x000 300 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//brick tower.bsp";
	} else if (player.multitool_setting == 532) {
		sprint(player, "Wall-Brick-Tower-Round Cost:^x000 375 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 375
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 375;
			player.rtnvl2 = 375;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//brick tower round.bsp";
	} else if (player.multitool_setting == 533) {
		sprint(player, "Wall-Brick-Door Cost:^x000 250 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//brick.bsp";
	} else if (player.multitool_setting == 540) {
		sprint(player, "Wall-Palisade Cost:^x000 275 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 275
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 275;
			player.rtnvl2 = 275;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade.bsp";
	} else if (player.multitool_setting == 541) {
		sprint(player, "Wall-Palisade-Tower Cost:^x000 325 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 325
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 325;
			player.rtnvl2 = 325;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade tower.bsp";
	} else if (player.multitool_setting == 542) {
		sprint(player, "Wall-Palisade-Gate Cost:^x000 275 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 275
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 275;
			player.rtnvl2 = 275;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade gate.bsp";
	} else if (player.multitool_setting == 543) {
		sprint(player, "Wall-Palisade-Gate-Large Cost:^x000 275 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 275
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 275;
			player.rtnvl2 = 275;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade gate large.bsp";
	} else if (player.multitool_setting == 544) {
		sprint(player, "Wall-Palisade-Woodwall Cost:^x000 295 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 295
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 295;
			player.rtnvl2 = 295;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade woodwall.bsp";
	} else if (player.multitool_setting == 545) {
		sprint(player, "Wall-Palisade-Woodwall-Gate Cost:^x000 295 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 295
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 295;
			player.rtnvl2 = 295;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade woodwall gate.bsp";
	} else if (player.multitool_setting == 546) {
		sprint(player, "Wall-Palisade-Woodwall-Tower Cost:^x000 345 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 345
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 345;
			player.rtnvl2 = 345;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//palisade woodwall tower.bsp";
	} else if (player.multitool_setting == 550) {
		sprint(player, "Wall-Berm Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//berm.bsp";
	} else if (player.multitool_setting == 551) {
		sprint(player, "Wall-Berm-Tower Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//berm tower.bsp";
	} else if (player.multitool_setting == 560) {
		sprint(player, "Wall-Curtain Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 567) {
		sprint(player, "Wall-Curtain-Fill-Stairs Cost:^x000 650 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 650
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 650;
			player.rtnvl2 = 650;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 561) {
		sprint(player, "Wall-Curtain-Tower Cost:^x000 700 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 700
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 700;
			player.rtnvl2 = 700;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain tower.bsp";
	} else if (player.multitool_setting == 562) {
		sprint(player, "Wall-Curtain-Tower-Round Cost:^x000 900 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 900
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 900;
			player.rtnvl2 = 900;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain tower round.bsp";
	} else if (player.multitool_setting == 563) {
		sprint(player, "Wall-Curtain-Door Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 564) {
		sprint(player, "Wall-Curtain-Fill Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 565) {
		sprint(player, "Wall-Curtain-Interior Cost:^x000 300 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 568) {
		sprint(player, "Wall-Curtain-Interior-Door Cost:^x000 300 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 569) {
		sprint(player, "Wall-Curtain-Gate-Large Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == 566) {
		sprint(player, "Vault-Curtain Cost:^x000 550 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 550
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 550;
			player.rtnvl2 = 550;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 570) {
		sprint(player, "Wall-Castle Cost:^x000 800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 578) {
		sprint(player, "Wall-Castle-Fill-Stairs Cost:^x000 900 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 900
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 900;
			player.rtnvl2 = 900;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle tower.bsp";
	} else if (player.multitool_setting == 571) {
		sprint(player, "Wall-Castle-Tower Cost:^x000 1000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle tower.bsp";
	} else if (player.multitool_setting == 572) {
		sprint(player, "Wall-Castle-Tower-Round Cost:^x000 1050 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1050
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1050;
			player.rtnvl2 = 1050;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle tower round.bsp";
	} else if (player.multitool_setting == 573) {
		sprint(player, "Wall-Castle-Door Cost:^x000 800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 574) {
		sprint(player, "Vault-Castle Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 575) {
		sprint(player, "Vault-Castle-StarChamber Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 576) {
		sprint(player, "Wall-Castle-Fill Cost:^x000 800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 577) {
		sprint(player, "Wall-Castle-Interior Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 579) {
		sprint(player, "Wall-Castle-Interior-Door Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10700) {
		sprint(player, "Wall-Castle-Interior-Door-Two Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10701) {
		sprint(player, "Wall-Castle-Interior-Door-Side Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10702) {
		sprint(player, "Wall-Castle-Interior-Window Cost:^x000 500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10703) {
		sprint(player, "Wall-Castle-Interior-ArrowLoop Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10704) {
		sprint(player, "Wall-Castle-Interior-Arch Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10705) {
		sprint(player, "Wall-Castle-Interior-ArchIronBars Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10706) {
		sprint(player, "Wall-Castle-Interior-Alcove Cost:^x000 450 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 450
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 450;
			player.rtnvl2 = 450;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10707) {
		sprint(player, "Wall-Castle-Interior-Alcove-Top-Copper Cost:^x000 480 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 480
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 480;
			player.rtnvl2 = 480;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10708) {
		sprint(player, "Wall-Castle-Gate-Large Cost:^x000 800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10709) {
		sprint(player, "W-C-Portcullis-Wood Cost:^x000 400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 10710) {
		sprint(player, "W-C-Portcullis-Iron Cost:^x000 1400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1400;
			player.rtnvl2 = 1400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//castle.bsp";
	} else if (player.multitool_setting == 580) {
		sprint(player, "Wall-Polish Cost:^x000 850 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 850
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 850;
			player.rtnvl2 = 850;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 586) {
		sprint(player, "Wall-Polish-Fill-Stairs Cost:^x000 920 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 920
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 920;
			player.rtnvl2 = 920;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 581) {
		sprint(player, "Wall-Polish-Tower Cost:^x000 1000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 582) {
		sprint(player, "Wall-Polish-Door Cost:^x000 850 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 850
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 850;
			player.rtnvl2 = 850;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 583) {
		sprint(player, "Vault-Polish Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 584) {
		sprint(player, "Wall-Polish-Fill Cost:^x000 850 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 850
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 850;
			player.rtnvl2 = 850;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 585) {
		sprint(player, "Wall-Polish-Interior Cost:^x000 425 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 425
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 425;
			player.rtnvl2 = 425;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 587) {
		sprint(player, "Wall-Polish-Interior-Door Cost:^x000 425 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 425
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 425;
			player.rtnvl2 = 425;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 588) {
		sprint(player, "Wall-Polish-Gate-Large Cost:^x000 850 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 850
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 850;
			player.rtnvl2 = 850;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish.bsp";
	} else if (player.multitool_setting == 610) {
		sprint(player, "Vault-Roof-Copper Cost:^x000 1000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//roof
	} else if (player.multitool_setting == 611) {
		sprint(player, "Vault-Roof-Copper-End Cost:^x000 1000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//roof
	} else if (player.multitool_setting == 612) {
		sprint(player, "Vault-Roof-Copper-One Cost:^x000 1000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//roof
	} else if (player.multitool_setting == 616) {
		sprint(player, "Vault-Roof-Dome Cost:^x000 2000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//roof
	} else if (player.multitool_setting == 630) {
		sprint(player, "Foundation-Wall Cost:^x000 2000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 631) {
		sprint(player, "Foundation-Tower Cost:^x000 2500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2500;
			player.rtnvl2 = 2500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 632) {
		sprint(player, "Foundation-Tower-Round Cost:^x000 2500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2500;
			player.rtnvl2 = 2500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 633) {
		sprint(player, "Foundation-Bridge Cost:^x000 4000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//polish tower.bsp";
	} else if (player.multitool_setting == 645) {
		sprint(player, "Bridge-Wood (Wide) Cost:^x000 840 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 840
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 840;
			player.rtnvl2 = 840;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 646) {
		sprint(player, "Bridge-Wood (Narrow) Cost:^x000 800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 650) {
		sprint(player, "Bridge-Curtain-Landing Cost:^x000 1800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 651) {
		sprint(player, "Bridge-Curtain Cost:^x000 1800 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 652) {
		sprint(player, "Bridge-Curtain-Crenelated Cost:^x000 2000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 660) {
		sprint(player, "Bridge-Castle-Landing Cost:^x000 2400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2400;
			player.rtnvl2 = 2400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 661) {
		sprint(player, "Bridge-Castle Cost:^x000 2400 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2400
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2400;
			player.rtnvl2 = 2400;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 662) {
		sprint(player, "Bridge-Castle-Crenelated Cost:^x000 2600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2600;
			player.rtnvl2 = 2600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 663) {
		sprint(player, "Bridge-Castle-Fortified Cost:^x000 3000 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 3000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 3000;
			player.rtnvl2 = 3000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 664) {
		sprint(player, "Bridge-Castle-Fortified-Covered Cost:^x000 3500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 3500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 3500;
			player.rtnvl2 = 3500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 670) {
		sprint(player, "Bridge-Polish-Landing Cost:^x000 2550 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2550
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2550;
			player.rtnvl2 = 2550;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 671) {
		sprint(player, "Bridge-Polish Cost:^x000 2550 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2550
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2550;
			player.rtnvl2 = 2550;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 672) {
		sprint(player, "Bridge-Polish-Crenelated Cost:^x000 2750 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2750
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 2750;
			player.rtnvl2 = 2750;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == MTB64_STAKES_WOOD1) {
		sprint(player, "Block-64x64-Stakes Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_PLATFORMWOOD_8) {
		sprint(player, "Block-64x64-Platform-8 Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_PLATFORMWOOD_24) {
		sprint(player, "Block-64x64-Platform-24 Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_BWIRE) {
		sprint(player, "Block-64x64-BarbedWire:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_WINDOW_WOODBAR) {
		sprint(player, "Block-64x64-Window Wood Bars Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_WINDOW_IRONBAR) {
		sprint(player, "Block-64x64-Window Iron Bars Cost:^x000 15 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 15
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 15;
			player.rtnvl2 = 15;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_DOOR_R_WOOD) {
		sprint(player, "Door-64-Wood Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_DOOR_R_JWOOD) {
		sprint(player, "Door-64-Wood-Iron-Fittings Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_DOOR_R_FWOOD) {
		sprint(player, "Door-64-Wood-Paneled-White Cost:^x000 200 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_DOOR_R_IRONBAR) {
		sprint(player, "Door-64-Iron-Bars Cost:^x000 35 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 35
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 35;
			player.rtnvl2 = 35;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FITTEDWINDOW_CASTLE_ALOOP) {
		sprint(player, "FittedWindow-64-Castle-Arrowloop Cost:^x000 12 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 12
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 12;
			player.rtnvl2 = 12;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FITTEDWINDOW_CASTLE_SWALL) {
		sprint(player, "FittedWindow-64-Castle-SolidWall Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FITTEDWINDOW_WINDOW) {
		sprint(player, "FittedWindow-64-Window Cost:^x000 280 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 280
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 280;
			player.rtnvl2 = 280;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
		}
	} else if (player.multitool_setting >= MTB64_FILLED && player.multitool_setting <= MTB64_FILLEDLAST) {
		sprint(player, "Block-64x64-Filled Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_SHINGLES && player.multitool_setting <= MTB64_SHINGLESLAST) {
		sprint(player, "Block-64x64-CorrugatedRoof Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_WOOD1 && player.multitool_setting <= MTB64_WOOD1LAST) {
		sprint(player, "Block-64x64-Wood1 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_WOOD2 && player.multitool_setting <= MTB64_WOOD2LAST) {
		sprint(player, "Block-64x64-Wood2 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_CURTAIN && player.multitool_setting <= MTB64_CURTAINLAST) {
		sprint(player, "Block-64x64-Curtain Cost:^x000 4 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 4
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 4;
			player.rtnvl2 = 4;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_CASTLE && player.multitool_setting <= MTB64_CASTLELAST) {
		sprint(player, "Block-64x64-Castle Cost:^x000 5 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 5
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 5;
			player.rtnvl2 = 5;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_CASTLESQUARE) {
		sprint(player, "Block-64x64-CastleSquare Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64U_CONCRETE && player.multitool_setting <= MTB64U_CONCRETELAST) {
		sprint(player, "Block-64x64-Concrete Cost:^x000 1 Converted Nail^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
		// Cost:
		// Concrete vs Castle wall
		//; 230/800
	        //0.2875
		//Thus:
		//; 5*0.2875
	        //1.4375 
		//Rounded down because concrete is cheap
	} else if (player.multitool_setting == MTB64U_CONCRETESQUARE) {
		sprint(player, "Block-64x64-ConcreteSquare Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == MTB64U_PLATFORM_8) {
		sprint(player, "Block-64x64-Platform-8 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == MTB64U_PLATFORM_16) {
		sprint(player, "Block-64x64-Platform-16 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == MTB64U_PLATFORM_24) {
		sprint(player, "Block-64x64-Platform-24 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == MTB64U_PLATFORM_32) {
		sprint(player, "Block-64x64-Platform-32 Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting >= MTB64U_RCONCRETE && player.multitool_setting <= MTB64U_RCONCRETELAST) {
		sprint(player, "Block-64x64-ReenforcedConcrete Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64U_RCONCRETESQUARE) {
		sprint(player, "Block-64x64-ReenforcedConcreteSquare Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64U_RCONCRETESQUARE2) {
		sprint(player, "Block-64x64-ReenforcedConcreteSquare with Thin Metal Frame Cost:^x000 3 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 3
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 3;
			player.rtnvl2 = 3;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64U_ARCHIVEBOX) {
		sprint(player, "Block-64x64-ArchiveBox Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64U_INACT_OIL) {
		sprint(player, "Block-64x64-MetalDrum Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_ACT_OIL) {
		sprint(player, "Block-64x64-GasolineDrum Cost:^x000 1 Converted Nails^7 + ^xF41 30 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_rockets >= 30) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_rockets -= 30;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_ACT_EXPL) {
		sprint(player, "Block-64x64-DemolitionCharge Cost:^x000 15 Converted Nails^7 + ^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 15
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 15;
			player.rtnvl2 = 15;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHEST_WOOD ) {
		sprint(player, "Furniture-Chest-Wood Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHESTLARGE_WOOD ) {
		sprint(player, "Furniture-LargeChest-Wood Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BARREL_WOOD2) {
		sprint(player, "Furniture-Barrel-Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BARREL_WOOD) {
		sprint(player, "Furniture-Barrel-Wood-Tapped Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_STOOL_WOOD) {
		sprint(player, "Furniture-Stool-Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAIR_WOOD ) {
		sprint(player, "Furniture-Chair-Wood Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAIR_WOOD2 ) {
		sprint(player, "Furniture-Chair-Wood2 Enetheru Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BENCH_WOOD ) {
		sprint(player, "Furniture-Bench-Wood Enetheru Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAIR_FANCY1 ) {
		sprint(player, "Furniture-Chair-Upholstered Cost:^x000 1400 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1400;
			player.rtnvl2 = 1400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAIR_FANCY2 ) {
		sprint(player, "Furniture-WingChair-Upholstered Cost:^x000 1800 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAIR_FANCY3 ) {
		sprint(player, "Furniture-Chair-Poltroncina Cost:^x000 1400 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1400;
			player.rtnvl2 = 1400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_CHAISELOUNGE) {
		sprint(player, "Furniture-ChaiseLounge Cost:^x000 1980 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1980
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1980;
			player.rtnvl2 = 1980;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BED_WOOD ) {
		sprint(player, "Furniture-Bed-Wood Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_TABLE_WOOD ) {
		sprint(player, "Furniture-Table-Wood Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_TABLE_WOOD2 ) {
		sprint(player, "Furniture-Table-Wood2 Enetheru Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_TABLE_WOOD3 ) {
		sprint(player, "Furniture-Table-Wood3 Enetheru Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_TABLE_OCT_WOOD ) {
		sprint(player, "Furniture-Table-Octagonal-Wood Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_TABLE_OCT_WOOD2 ) {
		sprint(player, "Furniture-Table-Octagonal-DarkWood Cost:^x000 20 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 20
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 20;
			player.rtnvl2 = 20;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_WORKBENCH) {
		sprint(player, "Furniture-WorkBench Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BLKSMHBELLOWS) {
		sprint(player, "Furniture-Blacksmith-Bellows Cost:^x000 40 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 40
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 40;
			player.rtnvl2 = 40;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_GREEKPILLAR) {
		sprint(player, "Furniture-GreekPillar Cost:^x000 400 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_GREEKPILLARM) {
		sprint(player, "Furniture-GreekPillar-Marble Cost:^x000 500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_ROMANCOLUMN) {
		sprint(player, "Furniture-RomanColumn Cost:^x000 400 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_ROMANCOLUMNM) {
		sprint(player, "Furniture-RomanColumn-Marble Cost:^x000 500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BLKSMHFORGE) {
		sprint(player, "Furniture-Blacksmith-Forge Cost:^x000 50 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 50
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 50;
			player.rtnvl2 = 50;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BLKSMHANVIL) {
		sprint(player, "Furniture-Blacksmith-Anvil Cost:^x000 160 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 160
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 160;
			player.rtnvl2 = 160;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_IRONBRAZIER) {
		if (player.multitool_flamecolor == -10
		|| player.multitool_flamecolor >= 1)
		{
			sprint(player, "Furniture-Iron-Brazier (MagicFlame) Cost:^x000 120 Converted Nails^7 + ^xFF7 1 Free Nails^7 + ^x70F 130 Free Cells^7\n");
	
			if (player.multitool_ammocurrent >= 120
			&&  player.ammo_nails >= 1
			&&  player.ammo_cells >= 130) {
				player.multitool_ammocurrent -= 120;
				player.rtnvl2 = 120;
				player.ammo_nails -= 1;
				player.ammo_cells -= 130;
			} else {
				spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
				return FALSE;
			}
		} else {
			sprint(player, "Furniture-Iron-Brazier Cost:^x000 120 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
			if (player.multitool_ammocurrent >= 120
			&&  player.ammo_nails >= 1) {
				player.multitool_ammocurrent -= 120;
				player.rtnvl2 = 120;
				player.ammo_nails -= 1;
			} else {
				spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
				return FALSE;
			}
		}
	} else if (player.multitool_setting == MTB64_FURN_IRONMAIDEN) {
		sprint(player, "Furniture-IronMaiden Cost:^x000 360 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 360
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 360;
			player.rtnvl2 = 360;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_SPIKEDRACK) {
		sprint(player, "Furniture-SpikedRack Cost:^x000 210 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 210
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 210;
			player.rtnvl2 = 210;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_IMPALEMENTPOLE) {
		sprint(player, "Furniture-ImpalementPole Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_GIBBET) {
		sprint(player, "Furniture-Gibbet Cost:^x000 260 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 260
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 260;
			player.rtnvl2 = 260;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BLKSMHGRNDSTN) {
		sprint(player, "Furniture-Blacksmith-Grindstone Cost:^x000 20 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 20
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 20;
			player.rtnvl2 = 20;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_EMPTYSHELF_WOOD ) {
		sprint(player, "Furniture-EmptyShelves-Wood Cost:^x000 30 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 30
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 30;
			player.rtnvl2 = 30;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_FURN_BOOKSHELF_WOOD ) {
		sprint(player, "Furniture-Bookshelf-Wood Cost:^x000 800 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 800
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 800;
			player.rtnvl2 = 800;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CHAIR) {
		sprint(player, "Furniture-Chair Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA1BR) {
		sprint(player, "Furniture-LeatherChair-Brown Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA3BR) {
		sprint(player, "Furniture-LeatherSofa-Brown Cost:^x000 1500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA1B) {
		sprint(player, "Furniture-LeatherChair-Black Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA3B) {
		sprint(player, "Furniture-LeatherSofa-Black Cost:^x000 1500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA1LW) {
		sprint(player, "Furniture-LeatherChair-Creme Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA3LW) {
		sprint(player, "Furniture-LeatherSofa-Creme Cost:^x000 1500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA1LW2) {
		sprint(player, "Furniture-LeatherChair-White Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA3LW2) {
		sprint(player, "Furniture-LeatherSofa-White Cost:^x000 1500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		
	} else if (player.multitool_setting == MTB64U_FURN_SOFA_FOAM) {
		sprint(player, "Furniture-Sofa-Foam Cost:^x000 250 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA_TARTAN) {
		sprint(player, "Furniture-Sofa-Tartan Cost:^x000 250 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA_POOFY) {
		sprint(player, "Furniture-Sofa-Plush Cost:^x000 350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SOFA_NORM) {
		sprint(player, "Furniture-Sofa-Low Cost:^x000 250 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	
	} else if (player.multitool_setting == MTB64U_FURN_SHOWER) {
		sprint(player, "Furniture-Shower Cost:^x000 200 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SINK_PED) {
		sprint(player, "Furniture-PedestalSink Cost:^x000 300 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SINK_PED2) {
		sprint(player, "Furniture-PedestalSink2 Cost:^x000 350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SINK) {
		sprint(player, "Furniture-GreySink Cost:^x000 200 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SINK2) {
		sprint(player, "Furniture-DoubleSink Cost:^x000 220 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 220
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 220;
			player.rtnvl2 = 220;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TOILET) {
		sprint(player, "Furniture-TallToilet Cost:^x000 200 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_STOVE) {
		sprint(player, "Furniture-Stove Cost:^x000 350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_STOVE2) {
		sprint(player, "Furniture-ModernStove Cost:^x000 1800 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_STOVE3) {
		sprint(player, "Furniture-BasicStove Cost:^x000 190 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 190
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 190;
			player.rtnvl2 = 190;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_STOVE4) {
		sprint(player, "Furniture-PropaneStove Cost:^x000 350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FRIDGE) {
		sprint(player, "Furniture-Refrigerator Cost:^x000 500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FRIDGE2) {
		sprint(player, "Furniture-ThinRefrigerator Cost:^x000 350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FRIDGE3) {
		sprint(player, "Furniture-TrendyRefrigerator Cost:^x000 1500 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FRIDGE4) {
		sprint(player, "Furniture-SmallRefrigerator Cost:^x000 150 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 150
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 150;
			player.rtnvl2 = 150;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TOILET2) {
		sprint(player, "Furniture-Toilet Cost:^x000 200 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TOILET3) {
		sprint(player, "Furniture-ModernToilet Cost:^x000 400 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CHAIR2) {
		sprint(player, "Furniture-Chair-Black Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CHAIR3) {
		sprint(player, "Furniture-Chair-Minimalist Cost:^x000 40 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 40
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 40;
			player.rtnvl2 = 40;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CHAIR4) {
		sprint(player, "Furniture-Chair-Basic Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CHAIR5) {
		sprint(player, "Furniture-Chair-Basic2 Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SCHAIR) {
		sprint(player, "Furniture-Chair-TubeAndCushion Cost:^x000 20 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 20
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 20;
			player.rtnvl2 = 20;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_OMLCHAIR) {
		sprint(player, "Furniture-Chair-OfficeModernLeather Cost:^x000 620 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 620
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 620;
			player.rtnvl2 = 620;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_OMLCHAIR2) {
		sprint(player, "Furniture-Chair-OfficeModernFauxLeather Cost:^x000 570 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 570
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 570;
			player.rtnvl2 = 570;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_MLHSKCHAIR) {
		sprint(player, "Furniture-Chair-ModernLeatherHusk Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TRIBECACHAIR) {
		sprint(player, "Furniture-Chair-TribecaLeather Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BARCELONACHAIR) {
		sprint(player, "Furniture-Chair-Barcelona Cost:^x000 1000 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_STOOL) {
		sprint(player, "Furniture-Stool Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_CSTOOL) {
		sprint(player, "Furniture-Stool-Cushioned Cost:^x000 15 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 15
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 15;
			player.rtnvl2 = 15;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_RETROCHAIR) {
		sprint(player, "Furniture-Retro-Chair Cost:^x000 25 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 25
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 25;
			player.rtnvl2 = 25;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_PLSCHAIR) {
		sprint(player, "Furniture-Chair-PlasticSwivelOffice Cost:^x000 25 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 25
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 25;
			player.rtnvl2 = 25;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SCHINTGRDESK) {
		sprint(player, "Furniture-School-Integrated-Desk Cost:^x000 15 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 15
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 15;
			player.rtnvl2 = 15;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SCHDESKCHAIR) {
		sprint(player, "Furniture-School-Desk-and-Chair Cost:^x000 25 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 25
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 25;
			player.rtnvl2 = 25;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BARRELP) {
		sprint(player, "Furniture-PlasticBarrel Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BARRELM) {
		sprint(player, "Furniture-MetalCylinder Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}	
	} else if (player.multitool_setting == MTB64U_FURN_CRATE) {
		sprint(player, "Furniture-Crate Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_DESK) {
		sprint(player, "Furniture-Desk Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_MGSTDESK) {
		sprint(player, "Furniture-Desk-MetalTubeAndGlass Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_MGSTDESKFLAT) {
		sprint(player, "Furniture-Desk-MetalTubeAndGlass-Flat Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_MGSTDESKFULLCORNER) {
		sprint(player, "Furniture-Desk-MetalTubeAndGlass-FullCorner Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 215
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 215;
			player.rtnvl2 = 215;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLE) {
		sprint(player, "Furniture-Table Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLELOW) {
		sprint(player, "Furniture-Table-Low Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLEGLASS) {
		sprint(player, "Furniture-Table-Glass-Black Cost:^x000 110 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 110
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 110;
			player.rtnvl2 = 110;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_RETROTABLE) {
		sprint(player, "Furniture-Retro-Table Cost:^x000 105 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 105
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 105;
			player.rtnvl2 = 105;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLESQUARE) {
		sprint(player, "Furniture-Table-Square Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLECIRC) {
		sprint(player, "Furniture-Table-Circular Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_TABLELONG) {
		sprint(player, "Furniture-Table-Long Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINET1) {
		sprint(player, "Furniture-Cabinet-Basic-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINET2) {
		sprint(player, "Furniture-Cabinet-Basic-2 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINET3) {
		sprint(player, "Furniture-Cabinet-Basic-3 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINET4) {
		sprint(player, "Furniture-Cabinet-Basic-4 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNER1) {
		sprint(player, "Furniture-Cabinet-Basic-Corner1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETTOP1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNERTOP1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Corner1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNERTOP2) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Corner2 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}	
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETTOPDEEP1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Deep-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}	
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETTOPDEEPSHORT1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Deep-Short-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}	
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETTOPSHORT1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Short-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}	
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETTOPSHORTSHELVES1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Short-Shelves-1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP1) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Deep-Corner1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNERTOPDEEP2) {
		sprint(player, "Furniture-Cabinet-Basic-Top-Deep-Corner2 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETCORNER2) {
		sprint(player, "Furniture-Cabinet-Basic-Corner2 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETBAR1) {
		sprint(player, "Furniture-Cabinet-Basic-Bar1 Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETBARENDR) {
		sprint(player, "Furniture-Cabinet-Basic-BarEnd-Right Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BSCKCABINETBARENDL) {
		sprint(player, "Furniture-Cabinet-Basic-BarEnd-Left Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SHELVES) {
		sprint(player, "Furniture-Shelves Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FILECABINET) {
		sprint(player, "Furniture-FileCabinet Cost:^x000 100 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_FUTON) {
		sprint(player, "Furniture-Futon Cost:^x000 250 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BED) {
		sprint(player, "Furniture-Bed Cost:^x000 450 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 450
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 450;
			player.rtnvl2 = 450;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_BED_FOAM) {
		sprint(player, "Furniture-Bed-Foam Cost:^x000 250 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_SERVER) {
		sprint(player, "Furniture-Server Cost:^x000 1000 Converted Nails^7 + ^x30D 400 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentc >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentc -= 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_LAMP_STREET) {
		sprint(player, "Furniture-StreetLamp Cost:^x000 500 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_LAMP_STREET2) {
		sprint(player, "Furniture-StreetLamp2 Cost:^x000 500 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_LAMP_STREET3) {
		sprint(player, "Furniture-StreetLamp3 Cost:^x000 500 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_LAMP_STREET4) {
		sprint(player, "Furniture-StreetLamp4 Cost:^x000 500 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_LAMP_STREET5) {
		sprint(player, "Furniture-StreetLamp5 Cost:^x000 500 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 100
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 100;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_COMCRATE) {
		sprint(player, "Furniture-ComCrate Cost:^x000 2000 Converted Nails^7 + ^x30D 400 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2000
		&&  player.multitool_ammocurrentc >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.multitool_ammocurrentc -= 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_COMCRATE2) {
		sprint(player, "Furniture-ComCrate2 Cost:^x000 4000 Converted Nails^7 + ^x30D 400 Converted Cells^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 4000
		&&  player.multitool_ammocurrentc >= 400
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 4000;
			player.rtnvl2 = 4000;
			player.multitool_ammocurrentc -= 400;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FURN_MTLCRATE) {
		sprint(player, "Furniture-MetalCrate Cost:^x000 3 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 3
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 3;
			player.rtnvl2 = 3;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_WINDOW_FUTURE || player.multitool_setting == MTB64U_WINDOW_FUTURE_X) {
		sprint(player, "Block-64x64-Window Colored Cost:^x000 10 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 10
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 10;
			player.rtnvl2 = 10;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64_CLAIMSTONE || player.multitool_setting == MTB64U_CLAIMSTONE) {
		sprint(player, "Block-64x64-ClaimStone Cost:^x000 1350 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
		
		//Claimstone: costs abit more than garrison
		
		if (player.multitool_ammocurrent >= 1350
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1350;
			player.rtnvl2 = 1350;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_XBEAM_UP || player.multitool_setting == MTB64U_XBEAM_OVER) {
		sprint(player, "Block-64x64-XBeam Cost:^x000 8 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 8
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 8;
			player.rtnvl2 = 8;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FLOOR_MTRUSS) {
		sprint(player, "Block-64x64-Floor Truss:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_BWIRE) {
		sprint(player, "Block-64x64-BarbedWire:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_BWIRE_X) {
		sprint(player, "Block-64x64-BarbedWire X:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_BWIRE_O) {
		sprint(player, "Block-64x64-BarbedWire O:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_DOOR_R_PLAIN) {
		sprint(player, "Door-64x64-Plain:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_DOOR_R_PLAIN2) {
		sprint(player, "Door-64x64-Plain-White:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_DOOR_R_STEEL) {
		sprint(player, "Door-64x64-Steel:^x000 16 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 16
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 16;
			player.rtnvl2 = 16;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_DOOR_R_GLASS) {
		sprint(player, "Door-64x64-Glass:^x000 40 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 40
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 40;
			player.rtnvl2 = 40;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FITTEDWINDOW_STEELSLIT) {
		sprint(player, "FittedWindow-64-SteelGunLoop:^x000 15 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 15
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 15;
			player.rtnvl2 = 15;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FITTEDWINDOW_STEELPLATE) {
		sprint(player, "FittedWindow-64-SteelPlate:^x000 14 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 14
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 14;
			player.rtnvl2 = 14;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FITTEDWINDOW_CWALL) {
		sprint(player, "FittedWindow-64-SolidWall-Concrete:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == MTB64U_FITTEDWINDOW_UWINDOW) {
		sprint(player, "FittedWindow-64-Glass:^x000 38 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 38
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 38;
			player.rtnvl2 = 38;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting >= MTB64U_METAL && player.multitool_setting <= MTB64U_METALLAST) {
		sprint(player, "Block-64x64-MetalTruss Cost:^x000 1 Converted Nail^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting >= MTB64_HEDGE && player.multitool_setting <= MTB64_HEDGELAST) {
		sprint(player, "Block-64x64-Hedge Cost:^x000 1 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 1;
			player.rtnvl2 = 1;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_POLISH && player.multitool_setting <= MTB64_POLISHLAST) {
		sprint(player, "Block-64x64-Polish Cost:^x000 5 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 5
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 5;
			player.rtnvl2 = 5;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_GRAYSTONE && player.multitool_setting <= MTB64_GRAYSTONELAST) {
		sprint(player, "Block-64x64-GrayStone Cost:^x000 5 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 5
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 5;
			player.rtnvl2 = 5;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONEDARK) {
		sprint(player, "Block-64x64-SandstoneDark Cost:^x000 5 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE) {
		sprint(player, "Block-64x64-SandstoneLight Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_CASING) {
		sprint(player, "Block-64x64-SandstoneLight Casing Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_SCASING) {
		sprint(player, "Block-64x64-SandstoneLight SideCasing Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_PYR) {
		sprint(player, "Block-64x64-SandstoneLight Pyramidion Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_CORNER) {
		sprint(player, "Block-64x64-SandstoneLight Corner Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_RCORNER) {
		sprint(player, "Block-64x64-SandstoneLight RoundCorner Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_STAIRS) {
		sprint(player, "Block-64x64-SandstoneLight Stairs Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_ICASING) {
		sprint(player, "Block-64x64-SandstoneLight CasingInside Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_OS) {
		sprint(player, "Block-64x64-SandstoneLight Octoside Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == MTB64_SANDSTONE_OS2) {
		sprint(player, "Block-64x64-SandstoneLight Octoside2 Cost:^x000 6 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 6
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 6;
			player.rtnvl2 = 6;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_SHINGLES2 && player.multitool_setting <= MTB64_SHINGLES2LAST) {
		sprint(player, "Block-64x64-Shingles Cost:^x000 2 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 2;
			player.rtnvl2 = 2;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting >= MTB64_MARBLEWHITE && player.multitool_setting <= MTB64_MARBLEWHITELAST) {
		sprint(player, "Block-64x64-Marble Cost:^x000 50 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 50
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 50;
			player.rtnvl2 = 50;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//curtain.bsp";
	} else if (player.multitool_setting == -3) {
		sprint(player, "Shrine Cost:^x000 975 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 975
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 975;
			player.rtnvl2 = 975;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//shrine.bsp";
	} else if (player.multitool_setting == -4) {
		sprint(player, "Shrine Cost:^x000 900 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 900
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 900;
			player.rtnvl2 = 900;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//dojo.bsp";
	} else if (player.multitool_setting == -2) {
		sprint(player, "House Cost:^x000 275 Converted Nails^7 + ^xFF7 25 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 275
		&&  player.ammo_nails >= 25) {
			player.multitool_ammocurrent -= 275;
			player.rtnvl2 = 275;
			player.ammo_nails -= 25;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//house.bsp";
	} else if (player.multitool_setting == -609) {
		sprint(player, "Floor Wooden Stakes Cost:^x000 210 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 210
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 210;
			player.rtnvl2 = 210;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting == -610) {
		sprint(player, "Floor Iron Spikes Cost:^x000 1725 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1725
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1725;
			player.rtnvl2 = 1725;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting == -615) {
		sprint(player, "Floor Trap Door Cost:^x000 1900 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1900
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1900;
			player.rtnvl2 = 1900;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";	
	} else if (player.multitool_setting == -618) {
		sprint(player, "Floor Trap Grate Cost:^x000 1800 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting <= -600 && player.multitool_setting > -620) {
		sprint(player, "Floor Wooden Cost:^x000 200 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting <= -620 && player.multitool_setting > -640) {
		sprint(player, "Floor Stone Cost:^x000 400 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";	
	} else if (player.multitool_setting <= -640 && player.multitool_setting > -670) {
		sprint(player, "Floor Tiled Cost:^x000 600 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting <= -670 && player.multitool_setting > -700) {
		sprint(player, "Floor Granite Cost:^x000 1800 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	} else if (player.multitool_setting <= -700 && player.multitool_setting > -760) {
		sprint(player, "Floor Marble Cost:^x000 2200 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2200
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 2200;
			player.rtnvl2 = 2200;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";	
	} else if (player.multitool_setting <= -760 && player.multitool_setting > -800) {
		sprint(player, "Floor Roman Marble Cost:^x000 2800 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2800
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 2800;
			player.rtnvl2 = 2800;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//floor.bsp";
	
	
	} else if (player.multitool_setting == 1001) {
		sprint(player, "CommandPost Cost:^x000 850 Converted Nails^7 + ^xFF7 40 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 850
		&&  player.ammo_nails >= 40) {
			player.multitool_ammocurrent -= 850;
			player.rtnvl2 = 850;
			player.ammo_nails -= 40;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//commandpost.bsp";
	} else if (player.multitool_setting == 1002) {
		sprint(player, "ShieldGen Cost:^x000 100 Converted Nails^7 + ^x30D 900 Converted Cells^7 +^x70F 110 Free Cells^7  + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 100
		&&  player.multitool_ammocurrentc >= 900
		&&  player.ammo_nails >= 20
		&&  player.ammo_cells >= 110) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.multitool_ammocurrentc -= 900;
			player.ammo_nails -= 20;
			player.ammo_cells -= 110;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//shieldgen.bsp";
	} else if (player.multitool_setting == 1003) {
		sprint(player, "Shelter Cost:^x000 200 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//house.bsp";
	} else if (player.multitool_setting == 1004) {
		sprint(player, "GlassBase Cost:^x000 1800 Converted Nails^7 + ^xFF7 40 Free Nails^7 + ^x70F 110 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 1800
		&&  player.ammo_nails >= 40
		&&  player.ammo_cells >= 110) {
			player.multitool_ammocurrent -= 1800;
			player.rtnvl2 = 1800;
			player.ammo_nails -= 40;
			player.ammo_cells -= 110;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//arsenal.bsp";
	} else if (player.multitool_setting == 1005) {
		sprint(player, "MilHangar Cost:^x000 1000 Converted Nails^7 + ^xE00 1500 Converted Rockets^7 + ^x30D 4000 Converted Cells^7 + ^xF41 150 Free Rockets^7 + ^x70F 110 Free Cells^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentr >= 1500
		&&  player.multitool_ammocurrentc >= 4000
		&&  player.ammo_rockets >= 150
		&&  player.ammo_cells >= 110
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentr -= 1500;
			player.multitool_ammocurrentc -= 4000;
			player.ammo_rockets -= 150;
			player.ammo_cells -= 110;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oldhangar.bsp";
	} else if (player.multitool_setting == 1006) {
		sprint(player, "SecurityBuilding Cost:^x000 2850 Converted Nails^7 + ^xFF7 40 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 2850
		&&  player.ammo_nails >= 40) {
			player.multitool_ammocurrent -= 2850;
			player.rtnvl2 = 2850;
			player.ammo_nails -= 40;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//commandpost.bsp";
	} else if (player.multitool_setting == 1007) {
		sprint(player, "TankPad Cost:^x000 1000 Converted Nails^7 + ^xE00 4500 Converted Rockets^7 + ^x30D 4500 Converted Cells^7 + ^xF41 150 Free Rockets^7 + ^x70F 110 Free Cells^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.multitool_ammocurrentr >= 4500
		&&  player.multitool_ammocurrentc >= 4500
		&&  player.ammo_rockets >= 150
		&&  player.ammo_cells >= 110
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.multitool_ammocurrentr -= 4500;
			player.multitool_ammocurrentc -= 4500;
			player.ammo_rockets -= 150;
			player.ammo_cells -= 110;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tankpad.bsp";
	} else if (player.multitool_setting == 1008) {
		sprint(player, "Stockpile Cost:^x000 400 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 400
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//stockpile.bsp";
	} else if (player.multitool_setting == 1009) {
		sprint(player, "AmmoDepot Cost:^x000 2000 Converted Nails^7 + ^xE00 2000 Converted Rockets^7 + ^x30D 2000 Converted Cells^7 + ^xF41 20 Free Rockets^7 + ^x70F 20 Free Cells^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 2000
		&&  player.multitool_ammocurrentr >= 2000
		&&  player.multitool_ammocurrentc >= 2000
		&&  player.ammo_rockets >= 20
		&&  player.ammo_cells >= 20
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 2000;
			player.rtnvl2 = 2000;
			player.multitool_ammocurrentr -= 2000;
			player.multitool_ammocurrentc -= 2000;
			player.ammo_rockets -= 20;
			player.ammo_cells -= 20;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//ammodepot.bsp";
	} else if (player.multitool_setting == 1010) {
		sprint(player, "OilTank Cost:^x000 240 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 240
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 240;
			player.rtnvl2 = 240;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1011) {
		sprint(player, "EnergyTank Cost:^x000 240 Converted Nails^7  + ^x30D 240 Converted Cells^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 240
		&& player.multitool_ammocurrentc >= 240
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 240;
			player.rtnvl2 = 240;
			player.multitool_ammocurrentc -= 240;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//energytank.bsp";
	} else if (player.multitool_setting == 1012) {
		sprint(player, "Apartments Cost:^x000 1200 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1200
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1200;
			player.rtnvl2 = 1200;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//apartments.bsp";
	} else if (player.multitool_setting == 1013) {
		sprint(player, "Turret-FLAC Cost:^x000 200 Converted Nails^7 + ^xE00 1800 Converted Rockets^7 + ^xF41 125 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 200
		&&  player.multitool_ammocurrentr >= 1800
		&&  player.ammo_rockets >= 125) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.multitool_ammocurrentr -= 1800;
			player.ammo_rockets -= 125;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tur_raised.bsp";
	} else if (player.multitool_setting == 1014) {
		sprint(player, "Turret-MLRS Cost:^x000 200 Converted Nails^7 + ^xE00 3200 Converted Rockets^7 + ^xF41 150 Free Rockets^7\n");

		if (player.multitool_ammocurrent >= 200
		&&  player.multitool_ammocurrentr >= 3200
		&&  player.ammo_rockets >= 150) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.multitool_ammocurrentr -= 3200;
			player.ammo_rockets -= 150;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tur_medium.bsp";
	} else if (player.multitool_setting == 1038) {
		sprint(player, "Turret-AutoSHLAC Cost:^x000 200 Converted Nails^7 + ^x30D 1800 Converted Cells^7 + ^x70F 125 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 200
		&&  player.multitool_ammocurrentc >= 1800
		&&  player.ammo_cells >= 125) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.multitool_ammocurrentc -= 1800;
			player.ammo_cells -= 125;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tur_raised.bsp";
	} else if (player.multitool_setting == 1015) {
		sprint(player, "OilPump Cost:^x000 180 Converted Nails^7 + ^xE00 750 Converted Rockets^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 180
		&&  player.multitool_ammocurrentr >= 750
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 180;
			player.rtnvl2 = 180;
			player.multitool_ammocurrentr -= 750;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//solarpanel.bsp";
	} else if (player.multitool_setting == 1016) {
		sprint(player, "ChemicalPlant1 Cost:^x000 960 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 960
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 960;
			player.rtnvl2 = 960;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1017) {
		sprint(player, "ChemicalPlant2 Cost:^x000 960 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 960
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 960;
			player.rtnvl2 = 960;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1018) {
		sprint(player, "ChemicalPlant3 Cost:^x000 960 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 960
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 960;
			player.rtnvl2 = 960;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1019) {
		sprint(player, "MunitionsFactory Cost:^x000 1000 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1020) {
		sprint(player, "SentryTower Cost:^x000 216 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 216
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 216;
			player.rtnvl2 = 216;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//sentry_raised.bsp";
	} else if (player.multitool_setting == 1021) {
		sprint(player, "Furnace Cost:^x000 600 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//furnace.bsp";
	} else if (player.multitool_setting == 1022) {
		sprint(player, "OfficeTower Cost:^x000 1500 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1023) {
		sprint(player, "FireSupression Cost:^x000 1300 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1300
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1300;
			player.rtnvl2 = 1300;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1024) {
		sprint(player, "OfficeTower2 Cost:^x000 1500 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1025) {
		sprint(player, "TensionWireTower Cost:^x000 975 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 975
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 975;
			player.rtnvl2 = 975;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//sentry_raised.bsp";
	} else if (player.multitool_setting == 1026) {
		sprint(player, "OfficeTower3 Cost:^x000 1500 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1027) {
		sprint(player, "APCPad Cost:^x000 300 Converted Nails^7 + ^x30D 100 Converted Cells^7 + ^x70F 50 Free Cells^7 + ^xFF7 50 Free Nails^7\n");
		//sprint(player, "APCPad Cost:^x000 300 Converted Nails^7 + ^xE00 100 Converted Rockets^7 + ^x30D 100 Converted Cells^7 + ^xF41 25 Free Rockets^7 + ^x70F 50 Free Cells^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 300
		//&&  player.multitool_ammocurrentr >= 100
		&&  player.multitool_ammocurrentc >= 100
		//&&  player.ammo_rockets >= 25
		&&  player.ammo_cells >= 50
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.multitool_ammocurrentr -= 100;
			//player.multitool_ammocurrentc -= 100;
			//player.ammo_rockets -= 25;
			player.ammo_cells -= 50;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tankpad.bsp";
	} else if (player.multitool_setting == 1028) {
		sprint(player, "CoveredGarage Cost:^x000 600 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1029) {
		sprint(player, "BulldozerPad Cost:^x000 350 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 350
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 350;
			player.rtnvl2 = 350;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1030) {
		sprint(player, "Local Energy Battery Cost:^x000 60 Converted Nails^7  + ^x30D 10 Converted Cells^7 + ^xFF7 10 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 60
		&& player.multitool_ammocurrentc >= 10
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 60;
			player.rtnvl2 = 60;
			player.multitool_ammocurrentc -= 60;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//energytank.bsp";
	} else if (player.multitool_setting == 1032) {
		sprint(player, "Local OilTank Cost:^x000 60 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 60
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 60;
			player.rtnvl2 = 60;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";
	} else if (player.multitool_setting == 1033) {
		sprint(player, "Oil Distribution Control:^x000 600 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";	
	} else if (player.multitool_setting == 1034) {
		sprint(player, "Chemical Distribution Control:^x000 700 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 700
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 700;
			player.rtnvl2 = 700;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//oiltank.bsp";	
	} else if (player.multitool_setting == 1035) {
		sprint(player, "Combat-Suit Pad Cost:^x000 250 Converted Nails^7 + ^xE00 450 Converted Rockets^7 + ^xF41 15 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 250
		&&  player.multitool_ammocurrentr >= 450
		&&  player.ammo_rockets >= 15
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.multitool_ammocurrentr -= 450;
			player.ammo_rockets -= 15;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//suitpad.bsp";
	} else if (player.multitool_setting == 1031) {
		sprint(player, "CanopyShieldGen Cost:^x000 100 Converted Nails^7 + ^x30D 900 Converted Cells^7 +^x70F 110 Free Cells^7  + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 100
		&&  player.multitool_ammocurrentc >= 900
		&&  player.ammo_nails >= 20
		&&  player.ammo_cells >= 110) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.multitool_ammocurrentc -= 900;
			player.ammo_nails -= 20;
			player.ammo_cells -= 110;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//shieldgen.bsp";
	} else if (player.multitool_setting == 1036) {
		sprint(player, "Hammer-Forge Cost:^x000 600 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1037) {
		sprint(player, "ObservationTower Cost:^x000 1250 Converted Nails^7 + ^xFF7 20 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1250
		&&  player.ammo_nails >= 20) {
			player.multitool_ammocurrent -= 1250;
			player.rtnvl2 = 1250;
			player.ammo_nails -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1510) {
		sprint(player, "SolarPanel Cost:^x000 200 Converted Nails^7 + ^x30D 1000 Converted Cells^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 200
		&&  player.multitool_ammocurrentc >= 1000
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.multitool_ammocurrentc -= 1000;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//solarpanel.bsp";
	} else if (player.multitool_setting == 1110) {
		sprint(player, "Point Defense SHLAC:^x000 200 Converted Nails^7 + ^x30D 300 Converted Cells^7 + ^x70F 10 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 200
		&&  player.multitool_ammocurrentc >= 300
		&&  player.ammo_cells >= 10) {
			player.multitool_ammocurrent -= 200;
			player.rtnvl2 = 200;
			player.multitool_ammocurrentc -= 300;
			player.ammo_cells -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1111) {
		sprint(player, "Point Defense AutoNex:^x000 250 Converted Nails^7 + ^x30D 400 Converted Cells^7 + ^x70F 10 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 250
		&&  player.multitool_ammocurrentc >= 400
		&&  player.ammo_cells >= 10) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.multitool_ammocurrentc -= 400;
			player.ammo_cells -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1112) {
		sprint(player, "Point Defense GRail:^x000 300 Converted Nails^7 + ^x30D 600 Converted Cells^7 + ^x70F 10 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 300
		&&  player.multitool_ammocurrentc >= 600
		&&  player.ammo_cells >= 10) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.multitool_ammocurrentc -= 600;
			player.ammo_cells -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1113) {
		sprint(player, "Point Defense BPCannon:^x000 400 Converted Nails^7 + ^x30D 500 Converted Cells^7 + ^x70F 20 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 400
		&&  player.multitool_ammocurrentc >= 500
		&&  player.ammo_cells >= 20) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.multitool_ammocurrentc -= 500;
			player.ammo_cells -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1114) {
		sprint(player, "Point Defense MHB50 Cost:^x000 500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1115) {
		sprint(player, "Point Defense M134 Cost:^x000 500 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1116) {
		sprint(player, "Point Defense GAU19 Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1117) {
		sprint(player, "Point Defense T17MM Cost:^x000 600 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 600
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 600;
			player.rtnvl2 = 600;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1118) {
		sprint(player, "Point Defense LaserCannon:^x000 400 Converted Nails^7 + ^x30D 800 Converted Cells^7 + ^x70F 20 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 400
		&&  player.multitool_ammocurrentc >= 800
		&&  player.ammo_cells >= 20) {
			player.multitool_ammocurrent -= 400;
			player.rtnvl2 = 400;
			player.multitool_ammocurrentc -= 800;
			player.ammo_cells -= 20;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1120) {
		sprint(player, "Mannable Energy Turret Cost:^x000 500 Converted Nails^7 + ^x30D 1000 Converted Cells^7 + ^x70F 110 Free Cells^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentc >= 1000
		&&  player.ammo_cells >= 110) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 1000;
			player.ammo_cells -= 110;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1121) {
		sprint(player, "Mannable GRail Turret Cost:^x000 500 Converted Nails^7 + ^x30D 140 Converted Cells^7 + ^x70F 80 Free Cells^7\n");
		if (player.multitool_ammocurrent >= 140
		&&  player.multitool_ammocurrentc >= 200
		&&  player.ammo_cells >= 80) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentc -= 140;
			player.ammo_cells -= 80;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1122) {
		sprint(player, "Mannable T17mm Turret Cost:^x000 500 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1123) {
		sprint(player, "Mannable AA Turret Cost:^x000 500 Converted Nails^7 + ^xE00 800 Converted Rockets^7 + ^xF41 50 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentr >= 800
		&&  player.ammo_rockets >= 50
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentr -= 800;
			player.ammo_rockets -= 50;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1124) {
		sprint(player, "Mannable RAA Turret Cost:^x000 500 Converted Nails^7 + ^xFF7 200 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.ammo_nails >= 200) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.ammo_nails -= 200;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1125) {
		sprint(player, "Mannable AI Turret Cost:^x000 500 Converted Nails^7 + ^xE00 500 Converted Rockets^7 + ^xF41 150 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentr >= 500
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentr -= 500;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1126) {
		sprint(player, "Mannable HEAT Turret Cost:^x000 500 Converted Nails^7 + ^xE00 1000 Converted Rockets^7 + ^xF41 150 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentr >= 1000
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentr -= 1000;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1127) {
		sprint(player, "Mannable Cannon Turret Cost:^x000 500 Converted Nails^7 + ^xE00 1500 Converted Rockets^7 + ^xF41 150 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 500
		&&  player.multitool_ammocurrentr >= 1500
		&&  player.ammo_rockets >= 150
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 500;
			player.rtnvl2 = 500;
			player.multitool_ammocurrentr -= 1500;
			player.ammo_rockets -= 150;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//pylon.bsp";
	} else if (player.multitool_setting == 1130) {
		sprint(player, "Tower T17mm Turret Cost:^x000 700 Converted Nails^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 700
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 700;
			player.rtnvl2 = 700;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//mantur_raised.bsp";
	} else if (player.multitool_setting == 1131) {
		sprint(player, "Tower AA Turret Cost:^x000 700 Converted Nails^7 + ^xE00 800 Converted Rockets^7 + ^xF41 50 Free Rockets^7 + ^xFF7 50 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 700
		&&  player.multitool_ammocurrentr >= 800
		&&  player.ammo_rockets >= 50
		&&  player.ammo_nails >= 50) {
			player.multitool_ammocurrent -= 700;
			player.rtnvl2 = 700;
			player.multitool_ammocurrentr -= 800;
			player.ammo_rockets -= 50;
			player.ammo_nails -= 50;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//mantur_raised.bsp";
	} else if (player.multitool_setting == 1501) {
		sprint(player, "Greenhouse Cost:^x000 120 Converted Nails^7 + ^xFF7 2 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 120
		&&  player.ammo_nails >= 2) {
			player.multitool_ammocurrent -= 120;
			player.rtnvl2 = 120;
			player.ammo_nails -= 2;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//field.bsp";
	} else if (player.multitool_setting == 1502) {
		sprint(player, "Recruitment Post Cost:^x000 25 Converted Nails^7 + ^xFF7 1 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 25
		&&  player.ammo_nails >= 1) {
			player.multitool_ammocurrent -= 25;
			player.rtnvl2 = 25;
			player.ammo_nails -= 1;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else if (player.multitool_setting == 1520) {
		sprint(player, "Fence-Mil Cost:^x000 50 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 50
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 50;
			player.rtnvl2 = 50;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//fencemil.bsp";
	} else if (player.multitool_setting == 1521) {
		sprint(player, "Fence-Mil-Tower Cost:^x000 100 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//fencemil tower.bsp";
	} else if (player.multitool_setting == 1522) {
		sprint(player, "Fence-Mil-Gate-Small Cost:^x000 50 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 50
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 50;
			player.rtnvl2 = 50;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//fencemil.bsp";
	} else if (player.multitool_setting == 1523) {
		sprint(player, "Fence-Mil-Gate-Large Cost:^x000 50 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 50
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 50;
			player.rtnvl2 = 50;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//fencemil.bsp";
	} else if (player.multitool_setting == 1524) {
		sprint(player, "F-M-MovingGate Cost:^x000 60 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
		
		//Costs more for mechanism
		
		if (player.multitool_ammocurrent >= 60
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 60;
			player.rtnvl2 = 60;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//fencemil.bsp";
	} else if (player.multitool_setting == 1530) {
		sprint(player, "Wall-Concrete Cost:^x000 230 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 230
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 230;
			player.rtnvl2 = 230;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1531) {
		sprint(player, "Wall-Concrete-Tower Cost:^x000 280 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 280
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 280;
			player.rtnvl2 = 280;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete tower.bsp";
	} else if (player.multitool_setting == 1532) {
		sprint(player, "Wall-Concrete-Gate-Small Cost:^x000 230 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 230
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 230;
			player.rtnvl2 = 230;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1533) {
		sprint(player, "Wall-Concrete-Gate-Large Cost:^x000 230 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 230
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 230;
			player.rtnvl2 = 230;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1534) {
		sprint(player, "Wall-Concrete-Tall Cost:^x000 260 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 260
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 260;
			player.rtnvl2 = 260;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1535) {
		sprint(player, "Wall-Concrete-Tall-Stairs Cost:^x000 260 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 260
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 260;
			player.rtnvl2 = 260;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1536) {
		sprint(player, "Wall-Concrete-Tall-Tower Cost:^x000 340 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 360
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 360;
			player.rtnvl2 = 360;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete tower.bsp";
	} else if (player.multitool_setting == 1537) {
		sprint(player, "Wall-Concrete-Taller-Tower Cost:^x000 440 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 440
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 440;
			player.rtnvl2 = 440;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete tower.bsp";
	} else if (player.multitool_setting == 1538) {
		sprint(player, "Wall-Concrete-Fill Cost:^x000 230 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 230
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 230;
			player.rtnvl2 = 230;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1539) {
		sprint(player, "Wall-Concrete-Fill-Ramp Cost:^x000 290 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 290
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 290;
			player.rtnvl2 = 290;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1540) {
		sprint(player, "Wall-Concrete-Interior Cost:^x000 115 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 115
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 115;
			player.rtnvl2 = 115;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1541) {
		sprint(player, "Wall-Concrete-Interior-Door Cost:^x000 115 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 115
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 115;
			player.rtnvl2 = 115;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1542) {
		sprint(player, "Wall-Concrete-Tall-Gate-Small Cost:^x000 260 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 260
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 260;
			player.rtnvl2 = 260;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1543) {
		sprint(player, "Wall-Concrete-Tall-Gate-Large Cost:^x000 260 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 260
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 260;
			player.rtnvl2 = 260;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1546) {
		sprint(player, "W-C-MovingGate-Steel Cost:^x000 100 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
		
		//Not as much stuff as a concrete wall, costs less, but there is a mechanism
		
		if (player.multitool_ammocurrent >= 100
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 100;
			player.rtnvl2 = 100;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1548) {
		sprint(player, "Wall-Concrete-Tall-Berm Cost:^x000 340 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 340
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 340;
			player.rtnvl2 = 340;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1549) {
		sprint(player, "Wall-Concrete-Berm Cost:^x000 300 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1550) {
		sprint(player, "Obstruction-TankPyrs Cost:^x000 300 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 300
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 300;
			player.rtnvl2 = 300;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tank_pyramid.bsp";
	} else if (player.multitool_setting == 1551) {
		sprint(player, "Obstruction-TankPier Cost:^x000 450 Converted Nails^7 + ^xFF7 10 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 450
		&&  player.ammo_nails >= 10) {
			player.multitool_ammocurrent -= 450;
			player.rtnvl2 = 450;
			player.ammo_nails -= 10;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//tankpier.bsp";
	} else if (player.multitool_setting == 1630) {
		sprint(player, "Foundation-Wall-Concrete Cost:^x000 1000 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1000
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1000;
			player.rtnvl2 = 1000;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1631) {
		sprint(player, "Foundation-Tower-Concrete Cost:^x000 1200 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1200
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1200;
			player.rtnvl2 = 1200;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == 1650) {
		sprint(player, "Bridge-Tread-Landing Cost:^x000 1050 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1050
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1050;
			player.rtnvl2 = 1050;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1651) {
		sprint(player, "Bridge-Tread Cost:^x000 950 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 950
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 950;
			player.rtnvl2 = 950;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1652) {
		sprint(player, "Bridge-Shield Cost:^x000 250 Converted Nails^7 + ^x30D 150 Converted Cells^7 +^x70F 110 Free Cells^7  + ^xFF7 5 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 250
		&&  player.multitool_ammocurrentc >= 150
		&&  player.ammo_nails >= 5
		&&  player.ammo_cells >= 110) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.multitool_ammocurrentc -= 150;
			player.ammo_nails -= 5;
			player.ammo_cells -= 110;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1653) {
		sprint(player, "Bridge-Shield-Control Cost:^x000 1100 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 1100
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 1100;
			player.rtnvl2 = 1100;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1680) {
		sprint(player, "Vault-Metal Cost:^x000 250 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1681) {
		sprint(player, "Vault-Metal-Vent Cost:^x000 250 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 250
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 250;
			player.rtnvl2 = 250;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//bridge.bsp";
	} else if (player.multitool_setting == 1686) {
		sprint(player, "Vault-Concrete Cost:^x000 230 Converted Nails^7 + ^xFF7 5 Free Nails^7\n");
	
		if (player.multitool_ammocurrent >= 230
		&&  player.ammo_nails >= 5) {
			player.multitool_ammocurrent -= 230;
			player.rtnvl2 = 230;
			player.ammo_nails -= 5;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//concrete.bsp";
	} else if (player.multitool_setting == -5) {
		sprint(player, "BellTower Cost:^x000 1500 Converted Nails^7 + ^xFF7 75 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 75) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 75;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
	} else {
		sprint(player, "SniperSpire Cost:^x000 1500 Converted Nails^7 + ^xFF7 75 Free Nails^7\n");

		if (player.multitool_ammocurrent >= 1500
		&&  player.ammo_nails >= 75) {
			player.multitool_ammocurrent -= 1500;
			player.rtnvl2 = 1500;
			player.ammo_nails -= 75;
		} else {
			spamsound (self, CH_SHOTS, "weapons/dryfire.wav", VOL_BASE * 0.20, ATTN_NORM);
			return FALSE;
		}
		//sniperspire.bsp";
	}
	
	multitool_updateammo();
	return TRUE;
}

float multitool_CheckIfNearBuilding(vector tlendorig, float srchrad)
{
	entity f;
		f = findradius(tlendorig, srchrad);
  		while(f)
  		{
			if (f.classname == "building")
			{
			  if (f.origin != tlendorig) {
			  	//print("found block or building not me\n");
				if not(multitool_isfurniture(f.count)) {
					//If found building is not furniture, we've found a building of ours in the vicinity
					return TRUE;
				}
			  }
			}
    			f = f.chain;
  		}
		return FALSE;	
}

//Returns False if any point not in solid;
//For checking if a controlpoint is encased in concrete etc, in that case don't lock down etc.
float multitool_CheckControlPointTotallyInSolid(entity mycontrolpoint)
{
	local vector forigin;
	
	//Center
	forigin = mycontrolpoint.origin;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + forigin_z + mycontrolpoint.maxs_z;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + forigin_z + (mycontrolpoint.maxs_z * 0.5);
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	//Mins
	forigin = mycontrolpoint.origin + mycontrolpoint.mins;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.mins;
	forigin_x = forigin_x + mycontrolpoint.maxs_x;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.mins;
	forigin_y = forigin_y + mycontrolpoint.maxs_y;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.mins;
	forigin_x = forigin_x + mycontrolpoint.maxs_x;
	forigin_y = forigin_y + mycontrolpoint.maxs_y;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	
	//Maxs
	forigin = mycontrolpoint.origin + mycontrolpoint.maxs;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.maxs;
	forigin_x = forigin_x + mycontrolpoint.mins_x;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.maxs;
	forigin_y = forigin_y + mycontrolpoint.mins_y;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin + mycontrolpoint.maxs;
	forigin_x = forigin_x + mycontrolpoint.mins_x;
	forigin_y = forigin_y + mycontrolpoint.mins_y;
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	
	//Intermediary
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + (mycontrolpoint.maxs_x * 0.5);
	forigin_x = forigin_x + (mycontrolpoint.mins_x * 0.5);
	forigin_y = forigin_y + (mycontrolpoint.mins_y * 0.5);
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + (mycontrolpoint.maxs_x * 0.5);
	forigin_x = forigin_x + (mycontrolpoint.maxs_x * 0.5);
	forigin_y = forigin_y + (mycontrolpoint.mins_y * 0.5);
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + (mycontrolpoint.maxs_x * 0.5);
	forigin_x = forigin_x + (mycontrolpoint.mins_x * 0.5);
	forigin_y = forigin_y + (mycontrolpoint.maxs_y * 0.5);
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	forigin = mycontrolpoint.origin;
	forigin_z = forigin_z + (mycontrolpoint.maxs_x * 0.5);
	forigin_x = forigin_x + (mycontrolpoint.maxs_x * 0.5);
	forigin_y = forigin_y + (mycontrolpoint.maxs_y * 0.5);
	if (pointcontents (forigin) != CONTENT_SOLID) {
		return FALSE;
	}
	
	// End
	return TRUE;
}


//Is the control point encased in solid?
float multitool_controlpointencased(entity mybuilding)
{		
	local entity mycontrolpoint;
	
	if (autocvar_g_balance_multitool_allowencasedcontrolpointtolockdown)
	{
		//As you wish, control points (of the appropriate buildings)
		//totally encased and inaccessable
		//will still lock down the area
		return FALSE;	
	}
	
	mycontrolpoint = world;
		
	//Could have done a loop, but would rather be careful and exact
	if (mybuilding.owner.subordinate
	&& (mybuilding.owner.subordinate != world)
	 && mybuilding.owner.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate
		&& mybuilding.owner.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
	} else if (mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate
		&&(mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate != world)
		&& mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.multitool_iscontrolpoint)
	{
		mycontrolpoint = mybuilding.owner.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate.subordinate;
												
	} else {
		//Shouldn't get here, put your control points as some reasonable .subordinate
		//Atleast on castle/stronghold/commandpost/etc that lock down the area
		print("Could not find control point, returning not encased in solid\n");
	}
	
	if (mycontrolpoint == world) {
		return FALSE;
	}


	if (time > mycontrolpoint.multitool_isencasedinsolidnextcheck) {
		mycontrolpoint.multitool_isencasedinsolidnextcheck = time + 30;
		if (multitool_CheckControlPointTotallyInSolid(mycontrolpoint)) {
				//print("ControlPoint found to be in solid, no lock down");
			mycontrolpoint.multitool_isencasedinsolid = 1;
			return TRUE;
		} else {
				//print("ControlPoint not totally in solid, continue");
			mycontrolpoint.multitool_isencasedinsolid = 0;
			return FALSE;
		}
	} else if (mycontrolpoint.multitool_isencasedinsolid) {
			//print("Declared in solid, will believe for the next small while\n");
		return TRUE;
	}
	
	return FALSE;
}


//Returns True if any point is in lava;
//For checking if a hitbox etc it touching lava.
//Usually called after creation of the building hitbox and after checking if wooden
float multitool_CheckIsTouchingLava(entity myhitbox, entity mymodel)
{
	local vector forigin;
	local float myreturn;
	local float myhitboxsolid;
	local float mymodelsolid;
	
	mymodelsolid = mymodel.solid;
	myhitboxsolid = myhitbox.solid;
	
	//Will change back later, must do this so we aren't testing
	//just the model or hitbox properties and actually do test the
	//surroundings
	mymodel.solid = SOLID_NOT;
	myhitbox.solid = SOLID_NOT;
	
	myreturn = 0;
	
	//Center
	forigin = myhitbox.origin;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin;
	forigin_z = forigin_z + forigin_z + myhitbox.maxs_z;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin;
	forigin_z = forigin_z + forigin_z + (myhitbox.maxs_z * 0.5);
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	//Mins
	forigin = myhitbox.origin + myhitbox.mins;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.mins;
	forigin_x = forigin_x + myhitbox.maxs_x;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.mins;
	forigin_y = forigin_y + myhitbox.maxs_y;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.mins;
	forigin_x = forigin_x + myhitbox.maxs_x;
	forigin_y = forigin_y + myhitbox.maxs_y;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	
	//Maxs
	forigin = myhitbox.origin + myhitbox.maxs;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.maxs;
	forigin_x = forigin_x + myhitbox.mins_x;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.maxs;
	forigin_y = forigin_y + myhitbox.mins_y;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin + myhitbox.maxs;
	forigin_x = forigin_x + myhitbox.mins_x;
	forigin_y = forigin_y + myhitbox.mins_y;
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	
	//Intermediary
	forigin = myhitbox.origin;
	forigin_z = forigin_z + (myhitbox.maxs_x * 0.5);
	forigin_x = forigin_x + (myhitbox.mins_x * 0.5);
	forigin_y = forigin_y + (myhitbox.mins_y * 0.5);
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin;
	forigin_z = forigin_z + (myhitbox.maxs_x * 0.5);
	forigin_x = forigin_x + (myhitbox.maxs_x * 0.5);
	forigin_y = forigin_y + (myhitbox.mins_y * 0.5);
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin;
	forigin_z = forigin_z + (myhitbox.maxs_x * 0.5);
	forigin_x = forigin_x + (myhitbox.mins_x * 0.5);
	forigin_y = forigin_y + (myhitbox.maxs_y * 0.5);
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	forigin = myhitbox.origin;
	forigin_z = forigin_z + (myhitbox.maxs_x * 0.5);
	forigin_x = forigin_x + (myhitbox.maxs_x * 0.5);
	forigin_y = forigin_y + (myhitbox.maxs_y * 0.5);
	if (pointcontents (forigin) == CONTENT_LAVA) {
		myreturn = 1;
	}
	
	//Reset
	mymodel.solid = mymodelsolid;
	myhitbox.solid = myhitboxsolid;
	
	// End
	return myreturn;
}


//This is for checking if thing will be totally in a solid.
//It will return the percentage of points found in solid.
float multitool_CheckInSolid(vector tlendorig, float srchrad) {
	local vector forigin;
	local float fcount;
	fcount = 0;
	
	//Center
	forigin = tlendorig;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	//6 corners
	//Top:
	forigin = tlendorig;
	forigin_x = forigin_x + srchrad;
	forigin_y = forigin_y + srchrad;
	forigin_z = forigin_z + srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	forigin = tlendorig;
	forigin_x = forigin_x + srchrad;
	forigin_y = forigin_y - srchrad;
	forigin_z = forigin_z + srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	forigin = tlendorig;
	forigin_x = forigin_x - srchrad;
	forigin_y = forigin_y - srchrad;
	forigin_z = forigin_z - srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	//Bottom:
	forigin = tlendorig;
	forigin_x = forigin_x + srchrad;
	forigin_y = forigin_y + srchrad;
	forigin_z = forigin_z - srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	forigin = tlendorig;
	forigin_x = forigin_x + srchrad;
	forigin_y = forigin_y - srchrad;
	forigin_z = forigin_z - srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	forigin = tlendorig;
	forigin_x = forigin_x - srchrad;
	forigin_y = forigin_y - srchrad;
	forigin_z = forigin_z - srchrad;
	if (pointcontents (forigin) == CONTENT_SOLID) {
		fcount = fcount + 1;
	}
	
	// End
	if (fcount == 0) {
		return 0; //Good
	} else {
		return((fcount/7)); //If it's 1 it's totally in a solid
	}
}

//This below checks if, say, a block to be added as a scaffold would be touching a world wall in the x or y direction
//It also has the option to trace up, and then a further option to trace down
//For each direction we will check if the vector traveled more than srchrad before
//colliding with the world model.
//Before doing this we will back up 32 qunits as blocks are 64x64 in size and we want to take
//into account the origin being on a world wall
//We take this 32 backup into account when computing if the vlen was too long (ex: (32 + srchrad))
float multitool_CheckIfNearWorld(vector tlendorig, float srchrad, float alsodoz)
{
	local vector forigin;
	local entity ftracer;
	local float fsflags;
	
	ftracer = spawn();
	//X pos
	ftracer.origin = tlendorig;
	//Offset to pullback 32 qu, so not near block origin
	//So we can detect even if block is stuck in wall 
	traceline(ftracer.origin - '32 0 0', ftracer.origin + '10000 0 0', MOVE_WORLDONLY, ftracer);
	forigin = trace_endpos;
	fsflags = trace_dphitq3surfaceflags;
	if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
		//X neg
		ftracer.origin = tlendorig; 
		traceline(ftracer.origin - '-32 0 0', ftracer.origin + '-10000 0 0', MOVE_WORLDONLY, ftracer);
		forigin = trace_endpos;
		fsflags = trace_dphitq3surfaceflags;
		if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
			//Y pos
			ftracer.origin = tlendorig; 
			traceline(ftracer.origin - '0 32 0', ftracer.origin + '0 10000 0', MOVE_WORLDONLY, ftracer);
			forigin = trace_endpos;
			fsflags = trace_dphitq3surfaceflags;
			if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
				//Y neg
				ftracer.origin = tlendorig; 
				traceline(ftracer.origin - '0 -32 0', ftracer.origin + '0 -10000 0', MOVE_WORLDONLY, ftracer);
				forigin = trace_endpos;
				fsflags = trace_dphitq3surfaceflags;
				if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
					if (alsodoz) {
						//Z pos
						ftracer.origin = tlendorig; 
						traceline(ftracer.origin - '0 0 32', ftracer.origin + '0 0 10000', MOVE_WORLDONLY, ftracer);
						forigin = trace_endpos;
						fsflags = trace_dphitq3surfaceflags;
						if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
							if (alsodoz >= 2) {
								//Z neg
								ftracer.origin = tlendorig; 
								traceline(ftracer.origin - '0 0 -32', ftracer.origin + '0 0 -10000', MOVE_WORLDONLY, ftracer);
								forigin = trace_endpos;
								fsflags = trace_dphitq3surfaceflags;
								if ( (vlen(tlendorig-forigin) > (32 + srchrad)) || (fsflags & Q3SURFACEFLAG_NOIMPACT) ) {
									//print("Not near z neg world wall either\n");
									remove (ftracer);
									return FALSE;
								} else {
									//print("Near enough to world wall\n");
									remove (ftracer);
									return TRUE;
								}
								////
							}
							//print("Not near z pos world wall either\n");
							remove (ftracer);
							return FALSE;
						} else {
							//print("Near enough to world wall\n");
							remove (ftracer);
							return TRUE;
						}
						////
					}
					//print("Not near world wall either\n");
					remove (ftracer);
					return FALSE;
				} else {
					//print("Near enough to world wall\n");
					remove (ftracer);
					return TRUE;
				}
				////
			} else {
				//print("Near enough to world wall\n");
				remove (ftracer);
				return TRUE;
			}
			////
		} else {
			//print("Near enough to world wall\n");
			remove (ftracer);
			return TRUE;
		}
		////
	} else {
		//print("Near enough to world wall\n");
		remove (ftracer);
		return TRUE;
	}
}


vector multitool_placetype_origin (entity player) {
	entity newtracer;
	vector traceedits;
	if (player.multitool_placetype) {
		newtracer = spawn();
		newtracer.origin = player.origin;
		newtracer.origin_z = newtracer.origin_z + player.view_ofs_z;
		makevectors(player.v_angle);
		traceline(newtracer.origin, newtracer.origin + v_forward * 160, MOVE_NORMAL, newtracer);
			float effectnum;
			//effectnum = particleeffectnum("fireball");
			effectnum = particleeffectnum("TE_TEI_G3");
			trailparticles(player, effectnum, player.origin, trace_endpos);
		remove(newtracer);
		traceedits = trace_endpos;
		//traceedits_z = trace_endpos_z + 2;
		return(traceedits);
	} else {
		return(player.origin);
	}
}



//To see if a spawnpoint is in the vicinity, too close to make more bed spawns near
float multitool_ownedspawnpoint_tooclose_ent(entity mysrchent, float myrad, entity myplayer)
{
	entity f;
	f = findradius(mysrchent.origin, myrad);
  	while(f)
  	{
		if (f != mysrchent)
		{
			if (f.classname == "info_player_deathmatch") {
				if (teamplay) {
					if (f.spawnpointisofbuildable) {
					  if (myplayer.team == f.team) {
					  	//print("TEAMBLTSPAWNPOINTTOOCLOSE\n");
						return TRUE;	
					  }
					}	
				} else {
					if (f.spawnpointisofbuildable) {
					  if (f.cntrlowner && f.cntrlowner.realowner) {
						if (myplayer == f.cntrlowner.realowner) {
							//print("PLYRBLTSPAWNPOINTTOOCLOSE\n");
			 				return TRUE;
						}
					  }
					}
				}
			}
		}
    		f = f.chain;
  	}
	return FALSE;
}


//To see if a centered door is in the vicinity
float multitool_doorcenteredtooclose_ent(entity mysrchent, float myrad)
{
	entity f;
	f = findradius(mysrchent.origin, myrad);
  	while(f)
  	{
		if (f != mysrchent)
		if (f.classname == "bldhitbx" || f.classname == "building")
		{
			//amnt is only found on scaffolds in this code
			if (multitool_isdoor(f.amnt) && f.multitool_doorcenter)
			{
				return TRUE;
			}
			
			if (multitool_isdoor(f.count) && f.multitool_doorcenter)
			{
				return TRUE;
			}
		} 
    		f = f.chain;
  	}
	return FALSE;
}

//To see if another door is too close to center a door
float multitool_doorcentertooclose(vector mysrchorigin, float myrad)
{
	entity f;
	f = findradius(mysrchorigin, myrad);
  	while(f)
  	{
		if (f.classname == "bldhitbx" || f.classname == "building")
		{
			//amnt is only found on scaffolds in this code
			if (multitool_isdoor(f.amnt))
			{
				return TRUE;
			}
			
			if (multitool_isdoor(f.count))
			{
				return TRUE;
			}
		} 
    		f = f.chain;
  	}
	return FALSE;
}

//This is for dropping furniature
vector multitool_fire_auto_dropfurn(vector my_tl_end, entity myplayer)
{
	if (myplayer.multitool_furndrop == autocvar_g_balance_multitool_furndropdefaultdisabled)
	{
		//If you want to use it with lockz, disable furndrop
		if(myplayer.multitool_lockz) {
			if ((clienttype(myplayer) == CLIENTTYPE_REAL)) {
				if (myplayer.multitool_annoymsgtime1 < time) {
					sprint(myplayer, "lockZ incompatable with furndrop, disable furndrop to lockZ for furniture, continuing\n");
					myplayer.multitool_annoymsgtime1 = time + 5;
				}
			}
		}
		local entity doorcentertracer;

		doorcentertracer = spawn();
	
		doorcentertracer.origin = my_tl_end;
		doorcentertracer.origin_z = myplayer.origin_z;
		setorigin(doorcentertracer, doorcentertracer.origin);
		traceline(doorcentertracer.origin + '0 0 2', doorcentertracer.origin + '0 0 -128', MOVE_NORMAL, doorcentertracer);
					
		my_tl_end_z = trace_endpos_z;
			
		remove(doorcentertracer);
		return my_tl_end;
	} else {
		return my_tl_end;
	}
}

//This is for dropping recruitment posts
vector multitool_fire_auto_droprecruitmentpost(vector my_tl_end)
{
		local entity doorcentertracer;

		doorcentertracer = spawn();
	
		doorcentertracer.origin = my_tl_end;

		setorigin(doorcentertracer, doorcentertracer.origin);
		traceline(doorcentertracer.origin + '0 0 2', doorcentertracer.origin + '0 0 -256', MOVE_NORMAL, doorcentertracer);
					
		my_tl_end_z = trace_endpos_z;
			
		remove(doorcentertracer);
		return my_tl_end;
}
	
//This is for centering a door in a frame or hallway
vector multitool_fire_auto_centerdoor(vector my_tl_end, entity myplayer)
{
	if (myplayer.multitool_lockz && myplayer.multitool_doorcenter == autocvar_g_balance_multitool_doorcenterdefaultdisabled)
	{
		if ((clienttype(myplayer) == CLIENTTYPE_REAL)) {
			if (myplayer.multitool_annoymsgtime2 < time) {
				sprint(myplayer, "doorcenter incompatable with lockZ, defaulting to normal placement\n");
				myplayer.multitool_annoymsgtime2 = time + 5;
				myplayer.multitool_annoymsgtime3 = 0; //So next time door can be centered it will be told
			}
		}
		return '0 0 0';	
	}
	else if (myplayer.multitool_doorcenter == autocvar_g_balance_multitool_doorcenterdefaultdisabled)
	{
		local float foundgoodspot;
		local vector mytlend0, mytlend1, mysnappedorigin;
		local entity doorcentertracer;
		
		foundgoodspot = 0;
		
		mysnappedorigin = myplayer.origin;
		mysnappedorigin_x = fsnap(mysnappedorigin_x, 8);
		mysnappedorigin_y = fsnap(mysnappedorigin_y, 8);
		
		doorcentertracer = spawn();
				
		doorcentertracer.angles = myplayer.angles;
		doorcentertracer.angles_y = myplayer.angles_y;
		
		if (myplayer.angles_y < 135 && myplayer.angles_y >= 45)
			doorcentertracer.angles_y = 90;
		else if (myplayer.angles_y < 45 && myplayer.angles_y >= -45)
			doorcentertracer.angles_y = 0;
		else if (myplayer.angles_y < -45 && myplayer.angles_y >= -135)
			doorcentertracer.angles_y = -90;
		else
			doorcentertracer.angles_y = 180;
					
		makevectors(doorcentertracer.angles);
				
		doorcentertracer.origin = mysnappedorigin;
		setorigin(doorcentertracer, doorcentertracer.origin);
		traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * 1000) , MOVE_NORMAL, doorcentertracer);
				
		mytlend0 = trace_endpos;
				
		doorcentertracer.origin = mysnappedorigin;
		setorigin(doorcentertracer, doorcentertracer.origin);
		traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * -1000), MOVE_NORMAL, doorcentertracer);
				
		mytlend1 = trace_endpos;
		
		local float myiter, mynudgeamnt;
		mynudgeamnt = 4;
		myiter = 0;
		while (myiter < 17) //4*16 = 64 max search qunits forward and back
		{
			myiter = myiter + 1;
			if (vlen(mytlend0 - mytlend1) > 128) {
			
				//Try again 8 qu forward
				doorcentertracer.origin = mysnappedorigin + (v_forward * myiter * mynudgeamnt);
				setorigin(doorcentertracer, doorcentertracer.origin);
				traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * 1000) , MOVE_NORMAL, doorcentertracer);
					
				mytlend0 = trace_endpos;
					
				doorcentertracer.origin = mysnappedorigin + (v_forward * myiter * mynudgeamnt);
				setorigin(doorcentertracer, doorcentertracer.origin);
				traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * -1000), MOVE_NORMAL, doorcentertracer);
					
				mytlend1 = trace_endpos;
				
				if (vlen(mytlend0 - mytlend1) > 128) {
					//Try again 8 qu backward
					doorcentertracer.origin = mysnappedorigin + (v_forward * myiter * mynudgeamnt * -1);
					setorigin(doorcentertracer, doorcentertracer.origin);
					traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * 1000) , MOVE_NORMAL, doorcentertracer);
					
					mytlend0 = trace_endpos;
					
					doorcentertracer.origin = mysnappedorigin + (v_forward * myiter * mynudgeamnt * -1);
					setorigin(doorcentertracer, doorcentertracer.origin);
					traceline(doorcentertracer.origin, doorcentertracer.origin + (v_right * -1000), MOVE_NORMAL, doorcentertracer);
					
					mytlend1 = trace_endpos;
				} else {
					foundgoodspot = 1;
					myiter = 999999; //We're done, exit loop
				}
			} else {
				foundgoodspot = 1;
				myiter = 999999; //We're done, exit loop
				
				if (vlen(mytlend0 - mytlend1) <= 64) {
					myplayer.rtnvl2 = 1; //To inform ourself not to use wings on the doorframe
				}
			}
		}
		
		
		if (foundgoodspot) {
			local vector mycentervec;
			if ((clienttype(myplayer) == CLIENTTYPE_REAL)) {
				if (myplayer.multitool_annoymsgtime3 < time) {
					sprint(myplayer, "Centering door in hall or frame\n");
					myplayer.multitool_annoymsgtime3 = time + 5;
					myplayer.multitool_annoymsgtime2 = 0; //So next time door cannot be centered it will be told
				}
			}
			mycentervec = (mytlend0 + mytlend1) * 0.5;
			my_tl_end_x = mycentervec_x;
			my_tl_end_y = mycentervec_y;
					
			//For door frame blocks, middle is 20 qu from origin
			my_tl_end = my_tl_end - (v_forward*20);
					
			doorcentertracer.origin = mysnappedorigin;
			setorigin(doorcentertracer, doorcentertracer.origin);
			traceline(doorcentertracer.origin, doorcentertracer.origin + '0 0 -128', MOVE_NORMAL, doorcentertracer);
					
			my_tl_end_z = trace_endpos_z; //Final placement now set, will return this vector
			
			//For short door
			//Reusing some now unused vecs.
			mycentervec_z = my_tl_end_z;
			doorcentertracer.origin = mycentervec;
			setorigin(doorcentertracer, doorcentertracer.origin);
			traceline(doorcentertracer.origin, doorcentertracer.origin + '0 0 128', MOVE_NORMAL, doorcentertracer);
			if ((trace_endpos_z - mycentervec_z) < 112) {
				myplayer.rtnvl3 = 1; //To inform ourself to use short door
			}
			//End short door
			
			remove(doorcentertracer);
			return my_tl_end;
		} else {
			if ((clienttype(myplayer) == CLIENTTYPE_REAL)) {
				if (myplayer.multitool_annoymsgtime2 < time) {
					sprint(myplayer, "Spot too wide for doorcenter, defaulting to normal placement\n");
					myplayer.multitool_annoymsgtime2 = time + 5;
					myplayer.multitool_annoymsgtime3 = 0; //So next time door can be centered it will be told
				}
			}
			
			remove(doorcentertracer);
			return '0 0 0';
		}
	} else {
		return my_tl_end;
	}
}


float multitool_testfor_isautoblocktypemultitool(entity player)
{	
	if (autocvar_g_balance_multitool_autoblocktypedisabled) {
		return FALSE;
	}
	
	local entity ntracer;
		
	ntracer = spawn();
	ntracer.origin = player.origin;
	
	trace_ent = world;
	
	//See if something below close should be auto blocktype	any	
	traceline(ntracer.origin + '0 0 2', ntracer.origin - '0 0 128', MOVE_NORMAL, ntracer);
	
	remove(ntracer);
	
	if (trace_ent)
	if (trace_ent != world)
	if (trace_ent.isautoblocktypemultitool) {
		//print("yes for auto blocktype any\n");
		return TRUE;
	}
	
	//print("no for auto blocktype any\n");
	return FALSE;
}


float multitool_testfor_isquestionableblocktypemultitool(entity player)
{	
	if (autocvar_g_balance_multitool_allowquestionableblocktype) {
		return FALSE;
	}
	
	local entity ntracer;
		
	ntracer = spawn();
	ntracer.origin = player.origin;
	
	trace_ent = world;
	
	//See if something below close should be auto blocktype	any	
	traceline(ntracer.origin + '0 0 2', ntracer.origin - '0 0 128', MOVE_NORMAL, ntracer);
	
	remove(ntracer);
	
	if (trace_ent)
	if (trace_ent != world)
	if (trace_ent.isquestionableblocktypemultitool) {
		//print("This is a questionable place to place a building... on a shield or etc\n");
		return TRUE;
	}
	
	//print("no for auto blocktype any\n");
	return FALSE;
}


void multitool_investigatemore_obstructions_or_excessive_grade(entity player)
{	
	local entity ntracer;
	local vector test_tl_endA;
	local vector test_tl_endB;
	
	if (autocvar_g_balance_multitool_autoblocktypedisabled)
		return;
		
	if (player.multitool_helpfultipnagnexttime > time)
		return;
	
	if ((clienttype(player) != CLIENTTYPE_REAL))
		return; //Real clients only please
			
	ntracer = spawn();
	ntracer.origin = player.origin;
	
	//Same trace, diff move types, see if there's a big diff		
	traceline(ntracer.origin + '0 0 2', ntracer.origin - '0 0 10000', MOVE_WORLDONLY, ntracer);
	test_tl_endA = trace_endpos;
			
	traceline(ntracer.origin + '0 0 2', ntracer.origin - '0 0 10000', MOVE_NORMAL, ntracer);
	test_tl_endB = trace_endpos;
		
	remove(ntracer);
	
	if (trace_ent)
	if (trace_ent != world)
	if (vlen(test_tl_endB - test_tl_endA) > 8)
	if (trace_ent.classname == "building") {
		if (player.weapon == WEP_UTILITOOL) {
			sprint(player, "To build buildings ontop of other structures or buildings enter the command ^x24Autilitool blocktype^7 and toggle blocktype to ANY\n");
		} else {
			sprint(player, "To build buildings ontop of other structures or buildings enter the command ^xA22multitool blocktype^7 and toggle blocktype to ANY\n");
		}
		
		//We don't want to nag the player too much about this
		if (player.multitool_helpfultipnagtimes < 1) {
			player.multitool_helpfultipnagnexttime = time + 2;
		} else if (player.multitool_helpfultipnagtimes < 2) {
			player.multitool_helpfultipnagnexttime = time + 5;
		} else if (player.multitool_helpfultipnagtimes < 3) {
			player.multitool_helpfultipnagnexttime = time + 10;
		} else if (player.multitool_helpfultipnagtimes < 4) {
			player.multitool_helpfultipnagnexttime = time + 14;
		} else if (player.multitool_helpfultipnagtimes < 5) {
			player.multitool_helpfultipnagnexttime = time + 24;
		} else if (player.multitool_helpfultipnagtimes < 6) {
			player.multitool_helpfultipnagnexttime = time + 48;
		} else if (player.multitool_helpfultipnagtimes < 7) {
			player.multitool_helpfultipnagnexttime = time + 96;
		} else {
			player.multitool_helpfultipnagnexttime = time + 192;
		}
		player.multitool_helpfultipnagtimes = player.multitool_helpfultipnagtimes + 1;
	}
}


void multitool_fire_auto()
{
	local float investigatemore;
	investigatemore = 0;
	
	if (self.multitool_jammed)
	{
		w_ready();
		return;
	}
	
	if(W_MultiTool_NeedManualReload()) {
		w_ready();
		return;	
	}

	if (!self.BUTTON_ATCK)
	{
		w_ready();
		return;
	}

	if (!weapon_action(self.weapon, WR_CHECKAMMO1))
	if not(self.items & IT_UNLIMITED_WEAPON_AMMO)
	{
		W_SwitchWeapon_Force(self, w_getbestweapon(self));
		w_ready();
		return;
	}
	
	//Semi-auto enforce
	if ((self.multitool_setting >= 700 && self.multitool_setting <= MTB64BOUNDLAST)
	|| (self.multitool_setting >= MTB64UBOUNDFIRST && self.multitool_setting <= MTB64UBOUNDLAST)) {
		if (self.multitool_release
		|| (self.weapon == WEP_MULTITOOL && autocvar_g_balance_multitool_refire_blocks_fullyautomatic)
		|| (self.weapon == WEP_UTILITOOL && autocvar_g_balance_utilitool_refire_blocks_fullyautomatic)
		) {
			//Continue
		} else {
			w_ready();
			return;
		}
	} else {
		if (self.multitool_release
		|| (self.weapon == WEP_MULTITOOL && autocvar_g_balance_multitool_refire_fullyautomatic)
		|| (self.weapon == WEP_UTILITOOL && autocvar_g_balance_utilitool_refire_fullyautomatic)
		) {
			//Continue
		} else {
			w_ready();
			return;
		}
	}

	//W_DecreaseAmmo(ammo_nails, autocvar_g_balance_multitool_ammo, autocvar_g_balance_multitool_reload_ammo);
	
	entity plyr;
	float myblocktype;
	float playerprevmovetype;
	myblocktype = MOVE_WORLDONLY;
	plyr = self;
	
	
	if(autocvar_g_balance_multitool_jamrate &&
 	(autocvar_g_balance_multitool_jamrate > random() ))
 	{
		if ((clienttype(self) == CLIENTTYPE_REAL)) {
			sprint(self, "Your multitool has malfunctioned\n");
		}
		self.multitool_jammed = 1;
	} else { //Start Not Jammed
		float nonblockwallsettings;
		float weshouldbailearly;
		entity player;
		entity tracer;
		player = self;
		
		if ((player.multitool_blocktype == 1) ||
		((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST))
		|| (player.multitool_setting == 503 || player.multitool_setting == 1502 
		   || player.multitool_setting == 110 || player.multitool_setting == 111 
		   || player.multitool_setting == 112
		   || player.multitool_setting == 1110 || player.multitool_setting == 1111
		   || player.multitool_setting == 1112 || player.multitool_setting == 1113
		   || player.multitool_setting == 1114 || player.multitool_setting == 1115
		   || player.multitool_setting == 1116 || player.multitool_setting == 1117 || player.multitool_setting == 1118
		   || player.multitool_setting == MTB64U_PLATFORM_8 || player.multitool_setting == MTB64U_PLATFORM_16
		   || player.multitool_setting == MTB64U_PLATFORM_24 || player.multitool_setting == MTB64U_PLATFORM_32
		   || player.multitool_setting == MTB64_PLATFORMWOOD_8 || player.multitool_setting == MTB64_PLATFORMWOOD_24)) {
			//If blocktype is set, or we're placing blocks or recruitment posts or point defense guns
			myblocktype = MOVE_NORMAL;
			playerprevmovetype = player.movetype; //Reset below at //RESET STUFF
			player.movetype = MOVETYPE_NOCLIP;
		}
		
		nonblockwallsettings = 0;
		weshouldbailearly = 0;
		
		if ((player.multitool_setting >= 500
		&& player.multitool_setting < 1000)
		|| (player.multitool_setting >= 10000
		&& player.multitool_setting < 20000)
		|| (player.multitool_setting <= -500
		&& player.multitool_setting > -1000)
		|| (player.multitool_setting >= 1500
		&& player.multitool_setting < 2000))
		{
			float tracershift; //For if we have enabled shifting.
			float dowallshift;
			dowallshift = 0;
			
			if (player.multitool_wallshift == 1) {
				dowallshift = 1;
			}
			
			//Medieval wall block
			tracer = spawn();
			tracer.origin = multitool_placetype_origin(self);
			if (player.multitool_setting == 564
			|| player.multitool_setting == 576
			|| player.multitool_setting == 584
			|| player.multitool_setting == 1538) {
				if (player.multitool_wallshift == 1) {
					dowallshift = 0; //Inverted to connect with vaults
				} else {
					dowallshift = 1;
				}

				//Smaller Pieces
				if (player.multitool_wallsnap == 1) {
					tracer.origin = vsnap(tracer.origin, 128);
					tracershift = 64;
				} else {
					tracer.origin = vsnap(tracer.origin, 256);
					tracershift = 128;
				}
			} else if (multitool_isfurniture(player.multitool_setting)) {
				//Like the building blocks below, but smaller grid
				if (player.multitool_wallsnap == 1) {
					tracer.origin = vsnap(tracer.origin, 16);
					tracershift = 8;
				} else {
					tracer.origin = vsnap(tracer.origin, 32);
					tracershift = 16;
				}
			} else if (player.multitool_setting == MTB64U_PLATFORM_8
				|| player.multitool_setting == MTB64U_PLATFORM_16
				|| player.multitool_setting == MTB64U_PLATFORM_24
				|| player.multitool_setting == MTB64U_PLATFORM_32
				|| player.multitool_setting == MTB64_PLATFORMWOOD_8
				|| player.multitool_setting == MTB64_PLATFORMWOOD_24) {
				//An exception: Small platforms for rasing things slightly in height (such as point defenses)
				//Used to set proper height for firing out of pillboxes etc
				//They don't follow normal 64block snap
				//Like the building blocks below, but smaller grid
				if (player.multitool_wallsnap == 1) {
					tracer.origin = vsnap(tracer.origin, 16);
					tracershift = 8;
				} else {
					tracer.origin = vsnap(tracer.origin, 32);
					tracershift = 16;
				}
			} else if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
			|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
			|| (player.multitool_setting == 503 || player.multitool_setting == 1502
			   || player.multitool_setting == 110 || player.multitool_setting == 111 || player.multitool_setting == 112
			   || player.multitool_setting == 1110 || player.multitool_setting == 1111
			   || player.multitool_setting == 1112 || player.multitool_setting == 1113
		   	   || player.multitool_setting == 1114 || player.multitool_setting == 1115
		   	   || player.multitool_setting == 1116 || player.multitool_setting == 1117 || player.multitool_setting == 1118)) {
				//Smaller Pieces
				local float mymovinggatezz;
				if (!autocvar_g_balance_multitool_prezsnapforblocks) {
					if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
					|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
						//Blocks won't be vsnapped to z just yet, test
						mymovinggatezz = tracer.origin_z;
					}
				}
				
				if (player.multitool_wallsnap == 1) {
					tracer.origin = vsnap(tracer.origin, 32);
					tracershift = 16;
				} else {
					tracer.origin = vsnap(tracer.origin, 64);
					tracershift = 32;
				}
				
				if (!autocvar_g_balance_multitool_prezsnapforblocks) {
					if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
					|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
						//Resetting movable gate Z
						tracer.origin_z = mymovinggatezz;
					}
				}
			} else {
				local float mymovinggatez;
				if (player.multitool_setting == 1524 || player.multitool_setting == 1546
				|| player.multitool_setting == 10709 || player.multitool_setting == 10710) {
					//Movable Gates can't be vsnapped for Z and fit in 
					mymovinggatez = tracer.origin_z;
				}
				
				if (player.multitool_wallsnap == 1) {
					tracer.origin = vsnap(tracer.origin, 256);
					tracershift = 128;
				} else {
					tracer.origin = vsnap(tracer.origin, 512);
					tracershift = 256;
				}
				
				if (player.multitool_setting == 1524 || player.multitool_setting == 1546
				|| player.multitool_setting == 10709 || player.multitool_setting == 10710) {
					//Resetting movable gate Z
					tracer.origin_z = mymovinggatez;
				}
				//Normal
			}
			
			if (dowallshift == 1) {
				vector testo1, testo2, testo3, testo4;
				testo1 = tracer.origin;
				testo2 = tracer.origin;
				testo3 = tracer.origin;
				testo4 = tracer.origin;
				
				testo1_x = tracer.origin_x + tracershift;
				testo1_y = tracer.origin_y + tracershift;
				
				testo2_x = tracer.origin_x - tracershift;
				testo2_y = tracer.origin_y - tracershift;
				
				testo3_x = tracer.origin_x + tracershift;
				testo3_y = tracer.origin_y - tracershift;
				
				testo4_x = tracer.origin_x - tracershift;
				testo4_y = tracer.origin_y + tracershift;
				
				
				if ((vlen(player.origin-testo2)) > (vlen(player.origin-testo1))) {
					//testo1 wins
					if ((vlen(player.origin-testo3)) > (vlen(player.origin-testo1))) {
						//testo1 wins
						tracer.origin = testo1;
						if ((vlen(player.origin-testo4)) > (vlen(player.origin-testo1))) {
							//testo1 wins
							tracer.origin = testo1;
						} else {
							//testo4 wins
							tracer.origin = testo4;
						}
					} else {
						//testo3 wins
						if ((vlen(player.origin-testo4)) > (vlen(player.origin-testo3))) {
							//testo3 wins
							tracer.origin = testo3;
						} else {
							//testo4 wins
							tracer.origin = testo4;
						}
					}
				} else {
					//testo2 wins
					if ((vlen(player.origin-testo3)) > (vlen(player.origin-testo2))) {
						//testo2 wins
						if ((vlen(player.origin-testo4)) > (vlen(player.origin-testo2))) {
							//testo2 wins
							tracer.origin = testo2;
						} else {
							//testo4 wins
							tracer.origin = testo4;
						}
					} else {
						//testo3 wins
						if ((vlen(player.origin-testo4)) > (vlen(player.origin-testo3))) {
							//testo3 wins
							tracer.origin = testo3;
						} else {
							//testo4 wins
							tracer.origin = testo4;
						}
					}
				}
					
			}
			setorigin(tracer, tracer.origin);
		} else {
			tracer = self;
			if (player.multitool_buildingsnap || player.multitool_placetype){ 
				nonblockwallsettings = 1;
			}
		}

		
		float tl_sf, tl_frac;
		vector tl_end, tb_end, eg1_end, eg2_end, eg3_end, eg4_end;
		
		if (nonblockwallsettings) {
			entity ntracer;
			ntracer = spawn();
			ntracer.origin = multitool_placetype_origin(player);
			if (player.multitool_buildingsnap) {
				ntracer.origin = vsnap(ntracer.origin, 64);
			}
			traceline(ntracer.origin + '0 0 2', ntracer.origin - '0 0 10000', myblocktype, ntracer);
			remove(ntracer);
		} else {
			traceline(tracer.origin + '0 0 2', tracer.origin - '0 0 10000', myblocktype, tracer);
		}
		
		
		if (autocvar_g_balance_multitool_allowquestionableblocktype) {
			//Do nothing, building on shields is fine
		} else if (trace_ent != world) {
			if (trace_ent.isquestionableblocktypemultitool) {
				//Let's now build upon energy shields etc
				sprint(self, "cannot build there (questionable building surface)\n");
				weshouldbailearly = 1;
			} else if(trace_ent.vehicle_flags & VHF_ISVEHICLE) {
				sprint(self, "cannot build there (vehicle)\n");
				weshouldbailearly = 1;
			} else if(trace_ent.solid == SOLID_SLIDEBOX) {
				//Try to detect vehicle hit boxes.
				if (trace_ent.owner)
				if (trace_ent.owner != world)
				if (trace_ent.owner.vehicle_flags & VHF_ISVEHICLE)
				{
					sprint(self, "cannot build there (vehicle part)\n");
					weshouldbailearly = 1;
				}
			} else if (trace_ent.multitool_hitbox) {
				if (trace_ent.multitool_hitbox != world)
				if (multitool_isfurniture(trace_ent.multitool_hitbox.count))
				if (multitool_isdragable(trace_ent.multitool_hitbox.count))
				{
					//What of our selection we are trying to build:
					if (multitool_isfurniture(player.multitool_setting)
					&& multitool_isdragable(player.multitool_setting))
					{
						//Do nothing.
						//Allow building of movable furniture
						//on movable furniture on
					} else {
						sprint(self, "cannot build there (movable furniture)\n");
						weshouldbailearly = 1;
					}
				}
			}
		}
		
		
		tl_sf = trace_dphitq3surfaceflags;
		tl_frac = trace_fraction;
		tl_end = trace_endpos;
		
		vector v1, v2, v3, v4, h1, m1, m2; //vectors for the edge traces, height vector, min max for tracebox.
		float d1, u1; //How far can we trace down vs center untill we don't allow building, how far up from base to allow.
		if (player.multitool_setting == 8 || player.multitool_setting == 10) {
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 896';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 128;
			u1 = 112; //64 changed to 112 to make easier for building on terrain
		} else if (player.multitool_setting == 4) {
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 7) {
			//Small Castle
			v1 = '640 640 2';
			v2 = '-640 -640 2';
			v3 = '640 -640 2';
			v4 = '-640 -640 2';
			h1 = '0 0 896';
			m1 = '-640 -640 0';
			m2 = '640 640 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 6) {
			//Circular strongtower
			v1 = '0 512 2';
			v2 = '-512 0 2';
			v3 = '512 0 2';
			v4 = '0 512 2';
			h1 = '0 0 896';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 5) {
			//Stronghold
			v1 = '512 512 2';
			v2 = '-512 -512 2';
			v3 = '512 -512 2';
			v4 = '-512 -512 2';
			h1 = '0 0 896';
			m1 = '-512 -512 0';
			m2 = '512 512 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 9) {
			//Townhall
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 576';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 128;
			u1 = 64;
		} else if (player.multitool_setting == 11) {
			//GManse
			v1 = '640 640 2';
			v2 = '-640 -640 2';
			v3 = '640 -640 2';
			v4 = '-640 -640 2';
			h1 = '0 0 896';
			m1 = '-640 -640 0';
			m2 = '640 640 16';
			d1 = 384;
			u1 = 256;
		} else if (player.multitool_setting == 12) {
			//Circular arsenal
			v1 = '0 384 2';
			v2 = '-384 0 2';
			v3 = '384 0 2';
			v4 = '0 384 2';
			h1 = '0 0 744';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 13) {
			//Barracks
			v1 = '288 288 2';
			v2 = '-288 -288 2';
			v3 = '288 -288 2';
			v4 = '-288 -288 2';
			h1 = '0 0 480';
			m1 = '-288 -288 0';
			m2 = '288 288 16';
			d1 = 128;
			u1 = 110;
		} else if (player.multitool_setting == 14) {
			//Church
			v1 = '320 320 2';
			v2 = '-320 -320 2';
			v3 = '320 -320 2';
			v4 = '-320 -320 2';
			h1 = '0 0 768';
			m1 = '-320 -320 0';
			m2 = '320 320 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 15) {
			//OldHangar
			v1 = '480 480 2';
			v2 = '-480 -480 2';
			v3 = '480 -480 2';
			v4 = '-480 -480 2';
			h1 = '0 0 480';
			m1 = '-480 -480 0';
			m2 = '480 480 16';
			d1 = 128;
			u1 = 110;
		} else if (player.multitool_setting == 16) {
			//OldHangar
			v1 = '480 480 2';
			v2 = '-480 -480 2';
			v3 = '480 -480 2';
			v4 = '-480 -480 2';
			h1 = '0 0 480';
			m1 = '-480 -480 0';
			m2 = '480 480 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 17) {
			//GManse
			v1 = '640 640 2';
			v2 = '-640 -640 2';
			v3 = '640 -640 2';
			v4 = '-640 -640 2';
			h1 = '0 0 896';
			m1 = '-640 -640 0';
			m2 = '640 640 16';
			d1 = 384;
			u1 = 256;
		} else if (player.multitool_setting == 18) {
			//PalladianManor
			v1 = '640 640 2';
			v2 = '-640 -640 2';
			v3 = '640 -640 2';
			v4 = '-640 -640 2';
			h1 = '0 0 896';
			m1 = '-640 -640 0';
			m2 = '640 640 16';
			d1 = 384;
			u1 = 256;
		} else if (player.multitool_setting == 19) {
			//Stone House
			v1 = '256 256 2';
			v2 = '-256 -256 2';
			v3 = '256 -256 2';
			v4 = '-256 -256 2';
			h1 = '0 0 320';
			m1 = '-256 -256 0';
			m2 = '256 256 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 20) {
			//Treetop sentry
			v1 = '128 128 2';
			v2 = '-128 -128 2';
			v3 = '128 -128 2';
			v4 = '-128 -128 2';
			h1 = '0 0 320';
			m1 = '-128 -128 0';
			m2 = '128 128 16';
			d1 = 256000;
			u1 = 110000;
		} else if (player.multitool_setting == 21) {
			//SiegeWorkshop
			v1 = '480 480 2';
			v2 = '-480 -480 2';
			v3 = '480 -480 2';
			v4 = '-480 -480 2';
			h1 = '0 0 440';
			m1 = '-480 -480 0';
			m2 = '480 480 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 22) {
			//Gaol
			v1 = '640 640 2';
			v2 = '-640 -640 2';
			v3 = '640 -640 2';
			v4 = '-640 -640 2';
			h1 = '0 0 896';
			m1 = '-640 -640 0';
			m2 = '640 640 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 23) {
			v1 = '384 384 2';
			v2 = '-384 -384 2';
			v3 = '384 -384 2';
			v4 = '-384 -384 2';
			h1 = '0 0 256';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 24
			|| player.multitool_setting == 26) {
			//Forges
			v1 = '448 448 2';
			v2 = '-448 -448 2';
			v3 = '448 -448 2';
			v4 = '-448 -448 2';
			h1 = '0 0 448';
			m1 = '-448 -448 0';
			m2 = '448 448 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 25) {
			//Circular forge (rocket)
			v1 = '0 448 2';
			v2 = '-448 0 2';
			v3 = '448 0 2';
			v4 = '0 448 2';
			h1 = '0 0 256';
			m1 = '-448 -448 0';
			m2 = '448 448 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 27) {
			//Crusader Stronghold
			v1 = '512 512 2';
			v2 = '-512 -512 2';
			v3 = '512 -512 2';
			v4 = '-512 -512 2';
			h1 = '0 0 1024';
			m1 = '-512 -512 0';
			m2 = '512 512 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 110 || player.multitool_setting == 111
			|| player.multitool_setting == 112
			|| player.multitool_setting == 1110
			|| player.multitool_setting == 1111
			|| player.multitool_setting == 1112
			|| player.multitool_setting == 1113
			|| player.multitool_setting == 1114
			|| player.multitool_setting == 1115
			|| player.multitool_setting == 1116
			|| player.multitool_setting == 1117
			|| player.multitool_setting == 1118) {
			//Point Defense (circular search)
			v1 = '0 16 2';
			v2 = '-16 0 2';
			v3 = '16 0 2';
			v4 = '0 16 2';
			h1 = '0 0 64'; //
			m1 = '-16 -16 0';
			m2 = '16 16 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 501 || player.multitool_setting == 502 || player.multitool_setting == 1501) {
			//field, vineyard, etc
			v1 = '128 128 2';
			v2 = '-128 -128 2';
			v3 = '128 -128 2';
			v4 = '-128 -128 2';
			h1 = '0 0 256';
			m1 = '-128 -128 0';
			m2 = '128 128 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 503 || player.multitool_setting == 1502) {
			//Recruitment Post
			v1 = '30 30 2';
			v2 = '-30 -30 2';
			v3 = '30 -30 2';
			v4 = '-30 -30 2';
			h1 = '0 0 64'; //Forgiving
			m1 = '-30 -30 0';
			m2 = '30 30 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == 520 || player.multitool_setting == 523) {
			//wall hedge
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 192';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 96;
		} else if (player.multitool_setting == 521 || player.multitool_setting == 522) {
			//wall hedge tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 192';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 96;
		} else if (player.multitool_setting == 530 || player.multitool_setting == 533) {
			//wall brick
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 192';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 129;
		} else if (player.multitool_setting == 531 || player.multitool_setting == 532) {
			//wall brick
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 192';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 129;
		} else if (player.multitool_setting == 540 || player.multitool_setting == 542
		|| player.multitool_setting == 543 || player.multitool_setting == 544 || player.multitool_setting == 545) {
			//wall palisade
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 432';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 541 || player.multitool_setting == 546) {
			//wall palisade tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 432';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 550) {
			//wall berm
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 551) {
			//wall berm tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 560 || player.multitool_setting == 563
			|| player.multitool_setting == 569) {
			//wall curtain
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 432';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 561) {
			//wall curtain tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 432';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 562) {
			//wall curtain tower round
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 432';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 570 || player.multitool_setting == 573
		|| player.multitool_setting == 10708) {
			//wall castle
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 512';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 574 || player.multitool_setting == 575
			|| player.multitool_setting == 583 || player.multitool_setting == 566
			|| player.multitool_setting == 610 || player.multitool_setting == 611
			|| player.multitool_setting == 612 || player.multitool_setting == 616) {
			//vault castle
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 384';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1680 || player.multitool_setting == 1681 || player.multitool_setting == 1686) {
			//vault castle
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 272';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 578
			|| player.multitool_setting == 586 || player.multitool_setting == 567) {
			//fill stairs castle
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 384';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1539) {
			//fill stairs futuristic concrete
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 564
			|| player.multitool_setting == 576
			|| player.multitool_setting == 584
			|| player.multitool_setting == 1538) {
			//fill wall
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 256'; //Forgiving
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == MTB64U_FURN_MTLCRATE) {
			//Large crate
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 112';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_COMCRATE) {
			//Large server
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 128';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_COMCRATE2) {
			//Large server
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 272';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_SERVER) {
			v1 = '16 16 2';
			v2 = '-16 -16 2';
			v3 = '16 -16 2';
			v4 = '-16 -16 2';
			h1 = '0 0 128';
			m1 = '-16 -16 0';
			m2 = '16 16 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_TOILET) {
			v1 = '16 16 2';
			v2 = '-16 -16 2';
			v3 = '16 -16 2';
			v4 = '-16 -16 2';
			h1 = '0 0 128';
			m1 = '-16 -16 0';
			m2 = '16 16 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_SHOWER) {
			v1 = '30 30 2';
			v2 = '-30 -30 2';
			v3 = '30 -30 2';
			v4 = '-30 -30 2';
			h1 = '0 0 96';
			m1 = '-30 -30 0';
			m2 = '30 30 30';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64U_FURN_FRIDGE
		|| player.multitool_setting == MTB64U_FURN_FRIDGE2
		|| player.multitool_setting == MTB64U_FURN_FRIDGE3) {
			v1 = '16 16 2';
			v2 = '-16 -16 2';
			v3 = '16 -16 2';
			v4 = '-16 -16 2';
			h1 = '0 0 96';
			m1 = '-16 -16 0';
			m2 = '16 16 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == MTB64_WINDOW_WOODBAR
			|| player.multitool_setting == MTB64_WINDOW_IRONBAR
			|| player.multitool_setting == MTB64U_WINDOW_FUTURE
			|| player.multitool_setting == MTB64U_WINDOW_FUTURE_X
			|| player.multitool_setting == MTB64U_BWIRE
			|| player.multitool_setting == MTB64_BWIRE) {
			//Special case in block64s, thin windows
			v1 = '4 4 2';
			v2 = '-4 -4 2';
			v3 = '4 -4 2';
			v4 = '-4 -4 2';
			h1 = '0 0 64'; //Forgiving
			m1 = '-4 -4 0';
			m2 = '4 4 16';
			d1 = 128;
			u1 = 128;
		} else if ((player.multitool_setting >= MTB64FIRST
			&& player.multitool_setting <= MTB64LAST
			)
			|| (player.multitool_setting >= MTB64UFIRST
			&& player.multitool_setting <= MTB64ULAST)) {
			//Block 64 (Between 710 and 811 or so)
			v1 = '30 30 2';
			v2 = '-30 -30 2';
			v3 = '30 -30 2';
			v4 = '-30 -30 2';
			h1 = '0 0 64'; //Forgiving
			m1 = '-30 -30 0';
			m2 = '30 30 16';
			d1 = 128;
			u1 = 128;
		} else if (player.multitool_setting == 565
			|| player.multitool_setting == 577
			|| player.multitool_setting == 585
			|| player.multitool_setting == 568
			|| player.multitool_setting == 579
			|| player.multitool_setting == 587
			|| player.multitool_setting == 10700
			|| player.multitool_setting == 10701
			|| player.multitool_setting == 10702
			|| player.multitool_setting == 10703
			|| player.multitool_setting == 10704
			|| player.multitool_setting == 10705
			|| player.multitool_setting == 10706
			|| player.multitool_setting == 10707
			|| player.multitool_setting == 1540
			|| player.multitool_setting == 1541) {
			//interior wall
			v1 = '8 8 2';
			v2 = '-8 -8 2';
			v3 = '8 -8 2';
			v4 = '-8 -8 2';
			h1 = '0 0 128'; 
			m1 = '-8 -8 0';
			m2 = '8 8 16';
			d1 = 512;
			u1 = 512;
		} else if (player.multitool_setting == 571) {
			//wall castle tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 512';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 572) {
			//wall castle tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 512';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 580 || player.multitool_setting == 582
			|| player.multitool_setting == 588) {
			//wall polish
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 512';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 581) {
			//wall polish tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 512';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 630 || player.multitool_setting == 631 || player.multitool_setting == 632
			|| player.multitool_setting == 633 || player.multitool_setting == 1630 || player.multitool_setting == 1631) {
			//foundation
			v1 = '4 4 2';
			v2 = '-4 -4 2';
			v3 = '4 -4 2';
			v4 = '-4 -4 2';
			h1 = '0 0 32';
			m1 = '-4 -4 0';
			m2 = '4 4 16';
			d1 = 1536;
			u1 = 256;
		} else if (player.multitool_setting == 645 || player.multitool_setting == 646 || player.multitool_setting == 650 || player.multitool_setting == 651 || player.multitool_setting == 652
			|| player.multitool_setting == 660 || player.multitool_setting == 661 || player.multitool_setting == 662
			|| player.multitool_setting == 663 || player.multitool_setting == 664
			|| player.multitool_setting == 670 || player.multitool_setting == 671 || player.multitool_setting == 672
			) {
			//bridge
			v1 = '4 4 2';
			v2 = '-4 -4 2';
			v3 = '4 -4 2';
			v4 = '-4 -4 2';
			h1 = '0 0 32';
			m1 = '-4 -4 0';
			m2 = '4 4 16';
			d1 = 1536;
			u1 = 512;
		} else if (player.multitool_setting == 1650 || player.multitool_setting == 1651
		|| player.multitool_setting == 1652 || player.multitool_setting == 1653) {
			//bridge, futuristic
			v1 = '4 4 2';
			v2 = '-4 -4 2';
			v3 = '4 -4 2';
			v4 = '-4 -4 2';
			h1 = '0 0 32';
			m1 = '-4 -4 0';
			m2 = '4 4 16';
			d1 = 3072;
			u1 = 512;
		} else if (player.multitool_setting == -3) {
			//Nippon Shrine
			v1 = '768 768 2';
			v2 = '-768 -768 2';
			v3 = '768 -768 2';
			v4 = '-768 -768 2';
			h1 = '0 0 768';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == -4) {
			//Nippon Dojo
			v1 = '1024 1024 2';
			v2 = '-1024 -1024 2';
			v3 = '1024 -1024 2';
			v4 = '-1024 -1024 2';
			h1 = '0 0 896';
			m1 = '-1024 -1024 0';
			m2 = '1024 1024 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == -2) {
			//Nippon House
			v1 = '384 384 2';
			v2 = '-384 -384 2';
			v3 = '384 -384 2';
			v4 = '-384 -384 2';
			h1 = '0 0 576';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == -1) {
			//Circular Sniperspire
			v1 = '0 288 2';
			v2 = '-288 0 2';
			v3 = '288 0 2';
			v4 = '0 288 2';
			h1 = '0 0 896';
			m1 = '-208 -208 0';
			m2 = '208 208 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == -5) {
			//Belltower
			v1 = '208 208 2';
			v2 = '-208 -208 2';
			v3 = '208 -208 2';
			v4 = '-208 -208 2';
			h1 = '0 0 896';
			m1 = '-208 -208 0';
			m2 = '208 208 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting <= -600 && player.multitool_setting > -1000) {
			//floors
			v1 = '4 4 2';
			v2 = '-4 -4 2';
			v3 = '4 -4 2';
			v4 = '-4 -4 2';
			h1 = '0 0 32'; // 32//12 (h of floor), 16 might be good too
			m1 = '-4 -4 0';
			m2 = '4 4 16';
			d1 = 512;
			u1 = 256;
		} else if (player.multitool_setting == 1001) {
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 320';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 1002) {
			//Shield Gen
			v1 = '48 48 2';
			v2 = '-48 -48 2';
			v3 = '48 -48 2';
			v4 = '-48 -48 2';
			h1 = '0 0 320';
			m1 = '-48 -48 0';
			m2 = '48 48 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 1003) {
			//Future House (Shelter)
			v1 = '232 232 2';
			v2 = '-232 -232 2';
			v3 = '232 -232 2';
			v4 = '-232 -232 2';
			h1 = '0 0 256';
			m1 = '-232 -232 0';
			m2 = '232 232 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 1004) {
			//Circular Glass Base
			v1 = '0 384 2';
			v2 = '-384 0 2';
			v3 = '384 0 2';
			v4 = '0 384 2';
			h1 = '0 0 744';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 256;
			u1 = 110;
		} else if (player.multitool_setting == 1005) {
			//NewHangar
			v1 = '992 992 2';
			v2 = '-992 -992 2';
			v3 = '992 -992 2';
			v4 = '-992 -992 2';
			h1 = '0 0 256';
			m1 = '-992 -992 0';
			m2 = '992 992 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1006) {
			//Circular Security Building
			v1 = '0 768 2';
			v2 = '-768 0 2';
			v3 = '768 0 2';
			v4 = '0 768 2';
			h1 = '0 0 744';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1007) {
			//Tankpad
			v1 = '232 232 2';
			v2 = '-232 -232 2';
			v3 = '232 -232 2';
			v4 = '-232 -232 2';
			h1 = '0 0 160';
			m1 = '-232 -232 0';
			m2 = '232 232 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1008) {
			//stockpile
			v1 = '496 496 2';
			v2 = '-496 -496 2';
			v3 = '496 -496 2';
			v4 = '-496 -496 2';
			h1 = '0 0 256';
			m1 = '-496 -496 0';
			m2 = '496 496 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1009) {
			//AmmoDepot
			v1 = '232 232 2';
			v2 = '-232 -232 2';
			v3 = '232 -232 2';
			v4 = '-232 -232 2';
			h1 = '0 0 256';
			m1 = '-232 -232 0';
			m2 = '232 232 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1010) {
			//oiltank
			v1 = '512 512 2';
			v2 = '-512 -512 2';
			v3 = '512 -512 2';
			v4 = '-512 -512 2';
			h1 = '0 0 512';
			m1 = '-512 -512 0';
			m2 = '512 512 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1011) {
			//energytank
			v1 = '512 512 2';
			v2 = '-512 -512 2';
			v3 = '512 -512 2';
			v4 = '-512 -512 2';
			h1 = '0 0 1152';
			m1 = '-512 -512 0';
			m2 = '512 512 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1012) {
			//Apartments
			v1 = '0 768 2';
			v2 = '-768 0 2';
			v3 = '768 0 2';
			v4 = '0 768 2';
			h1 = '0 0 1536';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 288;
			u1 = 112;
		} else if (player.multitool_setting == 1013) {
			//Turret-FLAC (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 512';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1014) {
			//Turret-MLRS (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 384';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1015) {
			//OilPump (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 512';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1016
		|| player.multitool_setting == 1017
		|| player.multitool_setting == 1018) {
			//chemical plants
			v1 = '1024 1024 2';
			v2 = '-1024 -1024 2';
			v3 = '1024 -1024 2';
			v4 = '-1024 -1024 2';
			h1 = '0 0 1024';
			m1 = '-1024 -1024 0';
			m2 = '1024 1024 16';
			d1 = 768;
			u1 = 768;
		} else if (player.multitool_setting == 1019) {
			//munitions factory
			v1 = '1024 1024 2';
			v2 = '-1024 -1024 2';
			v3 = '1024 -1024 2';
			v4 = '-1024 -1024 2';
			h1 = '0 0 1024';
			m1 = '-1024 -1024 0';
			m2 = '1024 1024 16';
			d1 = 768;
			u1 = 768;
		} else if (player.multitool_setting == 1020) {
			//Simple Metal Sentry Tower (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 544';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1021) {
			//Furnace (circular search)
			v1 = '0 288 2';
			v2 = '-288 0 2';
			v3 = '288 0 2';
			v4 = '0 288 2';
			h1 = '0 0 1856';
			m1 = '-288 -288 0';
			m2 = '288 288 16';
			d1 = 512;
			u1 = 512;
		} else if (player.multitool_setting == 1022 || player.multitool_setting == 1026) {
			//OfficeTower
			v1 = '0 768 2';
			v2 = '-768 0 2';
			v3 = '768 0 2';
			v4 = '0 768 2';
			h1 = '0 0 2264';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 288;
			u1 = 112;
		} else if (player.multitool_setting == 1023) {
			//OfficeTower
			v1 = '0 768 2';
			v2 = '-768 0 2';
			v3 = '768 0 2';
			v4 = '0 768 2';
			h1 = '0 0 784';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 288;
			u1 = 112;
		} else if (player.multitool_setting == 1024) {
			//OfficeTower
			v1 = '0 768 2';
			v2 = '-768 0 2';
			v3 = '768 0 2';
			v4 = '0 768 2';
			h1 = '0 0 2264';
			m1 = '-768 -768 0';
			m2 = '768 768 16';
			d1 = 288;
			u1 = 112;
		} else if (player.multitool_setting == 1025) {
			//TensionWire Tower (circular search)
			v1 = '0 384 2';
			v2 = '-384 0 2';
			v3 = '384 0 2';
			v4 = '0 384 2';
			h1 = '0 0 2560';
			m1 = '-384 -384 0';
			m2 = '384 384 16';
			d1 = 512;
			u1 = 256;
		} else if (player.multitool_setting == 1027) {
			//APCpad
			v1 = '232 232 2';
			v2 = '-232 -232 2';
			v3 = '232 -232 2';
			v4 = '-232 -232 2';
			h1 = '0 0 160';
			m1 = '-232 -232 0';
			m2 = '232 232 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1028) {
			//Covered Garage
			v1 = '256 256 2';
			v2 = '-256 -256 2';
			v3 = '256 -256 2';
			v4 = '-256 -256 2';
			h1 = '0 0 384';
			m1 = '-256 -256 0';
			m2 = '256 256 16';
			d1 = 256;
			u1 = 128;
		} else if (player.multitool_setting == 1029) {
			//Bulldozerpad
			v1 = '232 232 2';
			v2 = '-232 -232 2';
			v3 = '232 -232 2';
			v4 = '-232 -232 2';
			h1 = '0 0 160';
			m1 = '-232 -232 0';
			m2 = '232 232 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1030) {
			//Small energy tank (local)
			v1 = '96 96 2';
			v2 = '-96 -96 2';
			v3 = '96 -96 2';
			v4 = '-96 -96 2';
			h1 = '0 0 256';
			m1 = '-96 -96 0';
			m2 = '96 96 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 1031) {
			//CanopyShield Gen
			v1 = '32 32 2';
			v2 = '-32 -32 2';
			v3 = '32 -32 2';
			v4 = '-32 -32 2';
			h1 = '0 0 320';
			m1 = '-32 -32 0';
			m2 = '32 32 16';
			d1 = 128;
			u1 = 112;
		} else if (player.multitool_setting == 1032) {
			//Small oil tank (local)
			v1 = '96 96 2';
			v2 = '-96 -96 2';
			v3 = '96 -96 2';
			v4 = '-96 -96 2';
			h1 = '0 0 256';
			m1 = '-96 -96 0';
			m2 = '96 96 16';
			d1 = 256; //on pylons
			u1 = 112;
		} else if (player.multitool_setting == 1033) {
			//OilDistribution Control
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 384';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1034) {
			//ChemicalDistribution Control
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 192';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1035) {
			//Combat-Suit pad
			v1 = '96 96 2';
			v2 = '-96 -96 2';
			v3 = '96 -96 2';
			v4 = '-96 -96 2';
			h1 = '0 0 160';
			m1 = '-96 -96 0';
			m2 = '96 96 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1036) {
			//Hammerforge
			v1 = '0 448 2';
			v2 = '-448 0 2';
			v3 = '448 0 2';
			v4 = '0 448 2';
			h1 = '0 0 512';
			m1 = '-448 -448 0';
			m2 = '448 448 16';
			d1 = 512;
			u1 = 512;
		} else if (player.multitool_setting == 1037) {
			//ObservationTower
			v1 = '0 256 2';
			v2 = '-256 0 2';
			v3 = '256 0 2';
			v4 = '0 256 2';
			h1 = '0 0 832';
			m1 = '-256 -256 0';
			m2 = '256 256 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1038) {
			//Turret-AutoSHLAC (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 80';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1120 || player.multitool_setting == 1121
			|| player.multitool_setting == 1122 || player.multitool_setting == 1123
			|| player.multitool_setting == 1124 || player.multitool_setting == 1125
			|| player.multitool_setting == 1126 || player.multitool_setting == 1127) {
			//Mannable Turret (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 102'; //32(pylon)+70(top of turret);
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1130 || player.multitool_setting == 1131) {
			//Tower Mannable Turret (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 512'; //480(pylon)+70(top of turret);
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1510) {
			//SolarPanel (circular search)
			v1 = '0 64 2';
			v2 = '-64 0 2';
			v3 = '64 0 2';
			v4 = '0 64 2';
			h1 = '0 0 896';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 112;
		} else if (player.multitool_setting == 1520 || player.multitool_setting == 1522 || player.multitool_setting == 1523
		|| player.multitool_setting == 1530 || player.multitool_setting == 1532
		|| player.multitool_setting == 1533 || player.multitool_setting == 1534
		|| player.multitool_setting == 1535 || player.multitool_setting == 1542
		|| player.multitool_setting == 1543 || player.multitool_setting == 1548
		|| player.multitool_setting == 1549) {
			//fence mil
			v1 = '64 64 2';
			v2 = '-64 -64 2';
			v3 = '64 -64 2';
			v4 = '-64 -64 2';
			h1 = '0 0 192';
			m1 = '-64 -64 0';
			m2 = '64 64 16';
			d1 = 256;
			u1 = 96;
		} else if (player.multitool_setting == 1524
		|| player.multitool_setting == 1546
		|| player.multitool_setting == 10709
		|| player.multitool_setting == 10710) {
			//print("hereeeee\n");
			//fence mil moving gate
			v1 = '30 30 2';
			v2 = '-30 -30 2';
			v3 = '30 -30 2';
			v4 = '-30 -30 2';
			//h1 = '0 0 0'; //Forgiving //This on works for these to be in concrete gate
			//h1 = '0 0 2'; //Forgiving, didn't work, tried to put on top
			h1 = '0 0 128';
			m1 = '-30 -30 0';
			m2 = '30 30 1';
			d1 = 256;
			u1 = 128;
		} else if (player.multitool_setting == 1521 || player.multitool_setting == 1531
		|| player.multitool_setting == 1536 || player.multitool_setting == 1537) {
			//fence mil tower
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 192';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 96;
		} else if (player.multitool_setting == 1550) {
			//wall Tank pyrs
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 256;
			u1 = 256;
		} else if (player.multitool_setting == 1551) {
			//wall Tank pier
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 256';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 384;
			u1 = 256;
		} else {
			v1 = '192 192 2';
			v2 = '-192 -192 2';
			v3 = '192 -192 2';
			v4 = '-192 -192 2';
			h1 = '0 0 896';
			m1 = '-192 -192 0';
			m2 = '192 192 16';
			d1 = 128;
			u1 = 112;
		}
		
		traceline(tracer.origin + v1, tracer.origin - '0 0 10000', myblocktype, tracer);
		eg1_end = trace_endpos;
		
		traceline(tracer.origin + v2, tracer.origin - '0 0 10000', myblocktype, tracer);
		eg2_end = trace_endpos;
		
		traceline(tracer.origin + v3, tracer.origin - '0 0 10000', myblocktype, tracer);
		eg3_end = trace_endpos;
		
		traceline(tracer.origin + v4, tracer.origin - '0 0 10000', myblocktype, tracer);
		eg4_end = trace_endpos;
		
		tracebox(tracer.origin + h1, m1, m2, tracer.origin - '0 0 10000', MOVE_NORMAL, tracer);
		tb_end = trace_endpos;
		
		vector v_lockzd_tl_end;
		if (player.multitool_lockz) {
			v_lockzd_tl_end_x = tl_end_x;
			v_lockzd_tl_end_y = tl_end_y;
			v_lockzd_tl_end_z = player.multitool_lockzsetting;
			//print(vtos(v_lockzd_tl_end), "Lockzified tlend for comparison\n");
		}
		
		//print("MultiToolAmmoC: ", ftos(self.multitool_ammocurrent), "\n");
		//print("Max: ", ftos(self.multitool_ammomax), "\n");
		if (weshouldbailearly) {
			//We told player he couldn't build on a shield (unless the server enabled this)
		} else if (!(multitool_hasknowledge(player, player.multitool_setting, 1, ""))) {
			//We tell the player we have insufficent knowlege to build, in the routine
		} else if((tl_sf & Q3SURFACEFLAG_NOIMPACT) || tl_frac == 1)
		{
			sprint(self, "cannot build there (bad surface)\n");
		} else if (!autocvar_g_balance_multitool_allowobstructions && (
		(!((player.multitool_setting <= -600 && player.multitool_setting > -1000)
		|| (player.multitool_setting == 566 || player.multitool_setting == 574 || player.multitool_setting == 575
		|| player.multitool_setting == 564 || player.multitool_setting == 576 || player.multitool_setting == 584
		|| player.multitool_setting == 1538
		|| player.multitool_setting == 583 || player.multitool_setting == 1680
		|| player.multitool_setting == 610 || player.multitool_setting == 611
		|| player.multitool_setting == 612
		|| player.multitool_setting == 616
		|| player.multitool_setting == 1681
		|| player.multitool_setting == 1686)))
		&& (tb_end_z > (tl_end_z + u1))
		)) {
			//Not Vaults/Floors/Fill
			sprint(self, "cannot build there (obstructions or excessive grade)\n");
			//print("TL: ", ftos(tl_end_z), "\n");
			//print("TB: ", ftos(tb_end_z), "\n");
			
			if (!player.multitool_blocktype) {
				//We don't have blocktype toggled to any and are trying to build on a
				//structure, maybe this is the reason for the error?
				investigatemore = 1; //Sometimes its from trying to build buildings ontop of buildings
				                     //Inwhich case we want to tell the player what setting to change
			}
			
		} else if (!autocvar_g_balance_multitool_allowobstructions &&(
		((player.multitool_setting <= -600 && player.multitool_setting > -1000)
		|| (player.multitool_setting == 566 || player.multitool_setting == 574 || player.multitool_setting == 575
		|| player.multitool_setting == 564 || player.multitool_setting == 576 || player.multitool_setting == 584
		|| player.multitool_setting == 1538
		|| player.multitool_setting == 583 || player.multitool_setting == 1680
		|| player.multitool_setting == 610 || player.multitool_setting == 611
		|| player.multitool_setting == 612
		|| player.multitool_setting == 616
		|| player.multitool_setting == 1681
		|| player.multitool_setting == 1686))
		&& (tb_end_z > (tl_end_z + u1))
		&& (!multitool_CheckIfNearBuilding(v_lockzd_tl_end, 128))
		)) {
			//Vault/Floors/Fill
			sprint(self, "cannot build vault/floor there (obstructions or excessive grade while not near other vault or floor)\n");
			//print("TL: ", ftos(tl_end_z), "\n");
			//print("TB: ", ftos(tb_end_z), "\n");
		} else if ((
		(player.multitool_setting < 700 && player.multitool_setting > MTB64BOUNDLAST)
		|| (player.multitool_setting < MTB64UBOUNDFIRST && player.multitool_setting > MTB64UBOUNDLAST)
		) &&
		(
		(tl_end_z > (eg1_end_z + d1)) ||
		(tl_end_z > (eg2_end_z + d1)) ||
		(tl_end_z > (eg3_end_z + d1)) ||
		(tl_end_z > (eg4_end_z + d1))
		)
		){
			//regular bulidings and walls (less than and greater than MTB64BOUNDLAST id)
			sprint(self, "cannot build there (too close to edge or excessive overhang)\n");
		} else if ((player.multitool_lockz != 1 && player.multitool_placetype != 1) && 
		(
		(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
		) &&
		(
		(tl_end_z > (eg1_end_z + d1)) ||
		(tl_end_z > (eg2_end_z + d1)) ||
		(tl_end_z > (eg3_end_z + d1)) ||
		(tl_end_z > (eg4_end_z + d1))
		) &&
		(!multitool_CheckIfNearBuilding(tl_end, 32))
		){
			//Blocks
			sprint(self, "cannot build block there (too close to edge or excessive overhang)\n");
		} else if ((player.multitool_lockz) && 
		(
		(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
		) &&
		(
		(tl_end_z > (eg1_end_z + d1)) ||
		(tl_end_z > (eg2_end_z + d1)) ||
		(tl_end_z > (eg3_end_z + d1)) ||
		(tl_end_z > (eg4_end_z + d1))
		) &&
		(!multitool_CheckIfNearBuilding(v_lockzd_tl_end, 64))
		){
			//Blocks
			sprint(self, "cannot build block there (too close to edge or excessive overhang with lockZ enabled)\n");	
		} else if ((player.multitool_placetype) && 
		(
		(player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)
		) &&
		(
		(tl_end_z > (eg1_end_z + d1)) ||
		(tl_end_z > (eg2_end_z + d1)) ||
		(tl_end_z > (eg3_end_z + d1)) ||
		(tl_end_z > (eg4_end_z + d1))
		) &&
		(!multitool_CheckIfNearBuilding(tl_end, 64))
		){
			//Blocks
			sprint(self, "cannot build block there (too close to edge or excessive overhang with PlaceType enabled)\n");	
		
		} else if (multitool_tooclose(player)) {
			sprint(player, "cannot build there (too close to enemy occupied land)\n");
		} else if (multitool_toofar(player)) {
			sprint(player, "cannot build there (build a base in the vicinity)\n");
		} else if (multitool_decreaseammo(player)) {
			entity e, f;
			e = spawn();
			f = spawn();
			e.angles = f.angles = self.v_angle;
			//print(" VAngles: ", vtos(self.v_angle));
			e.count = f.count = self.multitool_setting;
			e.owner = f.owner = self;
			
			if ((player.multitool_setting >= 500
			&& player.multitool_setting < 1000)
			|| (player.multitool_setting >= 10000
			&& player.multitool_setting < 20000)
			|| (player.multitool_setting <= -500
			&& player.multitool_setting > -1000)
			|| (player.multitool_setting >= 1500
			&& player.multitool_setting < 2000)) {
				if (autocvar_g_balance_multitool_wall_zsnap) {
					float bkup_tl_end_z;
					bkup_tl_end_z = tl_end_z;
					
					if (player.multitool_zsnapmulti) {
						tl_end_z = fsnap(tl_end_z, (autocvar_g_balance_multitool_wall_zsnap * player.multitool_zsnapmulti));
					} else {
						if (player.multitool_setting == MTB64U_PLATFORM_8
						|| player.multitool_setting == MTB64U_PLATFORM_16
						|| player.multitool_setting == MTB64U_PLATFORM_24
						|| player.multitool_setting == MTB64U_PLATFORM_32
						|| player.multitool_setting == MTB64_PLATFORMWOOD_8
						|| player.multitool_setting == MTB64_PLATFORMWOOD_24) {
								//An exception: Small platforms for rasing things slightly in height (such as point defenses)
								//Used to set proper height for firing out of pillboxes etc
								//They don't follow normal 64block zsnap
						} else if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
						|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
							//Blocks, Zsnap should be 64 if default
							tl_end_z = fsnap(tl_end_z, 64);
						} else {
							tl_end_z = fsnap(tl_end_z, autocvar_g_balance_multitool_wall_zsnap);
						}
					}
					
					if (player.multitool_setting == MTB64U_PLATFORM_8
					|| player.multitool_setting == MTB64U_PLATFORM_16
					|| player.multitool_setting == MTB64U_PLATFORM_24
					|| player.multitool_setting == MTB64U_PLATFORM_32
					|| player.multitool_setting == MTB64_PLATFORMWOOD_8
					|| player.multitool_setting == MTB64_PLATFORMWOOD_24) {
						//An exception: Small platforms for rasing things slightly in height (such as point defenses)
						//Used to set proper height for firing out of pillboxes etc
						//They don't follow normal 64block zsnap
						//Do nothing
					//Blocks, Got to make sure they're on the ground:
					} else if (player.multitool_lockz != 1) {
					if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
					|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
						if ((bkup_tl_end_z - tl_end_z) < 0) {
							//print(ftos(bkup_tl_end_z)," bkup\n");
							//print(ftos(tl_end_z)," endz\n");
							//print("moving block down, so not floating slightly above\n");
							tl_end_z = tl_end_z - 64;
							//print(ftos(tl_end_z)," Moved\n");
						}
					}
					}
				}
			
			}
			
			if (player.multitool_lockz != 1) {
				player.multitool_lockzsetting = tl_end_z;
			} else {
				if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
				|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
					//Blocks
					//Rember the 64x64 BSP model block rests above the Z origin
					//___[]____
					//Not: ---[]---
					//So if you want to search from where the center is add +32 to z
					//(usually no, sometimes yes)
					if (multitool_CheckInSolid(v_lockzd_tl_end + '0 0 32', 32) >= 1) {
						//We add 32 to Z for above reason (block model is not centered on the Z axis, it is all positive)
						sprint(player, "lockZ in solid at all points, cannot lock Z\n");
					} else if (multitool_CheckIfNearWorld(v_lockzd_tl_end + '0 0 32', 16, 2)) {
						//Yea, same as below but, KISS
						//Tried 32, allowed blocks too far away from wall
						//Trying 16
						tl_end_z = player.multitool_lockzsetting;
					} else if ((((tl_end_z - player.multitool_lockzsetting) > 256)
					|| ((tl_end_z - player.multitool_lockzsetting) < -256))
					&&(!multitool_CheckIfNearBuilding(v_lockzd_tl_end, 64)))
					{
						sprint(player, "trace and lockZ difference too great, cannot lock Z\n");
					} else if ((((tl_end_z - player.multitool_lockzsetting) > 32)
					|| ((tl_end_z - player.multitool_lockzsetting) < -32))
					&&(!multitool_CheckIfNearBuilding(v_lockzd_tl_end, 64)))
					{
						//Possible settings: (v_lockzd_tl_end, 128)
						//128 gives 2 blocks radius from support, so
						//You get to build floating blocks, but not far from closest support
						//[] [] : 1 missing block is the most, to make building not too frustrating
						//Possible settings: (v_lockzd_tl_end, 64)
						//64 gives 1 block radius from support
						sprint(player, "trace and lockZ difference too great when not near support, cannot lock Z\n");	
					} else {
						tl_end_z = player.multitool_lockzsetting;
					}
				} else if ((player.multitool_setting >= 630 && player.multitool_setting <= 639)
					|| (player.multitool_setting >= 640 && player.multitool_setting <= 679)
					|| (player.multitool_setting >= 1630 && player.multitool_setting <= 1639)) {
					//Foundations
					if (((tl_end_z - player.multitool_lockzsetting) > 1536)
					|| ((tl_end_z - player.multitool_lockzsetting) < -1536))
					{
						sprint(player, "trace and lockZ difference too great, cannot lock Z\n");	
					} else {
						tl_end_z = player.multitool_lockzsetting;
					}
				} else if (player.multitool_setting >= 1650 && player.multitool_setting <= 1659) {
					//Foundations
					if (((tl_end_z - player.multitool_lockzsetting) > 3072)
					|| ((tl_end_z - player.multitool_lockzsetting) < -3072))
					{
						sprint(player, "trace and lockZ difference too great, cannot lock Z\n");	
					} else {
						tl_end_z = player.multitool_lockzsetting;
					}
				} else {
					//Buildings
					if (((tl_end_z - player.multitool_lockzsetting) > 512)
					|| ((tl_end_z - player.multitool_lockzsetting) < -512))
					{
						sprint(player, "trace and lockZ difference too great, cannot lock Z\n");	
					} else {
						tl_end_z = player.multitool_lockzsetting;
					}
				}
			}

			if not (player.multitool_doorcenter) player.multitool_doorcenter = 0; //Because null and 0 are not the same for below comparison with the autocvar
			
			//We center door if it is enabled
			if (player.multitool_doorcenter == autocvar_g_balance_multitool_doorcenterdefaultdisabled)
			if (multitool_isdoor(player.multitool_setting))
			{
				local vector doorcenterreturnvec;
				player.rtnvl2 = 0; //Another "return" value, 
				player.rtnvl3 = 0; //Another "return" value, 
				doorcenterreturnvec = multitool_fire_auto_centerdoor(tl_end, player);
				if (doorcenterreturnvec) {
					if (multitool_doorcentertooclose(doorcenterreturnvec, 32))
					{
						if ((clienttype(player) == CLIENTTYPE_REAL)) {
							sprint(player, "another door to close, could not center door\n");
						}
					} else {
						tl_end = doorcenterreturnvec;
						if (player.rtnvl2) {
							//Gap equal or less than 64
							if (player.rtnvl3) {
								//Short door (96z)
								f.multitool_doorcenter = 2.5; //set these so we can choose proper door frame
								e.multitool_doorcenter = 2.5;
							} else {
								f.multitool_doorcenter = 2; //set these so we can choose proper door frame
								e.multitool_doorcenter = 2;
							}
						} else {
							if (player.rtnvl3) {
								//Short door (96z)
								f.multitool_doorcenter = 1.5; //set these so we can choose proper door frame
								e.multitool_doorcenter = 1.5;
							} else {
								f.multitool_doorcenter = 1; //set these so we can choose proper door frame
								e.multitool_doorcenter = 1;
							}
						}
					}
				} else {
					if ((clienttype(player) == CLIENTTYPE_REAL)) {
						if (player.multitool_annoymsgtime2 < time) {
							sprint(player, "could not center door\n");
							player.multitool_annoymsgtime2 = time + 5;
							player.multitool_annoymsgtime3 = 0; //So next time door can be centered it will be told
						}
					}
				}
				player.rtnvl2 = 0;
				player.rtnvl3 = 0;
					
			}
			
			if not (player.multitool_furndrop) player.multitool_furndrop = 0; //Because null and 0 are not the same for below comparison with the autocvar
			
			//We drop furniature if it is enabled
			if (player.multitool_furndrop == autocvar_g_balance_multitool_furndropdefaultdisabled)
			if (multitool_isfurniture(player.multitool_setting))
			{
				tl_end = multitool_fire_auto_dropfurn(tl_end, player);
			}
			
			if (player.multitool_setting == 503 || player.multitool_setting == 1502
			|| player.multitool_setting == 110 || player.multitool_setting == 111 
		   	|| player.multitool_setting == 112
			|| player.multitool_setting == 1110 || player.multitool_setting == 1111
			|| player.multitool_setting == 1112 || player.multitool_setting == 1113
		   	|| player.multitool_setting == 1114 || player.multitool_setting == 1115
			|| player.multitool_setting == 1116 || player.multitool_setting == 1117 || player.multitool_setting == 1118
			|| player.multitool_setting == MTB64U_PLATFORM_8 || player.multitool_setting == MTB64U_PLATFORM_16
			|| player.multitool_setting == MTB64U_PLATFORM_24 || player.multitool_setting == MTB64U_PLATFORM_32
			|| player.multitool_setting == MTB64_PLATFORMWOOD_8 || player.multitool_setting == MTB64_PLATFORMWOOD_24)
			{
				//Recruitment posts and pointdefense guns are dropped a short way to floor, as are platforms for placing them on
				tl_end = multitool_fire_auto_droprecruitmentpost(tl_end);
			}
			
			if (player.multitool_setting == 20) {
				//print("Treetop Sentry (treehouse)\n");
				
				local entity ftreeent;
				ftreeent = multitool_findneartree(tl_end, TREETOP_SENTRY_RADIUS);
				
				if (ftreeent != world) {
					tl_end = ftreeent.origin;
					tl_end_z = ftreeent.origin_z + ftreeent.maxs_z + TREETOP_SENTRY_ZADD;
					//print("set tree z to", ftos(tl_end_z), "\n");
					
					e.requiresexist = ftreeent; //Later we will check this to see if it exists every so often, if not goodby treehouse
				}
			}
			
			setorigin(e, tl_end);
			setorigin(f, tl_end);
			e.think = func_null;
			f.think = multitool_scaffold_spawner;
			
			if ((player.multitool_setting >= 570 && player.multitool_setting <= 579)
			|| (multitool_isbuildingcurtainstone(player.multitool_setting))
			|| (multitool_isbuildingcastlestoneextra(player.multitool_setting))
			|| (player.multitool_setting == 6) || (player.multitool_setting == 8)
			|| (player.multitool_setting == 7) || (player.multitool_setting == 10)
			|| (player.multitool_setting == 27) 
			|| (player.multitool_setting >= 660 && player.multitool_setting <= 669)
			|| (player.multitool_setting >= 10700 && player.multitool_setting <= 10799))
			{
				multitool_forcecastlecolormaybe(player); //Force castle color if applicable
				//print("castlecolor7\n");
				if (player.multitool_castlecolor) {
					e.multitool_castlecolor = player.multitool_castlecolor; //For block spawn
					f.multitool_castlecolor = player.multitool_castlecolor; //For block scaffold spawn
				}
				
				if (player.multitool_setting == 616 && player.multitool_woodcolor) {
					e.multitool_woodcolor = player.multitool_woodcolor; //For block spawn
					f.multitool_woodcolor = player.multitool_woodcolor; //For block scaffold spawn
				}
			}
			
			if ((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
			|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST)) {
				if (player.multitool_flipblock) {
					e.multitool_flipblock = 1; //For block spawn
					f.multitool_flipblock = 1; //For block scaffold spawn
				}
				
				if (player.multitool_roofcolor) {
					e.multitool_roofcolor = player.multitool_roofcolor; //For block spawn
					f.multitool_roofcolor = player.multitool_roofcolor; //For block scaffold spawn
				}
				
				if (player.multitool_flamecolor) {
					e.multitool_flamecolor = player.multitool_flamecolor; //For block spawn
					f.multitool_flamecolor = player.multitool_flamecolor; //For block scaffold spawn
				}
				
				if (player.multitool_woodcolor) {
					e.multitool_woodcolor = player.multitool_woodcolor; //For block spawn
					f.multitool_woodcolor = player.multitool_woodcolor; //For block scaffold spawn
				}
				
				if (player.multitool_marblecolor) {
					e.multitool_marblecolor = player.multitool_marblecolor; //For block spawn
					f.multitool_marblecolor = player.multitool_marblecolor; //For block scaffold spawn
				}
				
				if (player.multitool_castlecolor) {
					e.multitool_castlecolor = player.multitool_castlecolor; //For block spawn
					f.multitool_castlecolor = player.multitool_castlecolor; //For block scaffold spawn
				}
				
				if (player.multitool_sstonecolor) {
					e.multitool_sstonecolor = player.multitool_sstonecolor; //For block spawn
					f.multitool_sstonecolor = player.multitool_sstonecolor; //For block scaffold spawn
				}
			}
			f.subordinate = e;
			f.nextthink = time;
			if (player.rtnvl2) {
				f.multitool_ammocurrent = player.rtnvl2; //What converted nails were used to build this.
				player.rtnvl2 = 0;
			}
		} else {
			sprint(self, "Insufficent Ammunition ^7(press ^xFF7E+R^7 to convert ^x000Nails^7, ^xF41Shift+R^7 to convert ^xE00Rockets^7, ^x70FF+R^7 to convert ^x30DCells^7)\n");	
		}
		
		if( tracer != self ) {
			//////Thanks to icodestuff for finding this entity leak//////
			//print("Tracer is not self, thus was spawned for the wall xy snap code: removing tracer\n");
			if( tracer != world ) { //Who knows what could happen in quakeC, from one line to the next
				//print("Tracer is not world either, it shouldn't be anyway, but not even C code runs on the metal so... is any of it truely deterministic, executing the way we write it?\n");
				remove(tracer);
			}
		}
		//print(etos(self), " self " ,self.model," - ", etos(tracer), " tracer " ,tracer.model, " model\n");//make sure
	
		if ((player.multitool_blocktype == 1) ||
		((player.multitool_setting >= 700 && player.multitool_setting <= MTB64BOUNDLAST)
		|| (player.multitool_setting >= MTB64UBOUNDFIRST && player.multitool_setting <= MTB64UBOUNDLAST))
		|| (player.multitool_setting == 503 || player.multitool_setting == 1502
		   || player.multitool_setting == 110 || player.multitool_setting == 111 
		   || player.multitool_setting == 112
		   || player.multitool_setting == 1110 || player.multitool_setting == 1111
		   || player.multitool_setting == 1112 || player.multitool_setting == 1113
		   || player.multitool_setting == 1114 || player.multitool_setting == 1115
		   || player.multitool_setting == 1116 || player.multitool_setting == 1117 || player.multitool_setting == 1118
		   || player.multitool_setting == MTB64U_PLATFORM_8 || player.multitool_setting == MTB64U_PLATFORM_16
		   || player.multitool_setting == MTB64U_PLATFORM_24 || player.multitool_setting == MTB64U_PLATFORM_32
		   || player.multitool_setting == MTB64_PLATFORMWOOD_8 || player.multitool_setting == MTB64_PLATFORMWOOD_24)) {
			//RESET STUFF;
			player.movetype = playerprevmovetype;
		}
	}
	
	if (investigatemore == 1) {
		multitool_investigatemore_obstructions_or_excessive_grade(plyr);
	}
	
	if ((plyr.multitool_setting >= 700 && plyr.multitool_setting <= MTB64BOUNDLAST)
	|| (plyr.multitool_setting >= MTB64UBOUNDFIRST && plyr.multitool_setting <= MTB64UBOUNDLAST)) {
		ATTACK_FINISHED(self) = time + autocvar_g_balance_multitool_refire_blocks * W_WeaponRateFactor();
		weapon_thinkf(WFRAME_FIRE1, autocvar_g_balance_multitool_refire_blocks, multitool_fire_auto);
	} else {
		ATTACK_FINISHED(self) = time + autocvar_g_balance_multitool_refire * W_WeaponRateFactor();
		weapon_thinkf(WFRAME_FIRE1, autocvar_g_balance_multitool_refire, multitool_fire_auto);
	}
	//ATTACK_FINISHED(self) = time + autocvar_g_balance_multitool_sustained_refire * W_WeaponRateFactor();
	//weapon_thinkf(WFRAME_FIRE1, autocvar_g_balance_multitool_sustained_refire, multitool_fire_auto);
}

void spawnfunc_weapon_multitool()
{    
	weapon_defaultspawnfunc(WEP_MULTITOOL);
}

void multitool_displaybuildinginfo (entity player,entity eburn)
{
	
	if (clienttype(player) == CLIENTTYPE_REAL) {
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	//You probably do not like this look up table.
	//Would you prefer a string stuffed with the color code?
	//strcated together with something? Eachtime this is called
	//I wonder how or if quakec frees and unused string?
	//Or do they just sit there, unused, forever past their creation?
	//I ask this because in QC strings are pointers to an immutable area that has the data.
	//If we kept making strings and then never used them again, would we waste memory?
	//Or would darkplaces know to free the unused ones?
	//... Thus the table:
	if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.01) {
		sprint(player, sprintf(_("^x200 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.025) {
		sprint(player, sprintf(_("^x250 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.05) {
		sprint(player, sprintf(_("^x500 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.10) {
		sprint(player, sprintf(_("^x800 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.15) {
		sprint(player, sprintf(_("^xF00 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.20) {
		sprint(player, sprintf(_("^xF40 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.25) {
		sprint(player, sprintf(_("^x840 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.35) {
		sprint(player, sprintf(_("^x440 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.55) {
		sprint(player, sprintf(_("^x480 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.75) {
		sprint(player, sprintf(_("^x080 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.95) {
		sprint(player, sprintf(_("^x0F0 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else if (eburn.vehicle_health/eburn.bldhitbx_max_health < 0.98) {
		sprint(player, sprintf(_("^x0F8 %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	} else {
		//Otherwise we must be greate than 98 percent health, very good:
		sprint(player, sprintf(_("^x0FE %.0f / %.0f Building Integrity^7\n"), eburn.vehicle_health , eburn.bldhitbx_max_health));
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	}
}

void multitool_repairbuilding_scaffold(entity targ)
{
	entity e, f;
	e = spawn();
	f = spawn();
	e.angles = f.angles = targ.angles;
	e.count = f.count = targ.count;
	e.owner = f.owner = targ.subordinate5;

	if (targ.usealtorigin) {
		setorigin(e, targ.altorigin);
		setorigin(f, targ.altorigin);
	} else {
	setorigin(e, targ.origin);
	setorigin(f, targ.origin);
	}
	
	e.think = func_null;
	f.think = multitool_scaffold_spawner;
	
	if ((targ.count >= 570 && targ.count <= 579)
	|| (multitool_isbuildingcurtainstone(targ.count))
	|| (multitool_isbuildingcastlestoneextra(targ.count))
	|| (targ.count == 6) || (targ.count == 8)
	|| (targ.count == 7) || (targ.count == 10)
	|| (targ.count == 27)
	|| (targ.count >= 660 && targ.count <= 669)
	|| (targ.count >= 10700 && targ.count <= 10799)) {
		//print("castlecolors8\n");
		if (targ.multitool_castlecolor) {
			//print("castlecolorC\n");
			e.multitool_castlecolor = targ.multitool_castlecolor; //For block spawn
			f.multitool_castlecolor = targ.multitool_castlecolor; //For block scaffold spawn
		}
		
		if (targ.count == 616 && targ.multitool_woodcolor) {
			//print("woodcolorC\n");
			e.multitool_woodcolor = targ.multitool_woodcolor; //For block spawn
			f.multitool_woodcolor = targ.multitool_woodcolor; //For block scaffold spawn
		}
	}
	
	if ((targ.count >= 700 && targ.count <= MTB64BOUNDLAST)
	|| (targ.count >= MTB64UBOUNDFIRST && targ.count <= MTB64UBOUNDLAST)) {
		if (targ.multitool_flipblock) {
			//print("flipblockC\n");
			e.multitool_flipblock = 1; //For block spawn
			f.multitool_flipblock = 1; //For block scaffold spawn
			e.origin_z = e.origin_z - 64;
			f.origin_z = f.origin_z - 64;
			setorigin(e, e.origin);
			setorigin(f, e.origin);
		}
				
		if (targ.multitool_roofcolor) {
			//print("roofcolorC\n");
			e.multitool_roofcolor = targ.multitool_roofcolor; //For block spawn
			f.multitool_roofcolor = targ.multitool_roofcolor; //For block scaffold spawn
		}
				
		if (targ.multitool_flamecolor) {
			//print("flamecolorC\n");
			e.multitool_flamecolor = targ.multitool_flamecolor; //For block spawn
			f.multitool_flamecolor = targ.multitool_flamecolor; //For block scaffold spawn
		}
				
		if (targ.multitool_woodcolor) {
			//print("woodcolorC\n");
			e.multitool_woodcolor = targ.multitool_woodcolor; //For block spawn
			f.multitool_woodcolor = targ.multitool_woodcolor; //For block scaffold spawn
		}
		
		if (targ.multitool_marblecolor) {
			//print("marblecolorC\n");
			e.multitool_marblecolor = targ.multitool_marblecolor; //For block spawn
			f.multitool_marblecolor = targ.multitool_marblecolor; //For block scaffold spawn
		}
		
		if (targ.multitool_castlecolor) {
			//print("castlecolorC\n");
			e.multitool_castlecolor = targ.multitool_castlecolor; //For block spawn
			f.multitool_castlecolor = targ.multitool_castlecolor; //For block scaffold spawn
		}
		
		if (targ.multitool_sstonecolor) {
			//print("sstonecolorC\n");
			e.multitool_sstonecolor = targ.multitool_sstonecolor; //For block spawn
			f.multitool_sstonecolor = targ.multitool_sstonecolor; //For block scaffold spawn
		}
		
		e.multitool_doorcenter = targ.multitool_doorcenter; //So we will set proper door frame
		f.multitool_doorcenter = targ.multitool_doorcenter;
	}
	f.subordinate = e;
	f.nextthink = time;
}

void multitool_setzsnap(entity player)
{
	if(player.BUTTON_HOOK) {
		//E	
		player.multitool_zsnapmulti = player.multitool_zsnapmulti + 1;
		if (player.multitool_zsnapmulti > 6) {
			player.multitool_zsnapmulti = 0;
		}
		spamsound (player, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.35, ATTN_NORM); 

	} else if(player.BUTTON_USE) {
		//F
		player.multitool_zsnapmulti = player.multitool_zsnapmulti - 1;
		if (player.multitool_zsnapmulti < 0) {
			player.multitool_zsnapmulti = 6;
		}
		spamsound (player, CH_SHOTS, "misc/decreasevalue.wav", VOL_BASE * 0.35, ATTN_NORM);
	} 
	
	if (player.multitool_zsnapmulti) {
		sprint(player, sprintf("Wall ZSnap Setting: %f\n", player.multitool_zsnapmulti * autocvar_g_balance_multitool_wall_zsnap));
	} else {
		sprint(player, sprintf("Wall ZSnap Setting: %f (default) , 64 (for blocks)\n", autocvar_g_balance_multitool_wall_zsnap));
	}
}

void multitool_repairbuilding(entity player, float repairhp)
{
	local entity eburn;
	eburn = findradius(player.origin, 32);
	while(eburn)
	{
		if not(eburn == world)
		{
		//BEGIN//
		if (eburn.classname == "bldhitbx")
		{
			
			if (eburn.vehicle_health < eburn.bldhitbx_max_health) {
				eburn.vehicle_health = eburn.vehicle_health + repairhp;
				
				if(eburn.vehicle_health > eburn.bldhitbx_max_health)
					eburn.vehicle_health = eburn.bldhitbx_max_health;
					
				float r;
				r = random() * 5;
				if (r > 4) {
					spamsound (self, CH_PAIN, "object/impact_metal_5.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 3) {
					spamsound (self, CH_PAIN, "object/impact_metal_4.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 2) {
					spamsound (self, CH_PAIN, "object/impact_metal_3.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 1) {
					spamsound (self, CH_PAIN, "object/impact_metal_2.ogg", VOL_BASE, ATTN_NORM);
				} else {
					spamsound (self, CH_PAIN, "object/impact_metal_1.ogg", VOL_BASE, ATTN_NORM);
				}
			}
			
			multitool_displaybuildinginfo(player, eburn);
			
			return;		
		}
		else if (eburn.classname == "rubblemaster")
		{
			if (eburn.cnt >= 10) {
				multitool_repairbuilding_scaffold(eburn);
				//Also remove rubble;
				multitool_destroyrubble(eburn);
			} else {
				if (clienttype(player) == CLIENTTYPE_REAL) {
					sprint(player, sprintf(_("^x111 %.0f / 10 Rebuild From Rubble^7\n"), eburn.cnt));
				}
				eburn.cnt = eburn.cnt + 1;
			}
			return;
		}
		else if (eburn.multitool_reparableturret && eburn.health <= 0 && autocvar_g_turrets_allrepairable >= 0)
		{
			//We are repairable, our health is at 0 or less, autocvar_g_turrets_allrepairable is set to 0 or 1 and NOT -1
			//Using a new .float as the entities in question are outside the code of
			//this file, so we don't want to step on any toes.
			if (eburn.multitool_repairamnt >= 10000) {
				//Do nothing
			} else if (eburn.multitool_repairamnt >= 10) {
				eburn.multitool_repairamnt = 10000;  //This is set back to 0 on respawn
				eburn.think = turret_stdproc_respawn;
				eburn.nextthink = time + 0.2;
			} else {
				if (clienttype(player) == CLIENTTYPE_REAL) {
					sprint(player, sprintf(_("^x321 %.0f / 10 Rebuild Turret^7\n"), eburn.multitool_repairamnt));
				}
				eburn.multitool_repairamnt = eburn.multitool_repairamnt + 1;
				
				float r;
				r = random() * 5;
				if (r > 4) {
					spamsound (self, CH_PAIN, "object/impact_metal_5.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 3) {
					spamsound (self, CH_PAIN, "object/impact_metal_4.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 2) {
					spamsound (self, CH_PAIN, "object/impact_metal_3.ogg", VOL_BASE, ATTN_NORM);
				} else if (r > 1) {
					spamsound (self, CH_PAIN, "object/impact_metal_2.ogg", VOL_BASE, ATTN_NORM);
				} else {
					spamsound (self, CH_PAIN, "object/impact_metal_1.ogg", VOL_BASE, ATTN_NORM);
				}
			}
			return;
		}
		//END//
		}
	eburn = eburn.chain;
	}
	return;	
}

.entity multitoollight;
void multitool_thinklight() {
	//For setting show model
	if (self.owner.multitool_lit == 1 && self.multitool_lit == 1 && self.owner.health > 0) {
		//setorigin(self, self.owner.origin);
		self.nextthink = time;
		self.multitool_lit = 0;
		
		//set model here with the subroutine
		float trn;
		trn = 0;
		
		//print(etos(self.owner), " \n");
		//print(ftos(self.count), " vs ",  ftos(self.owner.multitool_setting),"\n");
		
		if ((self.count != self.owner.multitool_setting) || (self.owner.multitool_update3dscaf == 1)) {
			if (self.owner.multitool_setting == 0) {
				setmodel(self, "null");
			} else {
				//print("here\n");
				trn = multitool_scaffold_modelset(self, self.owner.multitool_setting);
				setmodel(self, self.model);
				self.cnt = trn; //Save for other frames upcoming
				self.owner.multitool_update3dscaf = 0;
			}
		}
		
		self.count = self.owner.multitool_setting;
		
		makevectors(self.owner.v_angle);
		//setorigin(self, self.owner.origin + self.owner.view_ofs + v_forward * 20);
		
		self.angles_y = self.owner.angles_y;
		
		if ((self.owner.multitool_setting >= 700 && self.owner.multitool_setting <= MTB64BOUNDLAST)
		|| (self.owner.multitool_setting >= MTB64UBOUNDFIRST && self.owner.multitool_setting <= MTB64UBOUNDLAST)) {
			if (self.owner.multitool_flipblock) {
				self.angles_x = 180;
				setorigin(self, self.owner.origin + '0 0 32' + v_forward * 10); //+64*0.25, blocks models are from 0 to 64 z, so flipping it...
				
			} else {
				self.angles_x = 0;
				setorigin(self, self.owner.origin + '0 0 16' + v_forward * 10);
			}
		} else {
			self.angles_x = 0;
			setorigin(self, self.owner.origin + '0 0 16' + v_forward * 10);
		}

		//Snap angles
		if (self.angles_y < 135 && self.angles_y >= 45)
			self.angles_y = 90;
		else if (self.angles_y < 45 && self.angles_y >= -45)
			self.angles_y = 0;
		else if (self.angles_y < -45 && self.angles_y >= -135)
			self.angles_y = -90;
		else
			self.angles_y = 180;
		
		self.angles_y = self.angles_y + self.cnt;
	} else {
		if (self.owner && (self.owner != world)) {
			self.nextthink = time;
			setorigin(self, self.owner.origin);
			setmodel(self, "null");
		} else {
			print(etos(self)," removing mutitool shadow\n");
			self.nextthink = time;
			self.alpha = -1;
			setmodel(self, "null");
			remove_safely(self);
		}
	}
}

void multitool_spawnlight() {
	local entity newmultitoollight;
	newmultitoollight = spawn();
	//newmultitoollight.pflags = PFLAGS_FULLDYNAMIC;
	newmultitoollight.owner = self;
	newmultitoollight.drawonlytoclient = newmultitoollight.owner;
	newmultitoollight.think = multitool_thinklight;
	newmultitoollight.nextthink = time;
	newmultitoollight.multitool_lit = 1;
	newmultitoollight.scale = 0.25;
	//newmultitoollight.scale = 0.125;
	//newmultitoollight.scale = 0.0625;
	newmultitoollight.alpha = 0.50;
	newmultitoollight.solid = SOLID_NOT;
	setmodel(newmultitoollight, "null");
	self.multitoollight = newmultitoollight;
}

float multitool_setting_print(entity meprint, float pmtdosounds, float pmtsetting) {
				local float myreturna;
				myreturna = 1; //Start with requirements met, if not it will be changed to 0 below
				
				multitool_forcecastlecolormaybe(meprint); //Force castle color if applicable
				
				if (meprint.multitool_setting == -4) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Dojo");
				} else if (meprint.multitool_setting == -3) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Shrine");
				} else if (meprint.multitool_setting == -2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: House");
				} else if (meprint.multitool_setting == -1) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: SniperSpire");
				} else if (meprint.multitool_setting == -5) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: BellTower");
				} else if (meprint.multitool_setting == 0) {
					sprint(meprint, "Melee\n");
				} else if (meprint.multitool_setting == 1) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Tower-MG");
				} else if (meprint.multitool_setting == 2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Tower-Plasma");
				} else if (meprint.multitool_setting == 3) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Tower-MLRS");
				} else if (meprint.multitool_setting == 4) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Garrison");
				} else if (meprint.multitool_setting == 5) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Stronghold");
				} else if (meprint.multitool_setting == 6) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: StrongTower");
				} else if (meprint.multitool_setting == 7) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: SmallCastle");
				} else if (meprint.multitool_setting == 8) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: HellionTower");
				} else if (meprint.multitool_setting == 9) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: TownHall");
				} else if (meprint.multitool_setting == 10) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: HKTower");
				} else if (meprint.multitool_setting == 11) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: GovernorsMansion");
				} else if (meprint.multitool_setting == 12) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Arsenal");
				} else if (meprint.multitool_setting == 13) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Barracks");
				} else if (meprint.multitool_setting == 14) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Church");
				} else if (meprint.multitool_setting == 15) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Hangar");
				} else if (meprint.multitool_setting == 16) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: TankHangar");
				} else if (meprint.multitool_setting == 17) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Chataeu");
				} else if (meprint.multitool_setting == 18) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: PalladianManor");
				} else if (meprint.multitool_setting == 19) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: StoneHouse");
				} else if (meprint.multitool_setting == 20) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Treetop Sentry");
				} else if (meprint.multitool_setting == 21) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: SiegeWorkshop");	
				} else if (meprint.multitool_setting == 22) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Gaol");
				} else if (meprint.multitool_setting == 23) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: SmallJail");
				
				} else if (meprint.multitool_setting == 24) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Forge N");
				} else if (meprint.multitool_setting == 25) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Forge R");
				} else if (meprint.multitool_setting == 26) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Forge E");
				
				} else if (meprint.multitool_setting == 27) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: CrusaderStronghold");
					
				} else if (autocvar_g_balance_multitool_ancientonly &&
					(meprint.multitool_setting == 110
					|| meprint.multitool_setting == 111
					|| meprint.multitool_setting == 112)) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Point Defense Scorpion Ballista");
				} else if (meprint.multitool_setting == 110) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Point Defense Hotchkiss M1914 Gun");
				} else if (meprint.multitool_setting == 111) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Point Defense Lewis Gun");
				} else if (meprint.multitool_setting == 112) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Point Defense Maxim Gun");
							
				} else if (meprint.multitool_setting == 501) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Field");
				} else if (meprint.multitool_setting == 502) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vineyard");
				} else if (meprint.multitool_setting == 503) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Recruitment Post");
				} else if (meprint.multitool_setting == 520) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Hedge");
				} else if (meprint.multitool_setting == 521) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Hedge-Tower");
				} else if (meprint.multitool_setting == 522) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Hedge-Tower-Round");
				} else if (meprint.multitool_setting == 523) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Hedge-Door");
				} else if (meprint.multitool_setting == 530) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Brick");
				} else if (meprint.multitool_setting == 531) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Brick-Tower");
				} else if (meprint.multitool_setting == 532) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Brick-Tower-Round");
				} else if (meprint.multitool_setting == 533) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Brick-Door");
				} else if (meprint.multitool_setting == 540) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade");
				} else if (meprint.multitool_setting == 541) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Tower");
				} else if (meprint.multitool_setting == 542) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Gate");
				} else if (meprint.multitool_setting == 543) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Gate-Large");
				} else if (meprint.multitool_setting == 544) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Woodwall");
				} else if (meprint.multitool_setting == 545) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Woodwall-Gate");
				} else if (meprint.multitool_setting == 546) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Palisade-Woodwall-Tower");
				} else if (meprint.multitool_setting == 550) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Berm");
				} else if (meprint.multitool_setting == 551) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Berm-Tower");
				} else if (meprint.multitool_setting == 560) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain");
				} else if (meprint.multitool_setting == 561) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Tower");
				} else if (meprint.multitool_setting == 562) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Tower-Round");
				} else if (meprint.multitool_setting == 563) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Door");
				} else if (meprint.multitool_setting == 564) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Fill");
				} else if (meprint.multitool_setting == 565) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Interior");
				} else if (meprint.multitool_setting == 566) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Curtain");
				} else if (meprint.multitool_setting == 567) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Fill-Stairs");
				} else if (meprint.multitool_setting == 568) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Interior-Door");
				} else if (meprint.multitool_setting == 569) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Curtain-Gate-Large");
				
				} else if (meprint.multitool_setting == 570) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle");
				} else if (meprint.multitool_setting == 571) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Tower");
				} else if (meprint.multitool_setting == 572) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Tower-Round");
				} else if (meprint.multitool_setting == 573) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Door");
				} else if (meprint.multitool_setting == 574) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Castle");
				} else if (meprint.multitool_setting == 575) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Castle-StarChamber");
				} else if (meprint.multitool_setting == 576) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Fill");
				} else if (meprint.multitool_setting == 577) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior");
				} else if (meprint.multitool_setting == 578) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Fill-Stairs");
				} else if (meprint.multitool_setting == 579) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Door");
				
				} else if (meprint.multitool_setting == 10700) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Door-Two");
				} else if (meprint.multitool_setting == 10701) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Door-Side");
				} else if (meprint.multitool_setting == 10702) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Window");	
				
				} else if (meprint.multitool_setting == 10703) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-ArrowLoop");
				} else if (meprint.multitool_setting == 10704) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Arch");
				} else if (meprint.multitool_setting == 10705) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-ArchIronBars");
				} else if (meprint.multitool_setting == 10706) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Alcove");
				} else if (meprint.multitool_setting == 10707) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Interior-Alcove-Top-Copper");
				
				} else if (meprint.multitool_setting == 10708) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Castle-Gate-Large");
					
				} else if (meprint.multitool_setting == 10709) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: W-C-Portcullis-Wood");
				} else if (meprint.multitool_setting == 10710) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: W-C-Portcullis-Iron");
					
				} else if (meprint.multitool_setting == 580) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish");
				} else if (meprint.multitool_setting == 581) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Tower");
				} else if (meprint.multitool_setting == 582) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Door");
				} else if (meprint.multitool_setting == 583) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Polish");
				} else if (meprint.multitool_setting == 584) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Fill");
				} else if (meprint.multitool_setting == 585) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Interior");
				} else if (meprint.multitool_setting == 586) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Fill-Stairs");
				} else if (meprint.multitool_setting == 587) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Interior-Door");
				} else if (meprint.multitool_setting == 588) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Wall-Polish-Gate-Large");
					
				} else if (meprint.multitool_setting == 610) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Roof-Copper");
				} else if (meprint.multitool_setting == 611) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Roof-Copper-End");
				} else if (meprint.multitool_setting == 612) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Roof-Copper-One");
				} else if (meprint.multitool_setting == 616) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Vault-Roof-Dome");
					
				} else if (meprint.multitool_setting == 630) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Foundation-Wall");	
				} else if (meprint.multitool_setting == 631) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Foundation-Tower");
				} else if (meprint.multitool_setting == 632) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Foundation-Tower-Round");
				} else if (meprint.multitool_setting == 633) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Foundation-Bridge");
				
				
				} else if (meprint.multitool_setting == 645) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Wood (Wide)");
				} else if (meprint.multitool_setting == 646) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Wood (Narrow)");
				} else if (meprint.multitool_setting == 650) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Curtain-Landing");
				} else if (meprint.multitool_setting == 651) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Curtain");
				} else if (meprint.multitool_setting == 652) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Curtain-Crenelated");
				
				} else if (meprint.multitool_setting == 660) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Castle-Landing");
				} else if (meprint.multitool_setting == 661) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Castle");
				} else if (meprint.multitool_setting == 662) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Castle-Crenelated");
				} else if (meprint.multitool_setting == 663) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Castle-Fortified");
				} else if (meprint.multitool_setting == 664) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Castle-Fortified-Covered");
					
				} else if (meprint.multitool_setting == 670) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Polish-Landing");
				} else if (meprint.multitool_setting == 671) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Polish");
				} else if (meprint.multitool_setting == 672) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Bridge-Polish-Crenelated");
					
				//Following 64x64 blocks start at 710 for shingles onwards. (700 absolute min)
				} else if (meprint.multitool_setting == MTB64_FILLED) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled");
				} else if (meprint.multitool_setting == MTB64_FILLED_D) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled(///)");
				} else if (meprint.multitool_setting == MTB64_FILLED_X) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled(X)");
				} else if (meprint.multitool_setting == MTB64_FILLED_I) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled(|||)");
				} else if (meprint.multitool_setting == MTB64_FILLED_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled Casing");
				} else if (meprint.multitool_setting == MTB64_FILLED_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Filled Corner");
				} else if (meprint.multitool_setting == MTB64_SHINGLES) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Casing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof SideCasing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Pyramidion");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Corner");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof RoundCorner");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Stairs");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof InsideCasing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Octoside");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof Octoside2");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof SideStairs");
				} else if (meprint.multitool_setting == MTB64_SHINGLES_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CorrugatedRoof InsideStairs");
						
				} else if (meprint.multitool_setting == MTB64_WOOD1) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1");
				} else if (meprint.multitool_setting == MTB64_WOOD1_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Casing");
				} else if (meprint.multitool_setting == MTB64_WOOD1_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 SideCasing");
				} else if (meprint.multitool_setting == MTB64_WOOD1_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Pyramidion");
				} else if (meprint.multitool_setting == MTB64_WOOD1_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Corner");
				} else if (meprint.multitool_setting == MTB64_WOOD1_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 RoundCorner");
				} else if (meprint.multitool_setting == MTB64_WOOD1_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Stairs");
				} else if (meprint.multitool_setting == MTB64_WOOD1_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 InsideCasing");
				} else if (meprint.multitool_setting == MTB64_WOOD1_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Octoside");
				} else if (meprint.multitool_setting == MTB64_WOOD1_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 Octoside2");
				} else if (meprint.multitool_setting == MTB64_WOOD1_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 SideStairs");
				} else if (meprint.multitool_setting == MTB64_WOOD1_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood1 InsideStairs");
						
				} else if (meprint.multitool_setting == MTB64_WOOD2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2");
				} else if (meprint.multitool_setting == MTB64_WOOD2_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Casing");
				} else if (meprint.multitool_setting == MTB64_WOOD2_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 SideCasing");
				} else if (meprint.multitool_setting == MTB64_WOOD2_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Pyramidion");
				} else if (meprint.multitool_setting == MTB64_WOOD2_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Corner");
				} else if (meprint.multitool_setting == MTB64_WOOD2_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 RoundCorner");
				} else if (meprint.multitool_setting == MTB64_WOOD2_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Stairs");
				} else if (meprint.multitool_setting == MTB64_WOOD2_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 InsideCasing");
				} else if (meprint.multitool_setting == MTB64_WOOD2_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Octoside");
				} else if (meprint.multitool_setting == MTB64_WOOD2_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Octoside2");
				} else if (meprint.multitool_setting == MTB64_WOOD2_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 SideStairs");
				} else if (meprint.multitool_setting == MTB64_WOOD2_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 InsideStairs");
				} else if (meprint.multitool_setting == MTB64_WOOD2_STAIRSCHEAP) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Wood2 Stairs-Cheap");
					
				} else if (meprint.multitool_setting == MTB64_CURTAIN) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Casing");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain SideCasing");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Pyramidion");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Corner");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain RoundCorner");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Stairs");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain InsideCasing");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Octoside");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain Octoside2");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain SideStairs");
				} else if (meprint.multitool_setting == MTB64_CURTAIN_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Curtain InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_CASTLE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle");
				} else if (meprint.multitool_setting == MTB64_CASTLE_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Casing");
				} else if (meprint.multitool_setting == MTB64_CASTLE_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle SideCasing");
				} else if (meprint.multitool_setting == MTB64_CASTLE_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Pyramidion");
				} else if (meprint.multitool_setting == MTB64_CASTLE_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Corner");
				} else if (meprint.multitool_setting == MTB64_CASTLE_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle RoundCorner");
				} else if (meprint.multitool_setting == MTB64_CASTLE_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Stairs");
				} else if (meprint.multitool_setting == MTB64_CASTLE_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle InsideCasing");
				} else if (meprint.multitool_setting == MTB64_CASTLE_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Octoside");
				} else if (meprint.multitool_setting == MTB64_CASTLE_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle Octoside2");
				} else if (meprint.multitool_setting == MTB64_CASTLE_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle SideStairs");
				} else if (meprint.multitool_setting == MTB64_CASTLE_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Castle InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_CASTLESQUARE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-CastleSquare");
				
				} else if (meprint.multitool_setting == MTB64_HEDGE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge");
				} else if (meprint.multitool_setting == MTB64_HEDGE_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Casing");
				} else if (meprint.multitool_setting == MTB64_HEDGE_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge SideCasing");
				} else if (meprint.multitool_setting == MTB64_HEDGE_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Pyramidion");
				} else if (meprint.multitool_setting == MTB64_HEDGE_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Corner");
				} else if (meprint.multitool_setting == MTB64_HEDGE_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge RoundCorner");
				} else if (meprint.multitool_setting == MTB64_HEDGE_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Stairs");
				} else if (meprint.multitool_setting == MTB64_HEDGE_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge InsideCasing");
				} else if (meprint.multitool_setting == MTB64_HEDGE_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Octoside");
				} else if (meprint.multitool_setting == MTB64_HEDGE_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge Octoside2");
				} else if (meprint.multitool_setting == MTB64_HEDGE_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge SideStairs");
				} else if (meprint.multitool_setting == MTB64_HEDGE_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Hedge InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_POLISH) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish");
				} else if (meprint.multitool_setting == MTB64_POLISH_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Casing");
				} else if (meprint.multitool_setting == MTB64_POLISH_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish SideCasing");
				} else if (meprint.multitool_setting == MTB64_POLISH_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Pyramidion");
				} else if (meprint.multitool_setting == MTB64_POLISH_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Corner");
				} else if (meprint.multitool_setting == MTB64_POLISH_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish RoundCorner");
				} else if (meprint.multitool_setting == MTB64_POLISH_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Stairs");
				} else if (meprint.multitool_setting == MTB64_POLISH_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish InsideCasing");
				} else if (meprint.multitool_setting == MTB64_POLISH_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Octoside");
				} else if (meprint.multitool_setting == MTB64_POLISH_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish Octoside2");
				} else if (meprint.multitool_setting == MTB64_POLISH_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish SideStairs");
				} else if (meprint.multitool_setting == MTB64_POLISH_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Polish InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Casing");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone SideCasing");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Pyramidion");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Corner");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone RoundCorner");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Stairs");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone InsideCasing");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Octoside");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone Octoside2");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone SideStairs");
				} else if (meprint.multitool_setting == MTB64_GRAYSTONE_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-GrayStone InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_SANDSTONEDARK) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneDark");
					
				} else if (meprint.multitool_setting == MTB64_SANDSTONE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Casing");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight SideCasing");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Pyramidion");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Corner");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight RoundCorner");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Stairs");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight InsideCasing");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Octoside");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight Octoside2");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight SideStairs");
				} else if (meprint.multitool_setting == MTB64_SANDSTONE_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-SandstoneLight InsideStairs");
					
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Casing");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble SideCasing");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Pyramidion");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Corner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble RoundCorner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Stairs");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble InsideCasing");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Octoside");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Octoside2");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble SideStairs");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble InsideStairs");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER_SOLID) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Solid RoundCorner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER_F) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RoundCorner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER_FB) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RoundCorner (Bottom)");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER_FT) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RoundCorner (Top)");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RCORNER_P) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble RoundCorner Podium");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RECCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Solid RecessedCorner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RECCORNER_F) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RecessedCorner");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RECCORNER_FB) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RecessedCorner (Bottom)");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_RECCORNER_FT) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble Fluted RecessedCorner (Top)");
				} else if (meprint.multitool_setting == MTB64_MARBLEWHITE_SCORNER_P) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Marble SquareCorner Podium");
				
		
				} else if (meprint.multitool_setting == MTB64_SHINGLES2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_CASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Casing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_SCASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles SideCasing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_PYR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Pyramidion");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_CORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Corner");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_RCORNER) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles RoundCorner");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_STAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Stairs");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_ICASING) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles InsideCasing");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_OS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Octoside");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_OS2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles Octoside2");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_SSTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles SideStairs");
				} else if (meprint.multitool_setting == MTB64_SHINGLES2_ISTAIRS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Shingles InsideStairs");
				
				} else if (meprint.multitool_setting == MTB64_STAKES_WOOD1) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Stakes Wood");
				} else if (meprint.multitool_setting == MTB64_PLATFORMWOOD_8) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Platform-8 Wood");
				} else if (meprint.multitool_setting == MTB64_PLATFORMWOOD_24) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Platform-24 Wood");
				
				} else if (meprint.multitool_setting == MTB64_BWIRE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-BarbedWire");
				
				} else if (meprint.multitool_setting == MTB64_WINDOW_WOODBAR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Window Wood Bars");
				} else if (meprint.multitool_setting == MTB64_WINDOW_IRONBAR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-Window Iron Bars");
				} else if (meprint.multitool_setting == MTB64_DOOR_R_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Door-64-Wood");
				} else if (meprint.multitool_setting == MTB64_DOOR_R_JWOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Door-64-Wood-Iron-Fittings");	
				} else if (meprint.multitool_setting == MTB64_DOOR_R_FWOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Door-64-Wood-Paneled-White");
				} else if (meprint.multitool_setting == MTB64_DOOR_R_IRONBAR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Door-64-Iron-Bars");
				
				} else if (meprint.multitool_setting == MTB64_FITTEDWINDOW_CASTLE_ALOOP) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: FittedWindow-64-Castle-Arrowloop");
				} else if (meprint.multitool_setting == MTB64_FITTEDWINDOW_CASTLE_SWALL) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: FittedWindow-64-Castle-SolidWall");
				} else if (meprint.multitool_setting == MTB64_FITTEDWINDOW_WINDOW) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: FittedWindow-64-Window");
					
				} else if (meprint.multitool_setting == MTB64_FURN_CHEST_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Chest-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_CHESTLARGE_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-LargeChest-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_CHAIR_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Chair-Wood");
				
				} else if (meprint.multitool_setting == MTB64_FURN_STOOL_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Stool-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_TABLE_OCT_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Table-Octagonal-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_TABLE_OCT_WOOD2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Table-Octagonal-DarkWood");
				} else if (meprint.multitool_setting == MTB64_FURN_BARREL_WOOD2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Barrel-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_BARREL_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Barrel-Wood-Tapped");
					
				} else if (meprint.multitool_setting == MTB64_FURN_CHAIR_WOOD2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Chair-Wood2 Enetheru");
				} else if (meprint.multitool_setting == MTB64_FURN_BENCH_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Bench-Wood Enetheru");
				
				} else if (meprint.multitool_setting == MTB64_FURN_TABLE_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Table-Wood");
					
				} else if (meprint.multitool_setting == MTB64_FURN_TABLE_WOOD2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Table-Wood2 Enetheru");
				} else if (meprint.multitool_setting == MTB64_FURN_TABLE_WOOD3) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Table-Wood3 Enetheru");
				
				} else if (meprint.multitool_setting == MTB64_FURN_WORKBENCH) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-WorkBench");
				
				} else if (meprint.multitool_setting == MTB64_FURN_BLKSMHBELLOWS) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Blacksmith-Bellows");
				} else if (meprint.multitool_setting == MTB64_FURN_BLKSMHFORGE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Blacksmith-Forge");
				} else if (meprint.multitool_setting == MTB64_FURN_BLKSMHANVIL) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Blacksmith-Anvil");
				} else if (meprint.multitool_setting == MTB64_FURN_IRONMAIDEN) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-IronMaiden");	
				} else if (meprint.multitool_setting == MTB64_FURN_SPIKEDRACK) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-SpikedRack");	
				} else if (meprint.multitool_setting == MTB64_FURN_IMPALEMENTPOLE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-ImpalementPole");	
				} else if (meprint.multitool_setting == MTB64_FURN_IRONBRAZIER) {
					if (meprint.multitool_flamecolor == -10
					|| meprint.multitool_flamecolor >= 1) {
						myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-IronBrazier (MagicFlame)");	
					} else {
						myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-IronBrazier");	
					}
				} else if (meprint.multitool_setting == MTB64_FURN_GIBBET) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Gibbet");	
				} else if (meprint.multitool_setting == MTB64_FURN_BLKSMHGRNDSTN) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Blacksmith-Grindstone");
				
				} else if (meprint.multitool_setting == MTB64_FURN_BED_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Bed-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_EMPTYSHELF_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-EmptyShelves-Wood");
				} else if (meprint.multitool_setting == MTB64_FURN_BOOKSHELF_WOOD) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Bookshelf-Wood");
					
				} else if (meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY1) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Chair-Upholstered");
				} else if (meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY2) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-WingChair-Upholstered");
				} else if (meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY3) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-Chair-Poltroncina");
				} else if (meprint.multitool_setting == MTB64_FURN_CHAISELOUNGE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-ChaiseLounge");
				
				} else if (meprint.multitool_setting == MTB64_FURN_GREEKPILLAR) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-GreekPillar");
				} else if (meprint.multitool_setting == MTB64_FURN_GREEKPILLARM) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-GreekPillar-Marble");
				} else if (meprint.multitool_setting == MTB64_FURN_ROMANCOLUMN) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-RomanColumn");
				} else if (meprint.multitool_setting == MTB64_FURN_ROMANCOLUMNM) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Furniture-RomanColumn-Marble");
				
				} else if (meprint.multitool_setting == MTB64_CLAIMSTONE) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Block-64x64-ClaimStone");
					
				} else if (meprint.multitool_setting == -601) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden Planks Light");
				} else if (meprint.multitool_setting == -602) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden Planks Dark");
				} else if (meprint.multitool_setting == -603) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden Planks Brown");
				} else if (meprint.multitool_setting == -604) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden TightPlanks");
				} else if (meprint.multitool_setting == -605) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden Chequered");
				
				} else if (meprint.multitool_setting == -609) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Wooden Stakes");
				} else if (meprint.multitool_setting == -610) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Iron Spikes");
				
				} else if (meprint.multitool_setting == -615) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Trap Door");
					
				} else if (meprint.multitool_setting == -618) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Trap Grate");
				
				} else if (meprint.multitool_setting == -620) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Stone Tan");
					
				} else if (meprint.multitool_setting == -640) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled Black / White");
				} else if (meprint.multitool_setting == -641) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled Blue / Gray");
				} else if (meprint.multitool_setting == -642) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled Brown Chequered");
				} else if (meprint.multitool_setting == -643) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled E7 Cobble");
				} else if (meprint.multitool_setting == -644) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled E7 Cobble Red");
				} else if (meprint.multitool_setting == -645) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled E7 Cobble Yellow");
				} else if (meprint.multitool_setting == -646) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled Gray");
				} else if (meprint.multitool_setting == -647) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Tiled Green");
				
				} else if (meprint.multitool_setting == -670) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Black");
				} else if (meprint.multitool_setting == -671) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Dark");
				} else if (meprint.multitool_setting == -672) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Light2");
				} else if (meprint.multitool_setting == -673) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Mixed");
				} else if (meprint.multitool_setting == -674) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Olive");
				} else if (meprint.multitool_setting == -675) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Tan");
				} else if (meprint.multitool_setting == -676) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Travertine");
				} else if (meprint.multitool_setting == -677) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Travertine2");
				} else if (meprint.multitool_setting == -678) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Granite Light");
				
				} else if (meprint.multitool_setting == -700) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Black / Brown");
				} else if (meprint.multitool_setting == -701) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Black / White");
				} else if (meprint.multitool_setting == -702) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Chess Green / White");
				} else if (meprint.multitool_setting == -703) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Cyan / White");
				} else if (meprint.multitool_setting == -704) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble DBlue / White");
				} else if (meprint.multitool_setting == -705) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Gray (Solid)");
				} else if (meprint.multitool_setting == -706) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble GrecoWhite");
				} else if (meprint.multitool_setting == -707) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Green / Green");
				} else if (meprint.multitool_setting == -708) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Green / White 2");
				} else if (meprint.multitool_setting == -709) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Green / White 3");
				} else if (meprint.multitool_setting == -710) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Green / White");
				} else if (meprint.multitool_setting == -711) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble LBlue / White");
				} else if (meprint.multitool_setting == -712) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Nero (Solid)");
				} else if (meprint.multitool_setting == -713) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Pink / Red");
				} else if (meprint.multitool_setting == -714) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Pink / Tan");
				} else if (meprint.multitool_setting == -715) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Pink / White");
				} else if (meprint.multitool_setting == -716) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Purplle / White");
				} else if (meprint.multitool_setting == -717) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Red / Pink");
				} else if (meprint.multitool_setting == -718) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Red / White");
				} else if (meprint.multitool_setting == -719) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Tan / Brown");
				} else if (meprint.multitool_setting == -720) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Tan / Tan");
				} else if (meprint.multitool_setting == -721) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble White 2 (Solid)");
				} else if (meprint.multitool_setting == -722) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble White (Solid)");
				} else if (meprint.multitool_setting == -723) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble White / White 2");
				} else if (meprint.multitool_setting == -724) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble White / White");
				} else if (meprint.multitool_setting == -725) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Woodlike / Tan");
				} else if (meprint.multitool_setting == -726) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble Yellow / Brown");
				} else if (meprint.multitool_setting == -727) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble YGreen (Solid)");
				} else if (meprint.multitool_setting == -728) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble YGreen / Green");
				} else if (meprint.multitool_setting == -729) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble YGreen / White");
				} else if (meprint.multitool_setting == -730) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Marble YGren / YGreen");
					
				} else if (meprint.multitool_setting == -760) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble   RedWhiteGreen");
				} else if (meprint.multitool_setting == -761) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble O RedWhiteBlack");
				} else if (meprint.multitool_setting == -762) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble X RedWhite");
				} else if (meprint.multitool_setting == -763) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble   CyanLGreenGreen");
				} else if (meprint.multitool_setting == -764) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble O CyanLGreenBlack");
				} else if (meprint.multitool_setting == -765) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble X CyanLGreen");
				} else if (meprint.multitool_setting == -766) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble   BrownBlackGray");
				} else if (meprint.multitool_setting == -767) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble O BrownBlackGray ");
				} else if (meprint.multitool_setting == -768) {
					myreturna = multitool_hksprint(meprint, "Multi-Tool Setting: Floor Roman Marble X BrownBlack");
				
					
				} else {
					sprint(meprint, sprintf("Multi-Tool Setting: %f\n", meprint.multitool_setting));
				}
				
				if (multitool_isbuildingcurtainstone(meprint.multitool_setting))
				{
						//With these we only use mudbrick when castle color is set to tan or light tan
						//Otherwise we use the grey curtainwall brick
						if (meprint.multitool_castlecolor == 0) {
							sprint(meprint, "Castle Color:^x444  0 Dark^7\n");
						} else if (meprint.multitool_castlecolor == 1) {
							sprint(meprint, "Castle Color:^xA86  1 Tan^7\n");
						} else if (meprint.multitool_castlecolor == 2) {
							sprint(meprint, "Castle Color:^x444  2 White, Defaulting to: Dark^7\n");	
						} else if (meprint.multitool_castlecolor == 3) {
							sprint(meprint, "Castle Color:^x444  3 Green, Defaulting to: Dark\n");
						} else if (meprint.multitool_castlecolor == 4) {
							sprint(meprint, "Castle Color:^x444  4 Brown, Defaulting to: Dark\n");
						} else if (meprint.multitool_castlecolor == 5) {
							sprint(meprint, "Castle Color:^xA86  5 LightTan, Defaulting to: Tan\n");
						} else if (meprint.multitool_castlecolor == 6) {
							sprint(meprint, "Castle Color:^x444  6 Black, Defaulting to: Dark\n");
						} else if (meprint.multitool_castlecolor == 7) {
							sprint(meprint, "Castle Color:^x444  7 Mauve, Defaulting to: Dark\n");
						} else if (meprint.multitool_castlecolor == 8) {
							sprint(meprint, "Castle Color:^x444  8 Pink,  Defaulting to: Dark\n");
						} else {
							sprint(meprint, sprintf("Castle Color:^x555 %f ^7\n", meprint.multitool_castlecolor));
						
						}
				} else if ((multitool_isbuildingcastlestoneextra(meprint.multitool_setting))
				|| (meprint.multitool_setting == MTB64_CASTLESQUARE) 
				|| (meprint.multitool_setting >= MTB64_CASTLE && meprint.multitool_setting <= MTB64_CASTLELAST)
				|| (meprint.multitool_setting >= 570 && meprint.multitool_setting <= 579)
				|| (meprint.multitool_setting == 6) || (meprint.multitool_setting == 8)
				|| (meprint.multitool_setting == 7) || (meprint.multitool_setting == 10)
				|| (meprint.multitool_setting == 27)
				|| (meprint.multitool_setting >= 660 && meprint.multitool_setting <= 669)
				|| (meprint.multitool_setting >= 10700 && meprint.multitool_setting <= 10799))
				{
					
						if (meprint.multitool_castlecolor == 0) {
							sprint(meprint, "Castle Color:^x444  0 Dark^7\n");
						} else if (meprint.multitool_castlecolor == 1) {
							sprint(meprint, "Castle Color:^xA86  1 Tan^7\n");
						} else if (meprint.multitool_castlecolor == 2) {
							sprint(meprint, "Castle Color:^xFFF  2 White^7\n");	
						} else if (meprint.multitool_castlecolor == 3) {
							sprint(meprint, "Castle Color:^x4D4  3 Green\n");
						} else if (meprint.multitool_castlecolor == 4) {
							sprint(meprint, "Castle Color:^x550  4 Brown\n");
						} else if (meprint.multitool_castlecolor == 5) {
							sprint(meprint, "Castle Color:^xDCA  5 LightTan\n");
						} else if (meprint.multitool_castlecolor == 6) {
							sprint(meprint, "Castle Color:^x000  6 Black\n");
						} else if (meprint.multitool_castlecolor == 7) {
							sprint(meprint, "Castle Color:^x424  7 Mauve\n");
						} else if (meprint.multitool_castlecolor == 8) {
							sprint(meprint, "Castle Color:^xFAA  8 Pink\n");
						} else {
							sprint(meprint, sprintf("Castle Color:^x555 %f ^7\n", meprint.multitool_castlecolor));
						
						}
						
					if (meprint.multitool_setting == 616) {
						////Dome
						
						if (meprint.multitool_woodcolor == 1)
							sprint(meprint, "Wood Color:^x930  1 CopperBronze^7\n");
						else if (meprint.multitool_woodcolor == 2)
							sprint(meprint, "Wood Color:^x095  2 Cyan^7\n");
						//else if (meprint.multitool_woodcolor == 3)
						//	sprint(meprint, "Wood Color:^x090  3 Green^7\n");
						else if (meprint.multitool_woodcolor == 4)
							sprint(meprint, "Wood Color:^x900  4 Red^7\n");
						else if (meprint.multitool_woodcolor == 5)
							sprint(meprint, "Wood Color:^x009  5 Blue^7\n");
						else if (meprint.multitool_woodcolor == 6)
							sprint(meprint, "Wood Color:^xBBF  6 LightBlue^7\n");
						else if (meprint.multitool_woodcolor == 7)
							sprint(meprint, "Wood Color:^xA90  7 Brass^7\n");
						else if (meprint.multitool_woodcolor == 8)
							sprint(meprint, "Wood Color:^x111  8 Iron^7\n");
						//else if (meprint.multitool_woodcolor == 9)
						//	sprint(meprint, "Wood Color:^x909  9 Magenta^7\n");
						else if (meprint.multitool_woodcolor == 10)
							sprint(meprint, "Wood Color:^xFBB 10 LightRed^7\n");
						else if (meprint.multitool_woodcolor == 11)
							sprint(meprint, "Wood Color:^xAAA 11 Silver^7\n");
						else if (meprint.multitool_woodcolor == 12)
							sprint(meprint, "Wood Color:^xFF0 12 Gold^7\n");
						//else if (meprint.multitool_woodcolor == 13)
						//	sprint(meprint, "Wood Color:^x039 13 Blue3^7\n");
						else if (meprint.multitool_woodcolor == 14)
							sprint(meprint, "Wood Color:^xFA0 14 Copper^7\n");
						//else if (meprint.multitool_woodcolor == 15)
						//	sprint(meprint, "Wood Color:^x444 15 ^x440C^x404Y^x044C^x400L^x004E^7\n");
						else if (meprint.multitool_woodcolor == 16)
							sprint(meprint, "Wood Color:^xFFF 16 Platinum^7\n");
						//else if (meprint.multitool_woodcolor == 17)
						//	sprint(meprint, "Wood Color:^x111 17 Cycle2^7\n");
						else {
							sprint(meprint, sprintf("Wood Color:^x000 Tiles ^7\n"));
						
						}
					} 
				} else if (meprint.multitool_setting >= MTB64_SANDSTONE && meprint.multitool_setting <= MTB64_SANDSTONELAST)
				{
						if (meprint.multitool_sstonecolor == 0) {
							sprint(meprint, "SandStone Color:^xDCA  0 LightTan\n");
						} else if (meprint.multitool_sstonecolor == 1) {
							sprint(meprint, "SandStone Color:^xA86  1 Tan^7\n");
						} else if (meprint.multitool_sstonecolor == 2) {
							sprint(meprint, "SandStone Color:^x999  2 Gray^7\n");
						} else if (meprint.multitool_sstonecolor == 3) {
							sprint(meprint, "SandStone Color:^xAA0  3 Yellow\n");
						} else if (meprint.multitool_sstonecolor == 5) {
							sprint(meprint, "SandStone Color:^x111  4 Black^7\n");
						} else if (meprint.multitool_sstonecolor == 5) {
							sprint(meprint, "SandStone Color:^x006  5 BlueStone\n");
						} else {
							sprint(meprint, sprintf("SandStone Color:^x555 %f ^7\n", meprint.multitool_sstonecolor));
						
						}
				} else if (multitool_isbuildingmarbleextra(meprint.multitool_setting)
				|| (meprint.multitool_setting >= MTB64_MARBLEWHITE && meprint.multitool_setting <= MTB64_MARBLEWHITELAST))
				{
					
						if (meprint.multitool_marblecolor == 0) {
							sprint(meprint, "Marble Color:^xFFF  0 White^7\n");
						} else if (meprint.multitool_marblecolor == 1) {
							sprint(meprint, "Marble Color:^x000  1 Nero^7\n");
						} else if (meprint.multitool_marblecolor == 2) {
							sprint(meprint, "Marble Color:^x0D0  2 Green^7\n");
						} else if (meprint.multitool_marblecolor == 3) {
							sprint(meprint, "Marble Color:^xB00  3 Red^7\n");
						} else if (meprint.multitool_marblecolor == 4) {
							sprint(meprint, "Marble Color:^xFCC  4 VeinyTan^7\n");
						} else if (meprint.multitool_marblecolor == 5) {
							sprint(meprint, "Marble Color:^x0DD  5 Cyan^7\n");
						} else if (meprint.multitool_marblecolor == 6) {
							sprint(meprint, "Marble Color:^x999  6 Gray^7\n");
						} else if (meprint.multitool_marblecolor == 7) {
							sprint(meprint, "Marble Color:^x550  7 Brown^7\n");
						} else if (meprint.multitool_marblecolor == 8) {
							sprint(meprint, "Marble Color:^xAAF  8 LightBlue^7\n");
						} else if (meprint.multitool_marblecolor == 9) {
							sprint(meprint, "Marble Color:^x0F5  9 Jade^7\n");
						} else if (meprint.multitool_marblecolor == 10) {
							sprint(meprint, "Marble Color:^x6F5 10 Olive^7\n");
						} else if (meprint.multitool_marblecolor == 11) {
							sprint(meprint, "Marble Color:^xFF0 11 Yellow^7\n");
						} else if (meprint.multitool_marblecolor == 12) {
							sprint(meprint, "Marble Color:^xFCC 12 Pink^7\n");
						} else if (meprint.multitool_marblecolor == 13) {
							sprint(meprint, "Marble Color:^xFFF 13 SoftWhite^7\n");
						} else if (meprint.multitool_marblecolor == 14) {
							sprint(meprint, "Marble Color:^xAAA 14 SoftGray^7\n");
						} else if (meprint.multitool_marblecolor == 15) {
							sprint(meprint, "Marble Color:^xAF0 15 OnyxGreen^7\n");
						} else if (meprint.multitool_marblecolor == 16) {
							sprint(meprint, "Marble Color:^xFDD 16 Cream^7\n");
						} else if (meprint.multitool_marblecolor == 17) {
							sprint(meprint, "Marble Color:^xFED 17 LightPink^7\n");
						} else if (meprint.multitool_marblecolor == 18) {
							sprint(meprint, "Marble Color:^xA86 18 Tan^7\n");
						} else if (meprint.multitool_marblecolor == 19) {
							sprint(meprint, "Marble Color:^xA85 19 PacificTan^7\n");
						} else if (meprint.multitool_marblecolor == 20) {
							sprint(meprint, "Marble Color:^xA75 20 Peach^7\n");
						} else if (meprint.multitool_marblecolor == 21) {
							sprint(meprint, "Marble Color:^xAA9 21 MysticGray^7\n");
						} else if (meprint.multitool_marblecolor == 22) {
							sprint(meprint, "Marble Color:^xCC4 22 PetrifiedWood^7\n");
						} else {
							sprint(meprint, sprintf("Marble Color:^x555 %f ^7\n", meprint.multitool_marblecolor));
						
						}
				} else if ((meprint.multitool_setting >= MTB64_SHINGLES && meprint.multitool_setting <= MTB64_SHINGLESLAST)
				|| (meprint.multitool_setting >= MTB64_SHINGLES2 && meprint.multitool_setting <= MTB64_SHINGLES2LAST)
				|| meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY1
				|| meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY2
				|| meprint.multitool_setting == MTB64_FURN_CHAIR_FANCY3
				|| meprint.multitool_setting == MTB64_FURN_CHAISELOUNGE
				) {
					if (meprint.multitool_roofcolor == -10) {
						sprint(meprint, sprintf("Roof Color:^x555 %f PlayerColor^7\n", meprint.multitool_roofcolor));
					} else if (meprint.multitool_roofcolor) {
						////    0:  '1.000000 1.000000 1.000000';
						////    1:  '1.000000 0.333333 0.000000';
						////    2:  '0.000000 1.000000 0.501961';
						
						////    3:  '0.000000 1.000000 0.000000';
						////    4:  '1.000000 0.000000 0.000000';
						////    5:  '0.000000 0.666667 1.000000';
						
						////    6:  '0.000000 1.000000 1.000000';
						////    7:  '0.501961 1.000000 0.000000';
						////    8:  '0.501961 0.000000 1.000000';
						
						////    9:  '1.000000 0.000000 1.000000';
						////   10:  '1.000000 0.000000 0.501961';
						////   11:  '0.000000 0.000000 1.000000';
						
						////   12:  '1.000000 1.000000 0.000000';
						////   13:  '0.000000 0.333333 1.000000';
						////   14:  '1.000000 0.666667 0.000000';
						
						if (meprint.multitool_roofcolor == 1)
							sprint(meprint, "Roof Color:^x930  1 Orange^7\n");
						else if (meprint.multitool_roofcolor == 2)
							sprint(meprint, "Roof Color:^x095  2 Cyan^7\n");
						else if (meprint.multitool_roofcolor == 3)
							sprint(meprint, "Roof Color:^x090  3 Green^7\n");
						else if (meprint.multitool_roofcolor == 4)
							sprint(meprint, "Roof Color:^x900  4 Red^7\n");
						else if (meprint.multitool_roofcolor == 5)
							sprint(meprint, "Roof Color:^x069  5 Blue^7\n");
						else if (meprint.multitool_roofcolor == 6)
							sprint(meprint, "Roof Color:^x099  6 LightBlue^7\n");
						else if (meprint.multitool_roofcolor == 7)
							sprint(meprint, "Roof Color:^x590  7 Yellow^7\n");
						else if (meprint.multitool_roofcolor == 8)
							sprint(meprint, "Roof Color:^x509  8 Purple^7\n");
						else if (meprint.multitool_roofcolor == 9)
							sprint(meprint, "Roof Color:^x909  9 Magenta^7\n");
						else if (meprint.multitool_roofcolor == 10)
							sprint(meprint, "Roof Color:^x905 10 Rose^7\n");
						else if (meprint.multitool_roofcolor == 11)
							sprint(meprint, "Roof Color:^x009 11 Blue2^7\n");
						else if (meprint.multitool_roofcolor == 12)
							sprint(meprint, "Roof Color:^x990 12 Yellow2^7\n");
						else if (meprint.multitool_roofcolor == 13)
							sprint(meprint, "Roof Color:^x039 13 Blue3^7\n");
						else if (meprint.multitool_roofcolor == 14)
							sprint(meprint, "Roof Color:^x960 14 Orange2^7\n");
						else if (meprint.multitool_roofcolor == 15)
							sprint(meprint, "Roof Color:^x444 15 ^x440C^x404Y^x044C^x400L^x004E^7\n");
						else if (meprint.multitool_roofcolor == 16)
							sprint(meprint, "Roof Color:^xFFF 16 White^7\n");
						else if (meprint.multitool_roofcolor == 17)
							sprint(meprint, "Roof Color:^x111 17 Cycle2^7\n");
						else {
							sprint(meprint, sprintf("Roof Color:^x000 %f ^7\n", meprint.multitool_roofcolor));
						
						}
					} else {
						sprint(meprint, sprintf("Roof Color:^x000 %f N^x111o^x222n^x333e^7 (Default)\n", meprint.multitool_roofcolor));
					}
				} else if (meprint.multitool_setting == MTB64_FURN_IRONBRAZIER) {
					if (meprint.multitool_flamecolor == -10) {
						sprint(meprint, sprintf("Flame Color:^x555 %f PlayerColor^7\n", meprint.multitool_flamecolor));
					} else if (meprint.multitool_flamecolor) {
						////    0:  '1.000000 1.000000 1.000000';
						////    1:  '1.000000 0.333333 0.000000';
						////    2:  '0.000000 1.000000 0.501961';
						
						////    3:  '0.000000 1.000000 0.000000';
						////    4:  '1.000000 0.000000 0.000000';
						////    5:  '0.000000 0.666667 1.000000';
						
						////    6:  '0.000000 1.000000 1.000000';
						////    7:  '0.501961 1.000000 0.000000';
						////    8:  '0.501961 0.000000 1.000000';
						
						////    9:  '1.000000 0.000000 1.000000';
						////   10:  '1.000000 0.000000 0.501961';
						////   11:  '0.000000 0.000000 1.000000';
						
						////   12:  '1.000000 1.000000 0.000000';
						////   13:  '0.000000 0.333333 1.000000';
						////   14:  '1.000000 0.666667 0.000000';
						
						if (meprint.multitool_flamecolor == 1)
							sprint(meprint, "Flame Color:^x930  1 Orange^7\n");
						else if (meprint.multitool_flamecolor == 2)
							sprint(meprint, "Flame Color:^x095  2 Cyan^7\n");
						else if (meprint.multitool_flamecolor == 3)
							sprint(meprint, "Flame Color:^x090  3 Green^7\n");
						else if (meprint.multitool_flamecolor == 4)
							sprint(meprint, "Flame Color:^x900  4 Red^7\n");
						else if (meprint.multitool_flamecolor == 5)
							sprint(meprint, "Flame Color:^x069  5 Blue^7\n");
						else if (meprint.multitool_flamecolor == 6)
							sprint(meprint, "Flame Color:^x099  6 LightBlue^7\n");
						else if (meprint.multitool_flamecolor == 7)
							sprint(meprint, "Flame Color:^x590  7 Yellow^7\n");
						else if (meprint.multitool_flamecolor == 8)
							sprint(meprint, "Flame Color:^x509  8 Purple^7\n");
						else if (meprint.multitool_flamecolor == 9)
							sprint(meprint, "Flame Color:^x909  9 Magenta^7\n");
						else if (meprint.multitool_flamecolor == 10)
							sprint(meprint, "Flame Color:^x905 10 Rose^7\n");
						else if (meprint.multitool_flamecolor == 11)
							sprint(meprint, "Flame Color:^x009 11 Blue2^7\n");
						else if (meprint.multitool_flamecolor == 12)
							sprint(meprint, "Flame Color:^x990 12 Yellow2^7\n");
						else if (meprint.multitool_flamecolor == 13)
							sprint(meprint, "Flame Color:^x039 13 Blue3^7\n");
						else if (meprint.multitool_flamecolor == 14)
							sprint(meprint, "Flame Color:^x960 14 Orange2^7\n");
						else if (meprint.multitool_flamecolor == 15)
							sprint(meprint, "Flame Color:^x444 15 ^x440C^x404Y^x044C^x400L^x004E^7\n");
						else if (meprint.multitool_flamecolor == 16)
							sprint(meprint, "Flame Color:^xFFF 16 White^7\n");
						else if (meprint.multitool_flamecolor == 17)
							sprint(meprint, "Flame Color:^x111 17 Cycle2^7\n");
						else {
							sprint(meprint, sprintf("Flame Color:^x000 %f ^7\n", meprint.multitool_flamecolor));
						
						}
					} else {
						sprint(meprint, sprintf("Flame Color:^x000 %f Normal^7 (Default)\n", meprint.multitool_flamecolor));
					}
				} else if (meprint.multitool_setting >= MTB64_WOOD1 && meprint.multitool_setting <= MTB64_WOOD1LAST) {
					if (meprint.multitool_woodcolor == -10) {
						sprint(meprint, sprintf("Wood Color:^x555 %f PlayerColor^7\n", meprint.multitool_woodcolor));
					} else if (meprint.multitool_woodcolor) {
						////Same as above
						
						if (meprint.multitool_woodcolor == 1)
							sprint(meprint, "Wood Color:^x930  1 Orange^7\n");
						else if (meprint.multitool_woodcolor == 2)
							sprint(meprint, "Wood Color:^x095  2 Cyan^7\n");
						else if (meprint.multitool_woodcolor == 3)
							sprint(meprint, "Wood Color:^x090  3 Green^7\n");
						else if (meprint.multitool_woodcolor == 4)
							sprint(meprint, "Wood Color:^x900  4 Red^7\n");
						else if (meprint.multitool_woodcolor == 5)
							sprint(meprint, "Wood Color:^x069  5 Blue^7\n");
						else if (meprint.multitool_woodcolor == 6)
							sprint(meprint, "Wood Color:^x099  6 LightBlue^7\n");
						else if (meprint.multitool_woodcolor == 7)
							sprint(meprint, "Wood Color:^x590  7 Yellow^7\n");
						else if (meprint.multitool_woodcolor == 8)
							sprint(meprint, "Wood Color:^x509  8 Purple^7\n");
						else if (meprint.multitool_woodcolor == 9)
							sprint(meprint, "Wood Color:^x909  9 Magenta^7\n");
						else if (meprint.multitool_woodcolor == 10)
							sprint(meprint, "Wood Color:^x905 10 Rose^7\n");
						else if (meprint.multitool_woodcolor == 11)
							sprint(meprint, "Wood Color:^x009 11 Blue2^7\n");
						else if (meprint.multitool_woodcolor == 12)
							sprint(meprint, "Wood Color:^x990 12 Yellow2^7\n");
						else if (meprint.multitool_woodcolor == 13)
							sprint(meprint, "Wood Color:^x039 13 Blue3^7\n");
						else if (meprint.multitool_woodcolor == 14)
							sprint(meprint, "Wood Color:^x960 14 Orange2^7\n");
						else if (meprint.multitool_woodcolor == 15)
							sprint(meprint, "Wood Color:^x444 15 ^x440C^x404Y^x044C^x400L^x004E^7\n");
						else if (meprint.multitool_woodcolor == 16)
							sprint(meprint, "Wood Color:^xFFF 16 White^7\n");
						else if (meprint.multitool_woodcolor == 17)
							sprint(meprint, "Wood Color:^x111 17 Cycle2^7\n");
						else {
							sprint(meprint, sprintf("Wood Color:^x000 %f ^7\n", meprint.multitool_woodcolor));
						
						}
					} else {
						sprint(meprint, sprintf("Wood Color:^x000 %f N^x111o^x222n^x333e^7 (Default)\n", meprint.multitool_woodcolor));
					}
				}
				
				
				if (pmtdosounds == 1) {
					if(pmtsetting < meprint.multitool_setting) {
						spamsound (meprint, CH_SHOTS, "misc/decreasevalue.wav", VOL_BASE * 0.50, ATTN_NORM); //Not 0.25: Heavier Firing Pin
					} else if(pmtsetting > meprint.multitool_setting) {
						spamsound (meprint, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.50, ATTN_NORM); //Not 0.25: Heavier Firing Pin
					}	
				}
				
				return myreturna;
}

float w_multitool(float req)
{
	float ammo_amount;
	if (req == WR_AIM) {
		if (W_MultiTool_NeedManualReload()) { weapon_action(self.weapon, WR_RELOAD); } // bot reload if automatic reload off

		if (self.multitool_jammed) {
			 weapon_action(self.weapon, WR_RELOAD);
		}

		if(vlen(self.origin-self.enemy.origin) < 3000 - bound(0, skill, 10) * 200)
			self.BUTTON_ATCK = bot_aim(1000000, 0, 0.001, FALSE);
		else
		{
			self.BUTTON_ATCK2 = bot_aim(1000000, 0, 0.001, FALSE);
		}
	}
	else if (req == WR_THINK && !W_MultiTool_NeedManualReload())
	{
		if(autocvar_g_balance_multitool_reload_ammo && self.clip_load < autocvar_g_balance_multitool_ammo) // forced reload
			weapon_action(self.weapon, WR_RELOAD);		
		else
		{
			if((self.multitool_setting > 1000)
			&& !(self.multitool_setting >= 10000 && self.multitool_setting < 20000))
				self.multitool_setting = self.multitool_setting_saved;
				
			if(self.multitool_setting == 0) {
				if (self.BUTTON_ATCK)
				if (self.multitool_release)
				if (weapon_prepareattack(1, autocvar_g_balance_multitool_primary_refire))
				{
					// attempt forcing playback of the anim by switching to another anim (that we never play) here...
					weapon_thinkf(WFRAME_FIRE1, 0, W_MultiTool_Attack);
					self.multitool_release = 0;
				}
			} else {
				if (self.BUTTON_ATCK)
				if (self.multitool_jammed != 1)
				if (self.multitool_release)
				if (weapon_prepareattack(0, 0))
				{
					self.multitool_only_lastset = self.multitool_setting;
					self.misc_bulletcounter = 0;
					
					local float qstnnobuild;
					local float umbt;
					local float oldmtbt;
					qstnnobuild = 0;
					umbt = 0;
					if (!self.multitool_blocktype) {
						//We are going to do a move worldonly trace.
						//If there is something like a placed mountain etc
						//maybe we have set it to automatically be buildable upon
						//regardless of what the player has configured for his multitool blocktype
						//If so we should do the move normal trace in abit so
						//we can build on said model.
						if (multitool_testfor_isautoblocktypemultitool(self)) {
							umbt = 1;
							self.multitool_blocktype = 1;
						}
					}
					
						
					//Let's make sure something like a shield isn't what
					//we are trying to build upon
					if (multitool_testfor_isquestionableblocktypemultitool(self)) {
							qstnnobuild = 1;
							if ((clienttype(self) == CLIENTTYPE_REAL)) {
								sprint(self, "cannot build there (questionable surface below)\n");
							}
					}
					
					
					if (qstnnobuild) {
						//Do nothing much
						w_ready();
					} else {
						//Do it!
						multitool_fire_auto();
					}
					
					
					if (umbt) {
						self.multitool_blocktype = oldmtbt;
					}
					
					self.multitool_release = 0;
				}
			}
			
			if (self.BUTTON_ATCK2)
			if (self.multitool_jammed != 1)
			if (self.multitool_release)
			//if (weapon_prepareattack(1, 0))
			{
				if(self.BUTTON_USE || self.BUTTON_HOOK) {
					multitool_setzsnap(self);
				} else if(self.BUTTON_CROUCH) {
					if (self.multitool_setting < -767)
						self.multitool_setting = MTB64LAST; //Around 810 or so (loop around) (greatest num)
					else if (self.multitool_setting == -730)
						self.multitool_setting = -760;
					else if (self.multitool_setting == -678)
						self.multitool_setting = -700;
					else if (self.multitool_setting == -647)
						self.multitool_setting = -670;
					else if (self.multitool_setting == -620)
						self.multitool_setting = -640;
					else if (self.multitool_setting == -618)
						self.multitool_setting = -620;
					else if (self.multitool_setting == -615)
						self.multitool_setting = -618;
					else if (self.multitool_setting == -610)
						self.multitool_setting = -615;
					else if (self.multitool_setting == -605)
						self.multitool_setting = -609;
					else if (self.multitool_setting == -5)
						self.multitool_setting = -601;
					else if (self.multitool_setting == 110)
						self.multitool_setting = 27;
					else if (self.multitool_setting == 501)
						if (autocvar_g_balance_multitool_ancientonly) {
							self.multitool_setting = 110;
						} else {
							self.multitool_setting = 112;
						}
					else if (self.multitool_setting == 520)
						self.multitool_setting = 503;
					else if (self.multitool_setting == 530)
						self.multitool_setting = 523;
					else if (self.multitool_setting == 540)
						self.multitool_setting = 533;
					else if (self.multitool_setting == 550)
						self.multitool_setting = 546;
					else if (self.multitool_setting == 560)
						self.multitool_setting = 551;
					else if (self.multitool_setting == 570)
						self.multitool_setting = 569; //Filled up (569 to 570) so jump not really needed here anymore
					else if (self.multitool_setting == 10700)
						self.multitool_setting = 579;
					else if (self.multitool_setting == 580)
						self.multitool_setting = 10710;
					else if (self.multitool_setting == 630)
						self.multitool_setting = 616;
					else if (self.multitool_setting == 616)
						self.multitool_setting = 612;
					else if (self.multitool_setting == 610)
						self.multitool_setting = 588;
					else if (self.multitool_setting == 645)
						self.multitool_setting = 633;
					else if (self.multitool_setting == 650)
						self.multitool_setting = 646;
					else if (self.multitool_setting == 660)
						self.multitool_setting = 652;
					else if (self.multitool_setting == 670)
						self.multitool_setting = 664;
					else if (self.multitool_setting == MTB64FIRST) //Around 710
						self.multitool_setting = 672;
					else
						self.multitool_setting = self.multitool_setting - 1;
						
					
					//Skip if cannot use
					if (self.multitool_setting == MTB64_BWIRE) {
						if(autocvar_g_balance_multitool_ancientonly) {
							self.multitool_setting = self.multitool_setting - 1;	
						}
					}
						
					if (self.multitool_setting == MTB64_CLAIMSTONE) {
						if not(autocvar_g_balance_multitool_claimstones)
						{
							self.multitool_setting = self.multitool_setting - 1;
						}
					}
						
					spamsound (self, CH_SHOTS, "misc/decreasevalue.wav", VOL_BASE * 0.35, ATTN_NORM); //Not 0.25: Heavier Firing Pin
				} else {
					if((self.multitool_setting > (MTB64LAST - 1))
					&& !(self.multitool_setting >= 10000 && self.multitool_setting < 20000))
						 //Around 810 or so, Loop around if at highest num or greater (but is a > compare so -1 in this case)
						 //And not in special area for more castle walls
							self.multitool_setting = -768;
					else if (self.multitool_setting == -760)
							//Jump point
							self.multitool_setting = -730;
					else if (self.multitool_setting == -700)
							//Jump point
							self.multitool_setting = -678;
					else if (self.multitool_setting == -670)
							//Jump point
							self.multitool_setting = -647;
					else if (self.multitool_setting == -640)
							//Jump point
							self.multitool_setting = -620;
					else if (self.multitool_setting == -620)
							//Jump point
							self.multitool_setting = -618;
					else if (self.multitool_setting == -618)
							//Jump point
							self.multitool_setting = -615;
					else if (self.multitool_setting == -615)
							//Jump point
							self.multitool_setting = -610;
					else if (self.multitool_setting == -609)
							//Jump point
							self.multitool_setting = -605;
					else if (self.multitool_setting == -601)
							//Jump point
							self.multitool_setting = -5;
					else if (self.multitool_setting == 27)
							//Jump point
							self.multitool_setting = 110;
					else if (self.multitool_setting == 112
					|| (autocvar_g_balance_multitool_ancientonly && self.multitool_setting == 110))
							//Jump point
							self.multitool_setting = 501;
					else if (self.multitool_setting == 503)
							//Jump point
							self.multitool_setting = 520;		
					else if (self.multitool_setting == 523)
							//Jump point
							self.multitool_setting = 530;
					else if (self.multitool_setting == 533)
							//Jump point
							self.multitool_setting = 540;
					else if (self.multitool_setting == 546)
							//Jump point
							self.multitool_setting = 550;
					else if (self.multitool_setting == 551)
							//Jump point
							self.multitool_setting = 560;
					else if (self.multitool_setting == 569)
							//Jump point
							self.multitool_setting = 570;  //Filled up (569 to 570) so jump not really needed here anymore
					else if (self.multitool_setting == 579)
							//Jump point
							self.multitool_setting = 10700;
					else if (self.multitool_setting == 10710)
							//Jump point
							self.multitool_setting = 580;
					else if (self.multitool_setting == 588)
							//Jump point
							self.multitool_setting = 610;
					else if (self.multitool_setting == 612)
							//Jump point
							self.multitool_setting = 616;
					else if (self.multitool_setting == 616)
							//Jump point
							self.multitool_setting = 630;
					else if (self.multitool_setting == 633)
							//Jump point
							self.multitool_setting = 645;
					else if (self.multitool_setting == 646)
							//Jump point
							self.multitool_setting = 650;
					else if (self.multitool_setting == 652)
							//Jump point
							self.multitool_setting = 660;
					else if (self.multitool_setting == 664)
							//Jump point
							self.multitool_setting = 670;
					else if (self.multitool_setting == 672)
							//Jump point
							self.multitool_setting = MTB64FIRST; //Around 710
					else
						self.multitool_setting = self.multitool_setting + 1;
					
					//Skip if cannot use
					if (self.multitool_setting == MTB64_BWIRE) {
						if(autocvar_g_balance_multitool_ancientonly) {
							self.multitool_setting = self.multitool_setting + 1;	
						}
					}	
					
					if (self.multitool_setting == MTB64_CLAIMSTONE) {
						if not(autocvar_g_balance_multitool_claimstones)
						{
							self.multitool_setting = -768; //As above
						}
					}
					
					spamsound (self, CH_SHOTS, "misc/increasevalue.wav", VOL_BASE * 0.35, ATTN_NORM); //Not 0.25: Heavier Firing Pin
				}
				self.multitool_only_lastset = self.multitool_setting;
				
				self.multitool_setting_saved = self.multitool_setting;
				
				local float mya;
				mya = multitool_setting_print(self, 0, 0);
				
				//Some code for rapidly scrolling through selections if secondary is pushed down for abit
				//and very rapidly through unbuildable selections for lack of requisite skill
				if (autocvar_g_balance_multitool_rapidscroll) {
					if (self.multitool_setting == 0 || self.BUTTON_ATCK) {
						//If we're pressing the other button we stop too
						//If we're at melee we stop
						self.multitool_release = 0;
						self.multitool_rapidscrollpressed = 0;
						self.multitool_didntknowlastselection = 0;
					} else if (mya) {
						//If we can build it we stop... maybe
						if (self.multitool_didntknowlastselection) {
							//We stop: Didn't know last selection, know this one though
							self.multitool_release = 0;
							//self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed - frametime;
							self.multitool_rapidscrollpressed = 0;
						} else if (self.multitool_rapidscrollpressed < autocvar_g_balance_multitool_rapidscroll_wait) {
							self.multitool_release = 0;
							
							//Will build up the ramp down time abit (so if you momentarially let go of the button
							//you will not have to hold it down again for the wait time unless you let go
							//for longer
							self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed + frametime;
							
						} else if (time > self.multitool_rapidscrollnext) {
							self.multitool_release = 1; //rapidscroll
							self.multitool_rapidscrollnext = time + autocvar_g_balance_multitool_rapidscroll_rate;
						} else {
							self.multitool_release = 0;
						}
						self.multitool_didntknowlastselection = 0;
					} else {
						//Don't know how to build
						self.multitool_didntknowlastselection = 1;
						if (self.multitool_rapidscrollpressed < autocvar_g_balance_multitool_rapidscroll_nobld_wait) {
							self.multitool_release = 0;
							//Will build up the ramp down time abit (so if you momentarially let go of the button
							//you will not have to hold it down again for the wait time unless you let go
							//for longer
							self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed + frametime;
						} else if (time > self.multitool_rapidscrollnobldnext) {
							self.multitool_release = 1; //rapidscroll
							self.multitool_rapidscrollnobldnext = time + autocvar_g_balance_multitool_rapidscroll_nobld_rate;
						} else {
							self.multitool_release = 0;
						}
					}
				} else {
					//Otherwise no rapid scrolling, simple
					self.multitool_release = 0;
				}
			} else if (autocvar_g_balance_multitool_rapidscroll && self.BUTTON_ATCK2) {
				//Didnt make it to above block, but Just pressing it...
				if not(self.BUTTON_ATCK) {
					if (self.multitool_didntknowlastselection) {
						if (self.multitool_rapidscrollpressed < autocvar_g_balance_multitool_rapidscroll_nobld_wait) {
							self.multitool_release = 0;
							//Will build up the ramp down time abit (so if you momentarially let go of the button
							//you will not have to hold it down again for the wait time unless you let go
							//for longer
							self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed + frametime;
						} else if (time > self.multitool_rapidscrollnobldnext) {
							self.multitool_release = 1; //rapidscroll
							self.multitool_rapidscrollnobldnext = time + autocvar_g_balance_multitool_rapidscroll_nobld_rate;
						} else {
							self.multitool_release = 0;
						}
					} else if (self.multitool_rapidscrollpressed < autocvar_g_balance_multitool_rapidscroll_wait) {
						//Do nothing
						
						//Will build up the ramp down time abit (so if you momentarially let go of the button
						//you will not have to hold it down again for the wait time unless you let go
						//for longer
						self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed + frametime;
					} else {
						if (time > self.multitool_rapidscrollnext) {
							self.multitool_release = 1; //rapidscroll
							self.multitool_rapidscrollnext = time + autocvar_g_balance_multitool_rapidscroll_rate;
						} else {
							self.multitool_release = 0;
						}
					}
				}
			}
			
			if not(self.BUTTON_ATCK)
			if not(self.BUTTON_ATCK2) {
				self.multitool_release = 1;
				if (autocvar_g_balance_multitool_rapidscroll && self.multitool_rapidscrollpressed > 0) {
					//Not pressing anything, decrease the "rampup" till zero, where the wait time for rapidscroll will kick in again
					self.multitool_rapidscrollpressed = self.multitool_rapidscrollpressed - frametime;
				}
			}
		}
		
		if (self.multitoollight) {
			if (self.multitool_lit) {
				if (self.multitool_setting == 0) {
					self.multitool_lit = 0;
				} else {
					self.multitoollight.multitool_lit = 1;
				}
			} else if (self.multitool_setting != 0) {
				self.multitool_lit = 1;
				//print("multilight onX2\n");
			}
		} else if (self.multitool_setting != 0) {
				self.multitool_lit = 1;
				multitool_spawnlight();
				//print("multilight on\n");
		}
	}
	else if (req == WR_PRECACHE)
	{
		precache_model ("models/uziflash.md3");
		precache_model ("models/weapons/g_multitool.md3");
		precache_model ("models/weapons/v_multitool.md3");
		precache_model ("models/weapons/h_multitool.iqm");
		precache_model ("models/misc/penant.iqm");
		
		//Precache Some Buildings Before They are Built
		if (autocvar_g_balance_multitoolutilitool_jitprecacheonly <= 0) {
		precache_model ("maps/buildables/building_turrettower_mg.bsp");
                precache_model ("maps/buildables/building_turrettower_plasma.bsp");
                precache_model ("maps/buildables/building_turrettower_mlrs.bsp");
		precache_model ("maps/buildables/building_turrettower_hellion.bsp");
                precache_model ("maps/buildables/building_garrison.bsp");
                precache_model ("maps/buildables/building_church.bsp");
		precache_model ("maps/buildables/building_townhall.bsp");
		precache_model ("maps/buildables/building_nippon_house.bsp");
		precache_model ("maps/buildables/building_nippon_shrine.bsp");
		precache_model ("maps/buildables/building_nippon_dojo.bsp");
                precache_model ("maps/buildables/building_stronghold.bsp");
                precache_model ("maps/buildables/building_strongtower.bsp");
                precache_model ("maps/buildables/building_sniperspire.bsp");
		precache_model ("maps/buildables/building_gmanse.bsp");
		precache_model ("maps/buildables/building_arsenal.bsp");
		precache_model ("maps/buildables/building_barracks.bsp");
		precache_model ("maps/buildables/building_oldhangar.bsp");
		precache_model ("maps/buildables/building_oldtankhangar.bsp");
		precache_model ("maps/buildables/building_chataeu.bsp");
		precache_model ("maps/buildables/building_palladianmanor.bsp");
		precache_model ("maps/buildables/building_barley.bsp");
		precache_model ("maps/buildables/building_kelp.bsp");
		precache_model ("maps/buildables/building_vineyard.bsp");
		precache_model ("maps/buildables/building_stonehouse.bsp");
		precache_model ("maps/buildables/building_treetopsentry.bsp");
		precache_model ("maps/buildables/building_siegeworkshop.bsp");
		precache_model ("maps/buildables/building_gaol.bsp");
		precache_model ("maps/buildables/building_smalljail.bsp");
		precache_model ("maps/buildables/building_forge1.bsp");
		precache_model ("maps/buildables/building_forge2.bsp");
		precache_model ("maps/buildables/building_forge3.bsp");
		precache_model ("maps/buildables/building_forge1_lock.bsp");
		precache_model ("maps/buildables/building_forge2_lock.bsp");
		precache_model ("maps/buildables/building_forge3_lock.bsp");
		precache_model ("maps/buildables/building_belltower.bsp");
		
		precache_model ("maps/buildables/block_64_window_woodbar.bsp");
		precache_model ("maps/buildables/block_64_window_ironbar.bsp");
		
		precache_model ("maps/buildables/foundation_wall.bsp");
		precache_model ("maps/buildables/foundation_tower.bsp");
		precache_model ("maps/buildables/foundation_tower_round.bsp");
		precache_model ("maps/buildables/foundation_bridge.bsp");
		precache_model ("maps/buildables/wall_berm.bsp");
		precache_model ("maps/buildables/wall_berm_tower.bsp");
		precache_model ("maps/buildables/wall_curtain.bsp");
		precache_model ("maps/buildables/wall_curtain_tower.bsp");
		precache_model ("maps/buildables/wall_curtain_tower_round.bsp");
		precache_model ("maps/buildables/wall_curtain_door.bsp");
		precache_model ("maps/buildables/wall_curtain_gate_large.bsp");
		precache_model ("maps/buildables/wall_curtain_fill.bsp");
		precache_model ("maps/buildables/wall_curtain_fill_stairs.bsp");
		precache_model ("maps/buildables/wall_curtain_interior.bsp");
		precache_model ("maps/buildables/wall_curtain_interior_door.bsp");
		precache_model ("maps/buildables/wall_castle.bsp");
		precache_model ("maps/buildables/wall_castle_tower.bsp");
		precache_model ("maps/buildables/wall_castle_tower_round.bsp");
		precache_model ("maps/buildables/wall_castle_door.bsp");
		precache_model ("maps/buildables/wall_castle_gate_large.bsp");
		precache_model ("maps/buildables/wall_castle_fill.bsp");
		precache_model ("maps/buildables/wall_castle_fill_stairs.bsp");
		precache_model ("maps/buildables/wall_castle_interior.bsp");
		precache_model ("maps/buildables/wall_castle_interior_door.bsp");
		//precache_model ("maps/buildables/wall_castle_interior_door_two.bsp");
		//precache_model ("maps/buildables/wall_castle_interior_door_side.bsp");
		//precache_model ("maps/buildables/wall_castle_interior_window.bsp");
		precache_model ("maps/buildables/vault_castle.bsp");
		precache_model ("maps/buildables/vault_castle_starchamber.bsp");
		precache_model ("maps/buildables/vault_polish.bsp");
		precache_model ("maps/buildables/vault_wings_castle.bsp");
		precache_model ("maps/buildables/vault_wings_polish.bsp");
		precache_model ("maps/buildables/vault_roof_copper.bsp");
		precache_model ("maps/buildables/vault_roof_copper_end.bsp");
		precache_model ("maps/buildables/vault_roof_copper_one.bsp");
		precache_model ("maps/buildables/wall_polish.bsp");
		precache_model ("maps/buildables/wall_polish_tower.bsp");
		precache_model ("maps/buildables/wall_polish_door.bsp");
		precache_model ("maps/buildables/wall_polish_gate_large.bsp");
		precache_model ("maps/buildables/wall_polish_fill.bsp");
		precache_model ("maps/buildables/wall_polish_fill_stairs.bsp");
		precache_model ("maps/buildables/wall_polish_interior.bsp");
		precache_model ("maps/buildables/wall_polish_interior_door.bsp");
		precache_model ("maps/buildables/wall_hedge.bsp");
		precache_model ("maps/buildables/wall_hedge_tower.bsp");
		precache_model ("maps/buildables/wall_hedge_tower_round.bsp");
		precache_model ("maps/buildables/wall_hedge_door.bsp");
		precache_model ("maps/buildables/wall_brick.bsp");
		precache_model ("maps/buildables/wall_brick_tower.bsp");
		precache_model ("maps/buildables/wall_brick_tower_round.bsp");
		precache_model ("maps/buildables/wall_brick_door.bsp");
		precache_model ("maps/buildables/wall_palisade.bsp");
		precache_model ("maps/buildables/wall_palisade_tower.bsp");
		precache_model ("maps/buildables/wall_palisade_gate.bsp");
		precache_model ("maps/buildables/wall_palisade_gate_large.bsp");
		precache_model ("maps/buildables/wall_palisade_woodwall.bsp");
		precache_model ("maps/buildables/wall_palisade_woodwall_tower.bsp");
		precache_model ("maps/buildables/wall_palisade_woodwall_gate.bsp");
		precache_model ("maps/buildables/block_64_shingles.bsp");
		precache_model ("maps/buildables/block_64_shingles_casing.bsp");
		precache_model ("maps/buildables/block_64_shingles_casingside.bsp");
		precache_model ("maps/buildables/block_64_shingles_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_shingles_corner.bsp");
		precache_model ("maps/buildables/block_64_shingles_stairs.bsp");
		precache_model ("maps/buildables/block_64_shingles_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_shingles_casinginside.bsp");
		precache_model ("maps/buildables/block_64_shingles_octoside.bsp");
		precache_model ("maps/buildables/block_64_shingles_octoside2.bsp");
		precache_model ("maps/buildables/block_64_shingles_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_shingles_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_shingles2.bsp");
		precache_model ("maps/buildables/block_64_shingles2_casing.bsp");
		precache_model ("maps/buildables/block_64_shingles2_casingside.bsp");
		precache_model ("maps/buildables/block_64_shingles2_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_shingles2_corner.bsp");
		precache_model ("maps/buildables/block_64_shingles2_stairs.bsp");
		precache_model ("maps/buildables/block_64_shingles2_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_shingles2_casinginside.bsp");
		precache_model ("maps/buildables/block_64_shingles2_octoside.bsp");
		precache_model ("maps/buildables/block_64_shingles2_octoside2.bsp");
		precache_model ("maps/buildables/block_64_shingles2_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_shingles2_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_wood1.bsp");
		precache_model ("maps/buildables/block_64_wood1_casing.bsp");
		precache_model ("maps/buildables/block_64_wood1_casingside.bsp");
		precache_model ("maps/buildables/block_64_wood1_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_wood1_corner.bsp");
		precache_model ("maps/buildables/block_64_wood1_stairs.bsp");
		precache_model ("maps/buildables/block_64_wood1_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_wood1_casinginside.bsp");
		precache_model ("maps/buildables/block_64_wood1_octoside.bsp");
		precache_model ("maps/buildables/block_64_wood1_octoside2.bsp");
		precache_model ("maps/buildables/block_64_wood1_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_wood1_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_wood2.bsp");
		precache_model ("maps/buildables/block_64_wood2_casing.bsp");
		precache_model ("maps/buildables/block_64_wood2_casingside.bsp");
		precache_model ("maps/buildables/block_64_wood2_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_wood2_corner.bsp");
		precache_model ("maps/buildables/block_64_wood2_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_wood2_stairs.bsp");
		precache_model ("maps/buildables/block_64_wood2_casinginside.bsp");
		precache_model ("maps/buildables/block_64_wood2_octoside.bsp");
		precache_model ("maps/buildables/block_64_wood2_octoside2.bsp");
		precache_model ("maps/buildables/block_64_wood2_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_wood2_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_wood2_stairs_cheap.bsp");
		precache_model ("maps/buildables/block_64_curtain.bsp");
		precache_model ("maps/buildables/block_64_curtain_casing.bsp");
		precache_model ("maps/buildables/block_64_curtain_casingside.bsp");
		precache_model ("maps/buildables/block_64_curtain_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_curtain_corner.bsp");
		precache_model ("maps/buildables/block_64_curtain_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_curtain_stairs.bsp");
		precache_model ("maps/buildables/block_64_curtain_casinginside.bsp");
		precache_model ("maps/buildables/block_64_curtain_octoside.bsp");
		precache_model ("maps/buildables/block_64_curtain_octoside2.bsp");
		precache_model ("maps/buildables/block_64_curtain_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_curtain_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_castle.bsp");
		precache_model ("maps/buildables/block_64_castle_casing.bsp");
		precache_model ("maps/buildables/block_64_castle_casingside.bsp");
		precache_model ("maps/buildables/block_64_castle_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_castle_corner.bsp");
		precache_model ("maps/buildables/block_64_castle_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_castle_stairs.bsp");
		precache_model ("maps/buildables/block_64_castle_casinginside.bsp");
		precache_model ("maps/buildables/block_64_castle_octoside.bsp");
		precache_model ("maps/buildables/block_64_castle_octoside2.bsp");
		precache_model ("maps/buildables/block_64_castle_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_castle_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_polish.bsp");
		precache_model ("maps/buildables/block_64_polish_casing.bsp");
		precache_model ("maps/buildables/block_64_polish_casingside.bsp");
		precache_model ("maps/buildables/block_64_polish_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_polish_corner.bsp");
		precache_model ("maps/buildables/block_64_polish_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_polish_stairs.bsp");
		precache_model ("maps/buildables/block_64_polish_casinginside.bsp");
		precache_model ("maps/buildables/block_64_polish_octoside.bsp");
		precache_model ("maps/buildables/block_64_polish_octoside2.bsp");
		precache_model ("maps/buildables/block_64_polish_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_polish_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_graycastle.bsp");
		precache_model ("maps/buildables/block_64_graycastle_casing.bsp");
		precache_model ("maps/buildables/block_64_graycastle_casingside.bsp");
		precache_model ("maps/buildables/block_64_graycastle_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_graycastle_corner.bsp");
		precache_model ("maps/buildables/block_64_graycastle_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_graycastle_stairs.bsp");
		precache_model ("maps/buildables/block_64_graycastle_casinginside.bsp");
		precache_model ("maps/buildables/block_64_graycastle_octoside.bsp");
		precache_model ("maps/buildables/block_64_graycastle_octoside2.bsp");
		precache_model ("maps/buildables/block_64_graycastle_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_graycastle_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_sandstonedark.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_casing.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_casingside.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_corner.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_stairs.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_casinginside.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_octoside.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_octoside2.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_sandstonelight_stairs_inside.bsp");
		
		precache_model ("maps/buildables/block_64_marblewhite.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_casing.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_casinginside.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_casingside.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_corner.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_octoside2.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_octoside.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner_f_bottom.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner_f.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner_f_solid.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner_f_top.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_roundcorner_p.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_stairs.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_recessedcorner.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_recessedcorner_f_bottom.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_recessedcorner_f.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_recessedcorner_f_top.bsp");
		precache_model ("maps/buildables/block_64_marblewhite_squarecorner_p.bsp");
		
		precache_model ("maps/buildables/block_64_castlesquare.bsp");
		precache_model ("maps/buildables/block_64_hedge.bsp");
		precache_model ("maps/buildables/block_64_hedge_casing.bsp");
		precache_model ("maps/buildables/block_64_hedge_casingside.bsp");
		precache_model ("maps/buildables/block_64_hedge_pyramidion.bsp");
		precache_model ("maps/buildables/block_64_hedge_corner.bsp");
		precache_model ("maps/buildables/block_64_hedge_roundcorner.bsp");
		precache_model ("maps/buildables/block_64_hedge_stairs.bsp");
		precache_model ("maps/buildables/block_64_hedge_casinginside.bsp");
		precache_model ("maps/buildables/block_64_hedge_octoside.bsp");
		precache_model ("maps/buildables/block_64_hedge_octoside2.bsp");
		precache_model ("maps/buildables/block_64_hedge_stairs_side.bsp");
		precache_model ("maps/buildables/block_64_hedge_stairs_inside.bsp");
		precache_model ("maps/buildables/block_64_filled.bsp");
		precache_model ("maps/buildables/block_64_filled_casing.bsp");
		precache_model ("maps/buildables/block_64_filled_corner.bsp");
		precache_model ("maps/buildables/block_64_filled_d.bsp");
		precache_model ("maps/buildables/block_64_filled_x.bsp");
		precache_model ("maps/buildables/block_64_filled_i.bsp");
		precache_model ("maps/buildables/bridge_wood.bsp");
		precache_model ("maps/buildables/bridge_wood_wide.bsp");
		precache_model ("maps/buildables/bridge_curtain.bsp");
		precache_model ("maps/buildables/bridge_curtain_c.bsp");
		precache_model ("maps/buildables/bridge_curtain_landing.bsp");
		precache_model ("maps/buildables/bridge_castle.bsp");
		precache_model ("maps/buildables/bridge_castle_c.bsp");
		precache_model ("maps/buildables/bridge_castle_fort.bsp");
		precache_model ("maps/buildables/bridge_castle_fortc.bsp");
		precache_model ("maps/buildables/bridge_castle_landing.bsp");
		precache_model ("maps/buildables/bridge_polish.bsp");
		precache_model ("maps/buildables/bridge_polish_c.bsp");
		precache_model ("maps/buildables/bridge_polish_landing.bsp");
		
		}
		
		//Precache Scaffolds and Rubble etc
		if (autocvar_g_balance_multitoolutilitool_jitprecacheonly <= 1) {
		precache_model ("maps/buildables/scaffold_treetopsentry.bsp");
		precache_model ("maps/buildables/scaffold_stronghold.bsp");
		precache_model ("maps/buildables/scaffold_smallcastle.bsp");
		precache_model ("maps/buildables/scaffold_strongtower.bsp");
		precache_model ("maps/buildables/scaffold_garrison.bsp");
		precache_model ("maps/buildables/scaffold_tower1.bsp");
		precache_model ("maps/buildables/scaffold_tower2.bsp");
		precache_model ("maps/buildables/scaffold_gmanse.bsp");
		precache_model ("maps/buildables/scaffold_church.bsp");
		precache_model ("maps/buildables/scaffold_nippon_house.bsp");
		precache_model ("maps/buildables/scaffold_nippon_shrine.bsp");
		precache_model ("maps/buildables/scaffold_nippon_dojo.bsp");
		precache_model ("maps/buildables/scaffold_arsenal.bsp");
		precache_model ("maps/buildables/scaffold_barracks.bsp");
		precache_model ("maps/buildables/scaffold_crusaderstronghold.bsp");
		precache_model ("maps/buildables/scaffold_wall_curtain.bsp");
		precache_model ("maps/buildables/scaffold_wall_curtain_tower.bsp");
		precache_model ("maps/buildables/scaffold_wall_fill.bsp");
		precache_model ("maps/buildables/scaffold_wall_small.bsp");
		precache_model ("maps/buildables/scaffold_wall_small_tower.bsp");
		precache_model ("maps/buildables/scaffold_chataeu.bsp");
		precache_model ("maps/buildables/scaffold_palladianmanor.bsp");
		precache_model ("maps/buildables/scaffold_field.bsp");
		precache_model ("maps/buildables/scaffold_vineyard.bsp");
		precache_model ("maps/buildables/scaffold_stonehouse.bsp");
		precache_model ("maps/buildables/scaffold_wall_interior.bsp");
		precache_model ("maps/buildables/scaffold_wall_interior_alcove.bsp");
		precache_model ("maps/buildables/scaffold_block_64.bsp");
		precache_model ("maps/buildables/scaffold_block_64_casing.bsp");
		precache_model ("maps/buildables/scaffold_block_64_casingside.bsp");
		precache_model ("maps/buildables/scaffold_block_64_pyramidion.bsp");
		precache_model ("maps/buildables/scaffold_block_64_corner.bsp");
		precache_model ("maps/buildables/scaffold_block_64_roundcorner.bsp");
		precache_model ("maps/buildables/scaffold_block_64_recessedcorner.bsp");
		precache_model ("maps/buildables/scaffold_block_64_stairs.bsp");
		precache_model ("maps/buildables/scaffold_block_64_casinginside.bsp");
		precache_model ("maps/buildables/scaffold_block_64_octoside.bsp");
		precache_model ("maps/buildables/scaffold_block_64_octoside2.bsp");
		precache_model ("maps/buildables/scaffold_block_64_stairs_side.bsp");
		precache_model ("maps/buildables/scaffold_block_64_stairs_inside.bsp");
		precache_model ("maps/buildables/scaffold_block_64_stairs_cheap.bsp");
		precache_model ("maps/buildables/scaffold_block_64_window.bsp");
		precache_model ("maps/buildables/scaffold_block_64_stake.bsp");
		precache_model ("maps/buildables/scaffold_block_64_door.bsp");
		precache_model ("maps/buildables/scaffold_foundation_wall.bsp");
		precache_model ("maps/buildables/scaffold_foundation_bridge.bsp");
		precache_model ("maps/buildables/scaffold_foundation_tower.bsp");
		precache_model ("maps/buildables/scaffold_foundation_tower_round.bsp");
		precache_model ("maps/buildables/scaffold_vault_roof.bsp");
		precache_model ("maps/buildables/scaffold_vault_roof_end.bsp");
		precache_model ("maps/buildables/scaffold_vault_roof_one.bsp");
		precache_model ("maps/buildables/scaffold_vault_roof_dome.bsp");
		precache_model ("maps/buildables/scaffold_bridge.bsp");
		precache_model ("maps/buildables/scaffold_floor.bsp");
		precache_model ("maps/buildables/scaffold_sniperspire.bsp");
		precache_model ("maps/buildables/scaffold_big.bsp");
		
		precache_model ("maps/buildables/rubble_woodbar_block64.bsp");
		precache_model ("maps/buildables/rubble_ironbar_block64.bsp");
		
		precache_model ("maps/buildables/rubble_stone_512.bsp");
		precache_model ("maps/buildables/rubble_blackbrick_512.bsp");
		precache_model ("maps/buildables/rubble_brick_512.bsp");
		precache_model ("maps/buildables/rubble_limestone_512.bsp");
		precache_model ("maps/buildables/rubble_wmarble_512.bsp");
		precache_model ("maps/buildables/rubble_foundationstone_512.bsp");
		precache_model ("maps/buildables/rubble_cliffstone_512.bsp");
		precache_model ("maps/buildables/rubble_dirt_512.bsp");
		precache_model ("maps/buildables/rubble_woodbeams_512.bsp");
		precache_model ("maps/buildables/rubble_blackbrick_block64.bsp");
		precache_model ("maps/buildables/rubble_brick_block64.bsp");
		precache_model ("maps/buildables/rubble_cliffstone_block64.bsp");
		precache_model ("maps/buildables/rubble_concrete_block64.bsp");
		precache_model ("maps/buildables/rubble_concretedark_block64.bsp");
		precache_model ("maps/buildables/rubble_concreteplain_block64.bsp");
		precache_model ("maps/buildables/rubble_dirt_block64.bsp");
		precache_model ("maps/buildables/rubble_filled_block64.bsp");
		precache_model ("maps/buildables/rubble_foundationstone_block64.bsp");
		precache_model ("maps/buildables/rubble_graybrick_block64.bsp");
		precache_model ("maps/buildables/rubble_limestone_block64.bsp");
		precache_model ("maps/buildables/rubble_sandstonelight_block64.bsp");
		precache_model ("maps/buildables/rubble_shingles2_block64.bsp");
		precache_model ("maps/buildables/rubble_shingles_block64.bsp");
		precache_model ("maps/buildables/rubble_stone_block64.bsp");
		precache_model ("maps/buildables/rubble_wmarble_block64.bsp");
		precache_model ("maps/buildables/rubble_wood1_block64.bsp");
		precache_model ("maps/buildables/rubble_wood2_block64.bsp");
		precache_model ("maps/buildables/rubble_woodbeams_block64.bsp");
		precache_model ("maps/buildables/door_up_med_metal1.bsp");
		precache_model ("maps/buildables/door_up_med_metal2.bsp");
		precache_model ("maps/buildables/door_up_small_metal1.bsp");
		}
		
		precache_model ("models/marker.md3");
		precache_sound ("object/impact_stone_1.ogg");
		precache_sound ("object/impact_stone_2.ogg");
		precache_sound ("object/impact_stone_3.ogg");
		precache_sound ("object/impact_stone_4.ogg");
		precache_sound ("object/impact_stone_5.ogg");
		precache_sound ("object/impact_metal_1.ogg");
		precache_sound ("object/impact_metal_2.ogg");
		precache_sound ("object/impact_metal_3.ogg");
		precache_sound ("object/impact_metal_4.ogg");
		precache_sound ("object/impact_metal_5.ogg");
		precache_sound ("object/impact_wood_1.ogg");
		precache_sound ("object/impact_wood_2.ogg");
		precache_sound ("object/impact_wood_3.ogg");
		precache_sound ("object/impact_wood_4.ogg");
		precache_sound ("object/impact_wood_5.ogg");
		precache_sound ("misc/decreasevalue.wav");
		precache_sound ("misc/increasevalue.wav");
		precache_sound("misc/menu2.wav");
		precache_sound ("weapons/shotgun_melee.wav");		
	}
	else if (req == WR_SETUP)
	{
		weapon_setup(WEP_MULTITOOL);
		self.current_ammo = ammo_nails;
		self.multitool_ammomax = 9997001; //Magic number that tells hud to display differently (999 Tool :P)
		addstat(STAT_VEHICLESTAT_AMMO1_CURRENT,   AS_INT, vehicle_ammo1_current);
		addstat(STAT_VEHICLESTAT_AMMO1_MAX,   AS_INT, vehicle_ammo1_max);
		addstat(STAT_VEHICLESTAT_AMMO2_CURRENT,   AS_INT, vehicle_ammo2_current);
		addstat(STAT_VEHICLESTAT_AMMO2_MAX,   AS_INT, vehicle_ammo2_max);
		multitool_updateammo();
		self.multitool_update3dscaf = 1;
		self.multitool_setting = self.multitool_only_lastset;
	}
	else if (req == WR_CHECKAMMO1)
	{
        ammo_amount = self.ammo_nails >= autocvar_g_balance_multitool_ammo;

		if(autocvar_g_balance_multitool_reload_ammo)		
            ammo_amount += self.(weapon_load[WEP_MULTITOOL]) >= autocvar_g_balance_multitool_ammo;
		
		return ammo_amount;
	}
	else if (req == WR_CHECKAMMO2)
	{
        ammo_amount = self.ammo_nails >= autocvar_g_balance_multitool_ammo;

		if(autocvar_g_balance_multitool_reload_ammo)
            ammo_amount += self.(weapon_load[WEP_MULTITOOL]) >= autocvar_g_balance_multitool_ammo;
		
		return ammo_amount;
	}
	else if (req == WR_PLAYERDEATH)
	{
		self.multitool_lit = 0;	
	}
	else if (req == WR_RELOAD)
	{
		if (self.multitool_jammed) {
			weapon_thinkf(WFRAME_RELOAD, autocvar_g_balance_multitool_clearjam_time, w_ready);
			self.multitool_jammed = 0;
			self.multitool_click = 0;
			if ((clienttype(self) == CLIENTTYPE_REAL)) {
				sprint(self, "You fixed the malfunction\n");
			}
		} else {
			//W_Reload(autocvar_g_balance_multitool_ammo, autocvar_g_balance_multitool_reload_ammo, autocvar_g_balance_multitool_reload_time, "weapons/reload.wav");
			self.multitool_click = 0;
			
			if(self.BUTTON_CROUCH) {
				if (self.ammo_rockets) {
					vehicles_replenishAmmo(self, self, ammo_rockets, multitool_ammocurrentr, multitool_ammomax, self.ammo_rockets, 1);
					sound (self, CH_WEAPON_A, "weapons/reload.wav", VOL_BASE * 0.35, ATTN_NORM);
					multitool_updateammo();
				}
			} else if(self.BUTTON_USE) {
				if (self.ammo_cells) {
					vehicles_replenishAmmo(self, self, ammo_cells, multitool_ammocurrentc, multitool_ammomax, self.ammo_cells, 1);
					sound (self, CH_WEAPON_A, "weapons/reload.wav", VOL_BASE * 0.35, ATTN_NORM);
					multitool_updateammo();
				}
			} else if(self.BUTTON_HOOK) {
				if (self.ammo_nails) {
					vehicles_replenishAmmo(self, self, ammo_nails, multitool_ammocurrent, multitool_ammomax, self.ammo_nails, 1);
					sound (self, CH_WEAPON_A, "weapons/reload.wav", VOL_BASE * 0.35, ATTN_NORM);
					multitool_updateammo();
				}
			} else {
				if (time > self.multitool_nextrepair) {
					self.multitool_nextrepair = time + 0.2;
					multitool_repairbuilding(self, autocvar_g_balance_multitool_primary_damage * 5);
				}
			}
		}
	}
	return TRUE;
}
#endif
#ifdef CSQC
float w_multitool(float req)
{
	if(req == WR_IMPACTEFFECT)
	{
		vector org2;
		org2 = w_org + w_backoff * 2;
		pointparticles(particleeffectnum("machinegun_impact"), org2, w_backoff * 1000, 1);
		if(!w_issilent)
			if(w_random < 0.05)
				sound(self, CH_SHOTS, "weapons/ric1.wav", VOL_BASE, ATTN_NORM);
			else if(w_random < 0.1)
				sound(self, CH_SHOTS, "weapons/ric2.wav", VOL_BASE, ATTN_NORM);
			else if(w_random < 0.2)
				sound(self, CH_SHOTS, "weapons/ric3.wav", VOL_BASE, ATTN_NORM);
	}
	else if(req == WR_PRECACHE)
	{
		precache_sound("weapons/ric1.wav");
		precache_sound("weapons/ric2.wav");
		precache_sound("weapons/ric3.wav");
	}
	else if (req == WR_SUICIDEMESSAGE)
		w_deathtypestring = _("%s is now thinking with portals and multitools");
	else if (req == WR_KILLMESSAGE)
	{
		w_deathtypestring = _("%s was beaten with pliers by %s");
	}
	return TRUE;
}
#endif
#endif


//void spawnfunc_weapon_multitool()
//{    
//	weapon_defaultspawnfunc(WEP_MULTITOOL);
//}
